;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB_drv.asm
;;  Version: 1.5, Updated on 2008/9/10 at 16:20:2
;;  Generated by PSoC Designer ???
;;
;;  DESCRIPTION: USB Device User Module control endpoint driver
;;               for the CY8C24090 and CY7C64215 family of devices
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2005. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "USB_macros.inc"
include "USB.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
export  USB_EP0_ISR
export _USB_EP0_ISR
export  USB_InitControlRead
export _USB_InitControlRead
export  USB_InitControlWrite
export _USB_InitControlWrite
export  USB_InitNoDataStageControlTransfer
export _USB_InitNoDataStageControlTransfer
export  USB_NoDataStageControlTransfer

;-----------------------------------------------
;  Macro Definitions
;-----------------------------------------------

;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------

;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
AREA InterruptRAM (RAM, REL, CON)
;----------------------------------------------------------------------------
; Current Device
;----------------------------------------------------------------------------
export USB_bCurrentDevice, _USB_bCurrentDevice
 USB_bCurrentDevice:
_USB_bCurrentDevice:                    BLK   1    ;  Current Device
;----------------------------------------------------------------------------
; Current Configuration
;----------------------------------------------------------------------------
export USB_Configuration, _USB_Configuration
 USB_Configuration:
_USB_Configuration:                     BLK   1    ;  Current Configuration
;----------------------------------------------------------------------------
; Current Device Status
;----------------------------------------------------------------------------
export USB_DeviceStatus, _USB_DeviceStatus
 USB_DeviceStatus:
_USB_DeviceStatus:                      BLK   1    ;  Current Device Status
;----------------------------------------------------------------------------
; Interface Setting
;----------------------------------------------------------------------------
;  User Module Parameter determines the number of interfaces
export USB_InterfaceSetting, _USB_InterfaceSetting
 USB_InterfaceSetting:
_USB_InterfaceSetting:                  BLK   1h    ; Interface Setting
;----------------------------------------------------------------------------
; Endpoint Status--USB Status
;----------------------------------------------------------------------------
export USB_EndpointStatus, _USB_EndpointStatus
 USB_EndpointStatus:
_USB_EndpointStatus:                    BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
;----------------------------------------------------------------------------
; Last Packet Size
;----------------------------------------------------------------------------
export USB_LastSize
 USB_LastSize:                          BLK   1    ; Last Packet Size
;----------------------------------------------------------------------------
; Control Transfer State Machine
; State values for Control Write
; State values for Control Read
;----------------------------------------------------------------------------
export USB_TransferType
 USB_TransferType:                      BLK   1    ; Control Transfer State Machine
;----------------------------------------------------------------------------
; Control Transfer Intermediate Buffer--Shared among the requests
;----------------------------------------------------------------------------
export USB_TransferBuffer
 USB_TransferBuffer:                    BLK   8
;----------------------------------------------------------------------------
; Transfer Descriptor Data for Control Transfer
;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
;----------------------------------------------------------------------------
; Control Transfer Data Source
;   USB_DS_ROM
;   USB_DS_RAM
;   USB_DS_RAM_AS_NEEDED
;----------------------------------------------------------------------------
export USB_CurrentTD, _USB_CurrentTD
_USB_CurrentTD:
 USB_CurrentTD:
export USB_DataSource, _USB_DataSource
_USB_DataSource:
 USB_DataSource:                        BLK   1
;----------------------------------------------------------------------------
; Control Transfer Data Size
;----------------------------------------------------------------------------
export USB_TransferSize, _USB_TransferSize
_USB_TransferSize:
 USB_TransferSize:                      BLK   2
;----------------------------------------------------------------------------
; Control Transfer Data Pointer
;   Source for Control Read
;   Destination for Control Write
;----------------------------------------------------------------------------
export USB_DataPtr, _USB_DataPtr
_USB_DataPtr:
 USB_DataPtr:                           BLK   2
;----------------------------------------------------------------------------
; Transfer Completion Notification
;----------------------------------------------------------------------------
export USB_StatusBlockPtr, _USB_StatusBlockPtr
_USB_StatusBlockPtr:
 USB_StatusBlockPtr:                    BLK   2

;----------------------------------------------------------------------------
; Control Transfer _TransferByteCount (Actually transfered
;----------------------------------------------------------------------------
 USB_TransferByteCount:                 BLK   2

;----------------------------------------------------------------------------
; Control Endpoint Data toggle / krypton uses this ONLY for EP0  
; For 20x6x devices: See USB_EPXDataToggle defined in usb.asm
export USB_EPDataToggle, _USB_EPDataToggle
 _USB_EPDataToggle:
 USB_EPDataToggle:
 USB_EP0DataToggle:                     BLK   1
;----------------------------------------------------------------------------
; Control Endpoint Data Pending Flag
export USB_fDataPending
 USB_fDataPending:                      BLK   1
;----------------------------------------------------------------------------
; Control Endpoint Data Pending Flag
;export USB_PendingData
; USB_PendingData:                      BLK   1
;----------------------------------------------------------------------------
; Temporary Data registers
export USB_t2, USB_t1, USB_t0
 USB_t2:                                BLK   1    ; Temporary shared by the UM
 USB_t1:                                BLK   1    ; Temporary shared by the UM
 USB_t0:                                BLK   1    ; Temporary shared by the UM

;export USB_IntState
; USB_IntState:                         BLK  1
;export USB_StackPointer
; USB_StackPointer:                     BLK  1
;export USB_TempMode
; USB_TempMode:                         BLK 1
;----------------------------------------------------------------------------
; Endpoint Transfer--API Status
;----------------------------------------------------------------------------
export USB_EndpointAPIStatus, _USB_EndpointAPIStatus
 USB_EndpointAPIStatus:
_USB_EndpointAPIStatus:                 BLK   USB_NUM_ENDPOINTS    ; Endpoint Status

IF 1
ELSE
ERROR_RUN_USB_WIZARD
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; In order for the USB User Module to compile properly the USB Wizard must be run.
; To do this navigate back to the Device Editor Window, right click on the icon for the
; USB User Module and select the 'USB Setup Wizard...'.  Configure the device as needed
; and then click OK.  Re-generate source before compiling again.
; For HID devices it is important that all instances of HID Class Descriptors point to a valid
; HID report.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIF

AREA UserModules (ROM, REL)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_EP0_ISR

;
;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
;                 dispaches all SETUP, IN, and OUT transfers to the proper
;                 dispatch routines for all supported USB requests.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:   n/a
;
;  RETURNS:     n/a
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
 USB_EP0_ISR:
_USB_EP0_ISR:
    push    A
    push    X
    REG_PRESERVE MVW_PP
    REG_PRESERVE MVR_PP

    RAM_SETPAGE_MVW 0
    RAM_SETPAGE_MVR 0

    ; Dispatch to setup/in/out handlers
    mov     A, reg[USB_EP0MODE]         ; Get the mode reg

 ;   mov  [USB_TempMode], USB_MODE_NAK_IN_OUT
 ;   mov  reg[USB_EP0MODE], USB_MODE_NAK_IN_OUT
    ; MSB is the SETUP bit, followed by IN, then OUT
    asl     A                           ; Shift to the carry and jump if SETUP bit set
    jc      USB_EP0_Setup

    asl     A                           ; Shift to the carry and jump if IN bit set
    jc      USB_EP0_IN

    asl     A                           ; Shift to the carry and jump if OUT bit set
    jc      USB_EP0_OUT

    jmp     USB_Not_Supported_Local_Drv

; ISR Exit Point to update the mode register
;   mode and count have been pushed onto the stack
export USB_EP0_UPD_MODE_EXIT
USB_EP0_UPD_MODE_EXIT:

    mov     reg[USB_EP0CNT], A         ; Update the count
    mov     A, X                       ; Get the new mode
    mov     reg[USB_EP0MODE], A        ; Update the node

; Common Exit Point
USB_EP0_ISR_EXIT:
    REG_RESTORE MVR_PP
    REG_RESTORE MVW_PP
    pop     X                           ;
;       mov  A, [USB_TempMode]
;       mov  reg[USB_EP0MODE], A
    pop     A                           ; Restore Context
    reti


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_EP0_Setup
;
;  DESCRIPTION:   Dispatch a USB SETUP
;
;-----------------------------------------------------------------------------
 USB_EP0_Setup:
_USB_EP0_Setup:
; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
    push    A                          ; Save the mode register
    mov     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
    call    USB_UpdateStatusBlock
    pop     A                          ; Restore the mode register
    mov     A, reg[USB_EP0CNT]               ; Get the count reg
    cmp     A, (USB_CNT_VALID | 0x0A)
    jz      .dispatch

    jmp     USB_Not_Supported_Local_Drv


;-----------------------------------------------------------------------------
; Jump here to dispatch the request
; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
; 7, 6, 5, 1, 0 determine what the request is. Bits [2:4] are default to zero. The below code
; re-organizes [bmRequestType] to the following format:
; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
; "re-organization", the firmware will jump to an appropriate table to handle the request.
;-----------------------------------------------------------------------------
.dispatch:
    mov     A, reg[USB_EP0DATA+bmRequestType]   ; Get bmRequestType
    and     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
    push    A                                ; store value on the stack
    asr     A                                ; move bits 7-6-5 into 4-3-2's place
    asr     A                                ; "asr" instruction shift all bits one place to the right.
    asr     A                                ; Bit7 remains the same.
    mov     [USB_t2], A                      ; store shifted value
    pop     A                                ; get original value
    or      A, [USB_t2]                      ; or the two to get the 5-bit field
    and     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                             ; Bit0 is loaded with a Zero. This results in multiplying
                                             ; the accumulator by 2, and the reason to mutiply it by 2
                                             ; is that each "jmp" instruction in the tables is two bytes long.

    ljmp    USB_bmRequestType_Dispatch


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_EP0_IN
;
;  DESCRIPTION: Handles an IN request.  Depending on the state of the
;               enumeration sequence it decides what to do next
;
;-----------------------------------------------------------------------------
 USB_EP0_IN:
_USB_EP0_IN:

    mov     A, [USB_TransferType]
;    call USB_ControlInDispatch
;    jmp  USB_EP0_ISR_EXIT                   ; And exit
USB_ControlInDispatch:
    jacc    USB_ControlInDispatchTable
.LITERAL
USB_ControlInDispatchTable:
    jmp     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
    jmp     USB_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
    jmp     USB_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
    jmp     USB_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
.ENDLITERAL


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_EP0_OUT
;
;  DESCRIPTION: HANDles an OUT request.  Depending on the state of the
;               enumeration sequence it decides what to do next
;
;-----------------------------------------------------------------------------
 USB_EP0_OUT:
_USB_EP0_OUT:
    mov     A, [USB_TransferType]
    jacc    USB_ControlOutDispatchTable
.LITERAL
USB_ControlOutDispatchTable:
    jmp     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
    jmp     USB_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
    jmp     USB_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
    jmp     USB_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
.ENDLITERAL


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_InitControlRead
;
;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
;                 not called.  It assumes a tranfer descriptor has been loaded
;                 into the driver USB_CurrentTD data structure.
;
;-----------------------------------------------------------------------------
 USB_InitControlRead:
_USB_InitControlRead:
    mov     [USB_LastSize], A          ; Save the packet size?
    call    USB_InitializeStatusBlock
    mov     [USB_TransferType], USB_TRANS_STATE_CONTROL_READ

    ; Check the transfer size against the request size
    mov     A, reg[USB_EP0DATA+wLengthHi]   ; MSB of wLength
    cmp     A, [USB_TransferSize]
    jnz     .L1

    mov     A, reg[USB_EP0DATA+wLengthLo]   ; LSB of wLength
    cmp     A, [USB_TransferSize+1]
    jz      .L9
.L1:
    jnc     .L9
;
    mov    [USB_TransferSize+1], A     ;
    mov    A, reg[USB_EP0DATA+wLengthHi]   ;
    mov    [USB_TransferSize], A       ;
.L9:
    mov    [USB_TransferByteCount], 0  ;
    mov    [USB_TransferByteCount+1], 0   ;

    or     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
    jmp    USB_LoadEndpoint            ;
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_ControlReadDataStage
;
;  DESCRIPTION:   This routine processes the data stage of a control read.  It
;                 must be JUMPed to, not called.  It assumes a tranfer descriptor
;                 has been loaded into the driver USB_CurrentTD
;                 data structure.
;
;-----------------------------------------------------------------------------
 USB_ControlReadDataStage:
    jmp     USB_LoadEndpoint

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_ControlReadStatusStage
;
;  DESCRIPTION:   This routine processes the status stage of a control read.  It
;                 must be JUMPed to, not called.  It handles short or 0 packet
;                 It assumes a tranfer descriptor has been loaded into the
;                 driver USB_CurrentTD data structure.
;
;-----------------------------------------------------------------------------
 USB_ControlReadStatusStage:
    mov    A, [USB_LastSize]           ; Get the number of bytes from the last transfer
    add    [USB_TransferByteCount + 1], A   ; Update the transfer byte count
    adc    [USB_TransferByteCount], 0  ;
    mov    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
    call   USB_UpdateStatusBlock
    mov    [USB_TransferType], USB_TRANS_STATE_IDLE
    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STALL_IN_OUT
    jmp    USB_EP0_UPD_MODE_EXIT
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_NoDataStageControlTransfer
;                 USB_InitNoDataStageControlTransfer
;
;  DESCRIPTION:   This routine processes the status stage of a no data control
;                 write.  It must be JUMPed to, not called.
;
;-----------------------------------------------------------------------------
 USB_NoDataStageControlTransfer:
_USB_InitNoDataStageControlTransfer:
 USB_InitNoDataStageControlTransfer:
    call    USB_InitializeStatusBlock

    mov    [USB_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL

    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STATUS_IN_ONLY
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_InitControlWrite
;
;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
;                 to, not called.  It assumes a tranfer descriptor has been loaded
;                 into the driver USB_CurrentTD data structure.
;
;-----------------------------------------------------------------------------
 USB_InitControlWrite:
_USB_InitControlWrite:
    mov     A, [USB_DataSource]        ; Need to make sure the destination is not ROM
    cmp     A, USB_DS_ROM
    jz      USB_Not_Supported_Local_Drv

    call    USB_InitializeStatusBlock

    mov    [USB_TransferType], USB_TRANS_STATE_CONTROL_WRITE

    or     [USB_EP0DataToggle], 1 ; setup EP0 data toggle

    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_ACK_OUT_STATUS_IN
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_ControlWriteDataStage
;
;  DESCRIPTION:   This routine processes the data stage of a control
;                 write.  It must be JUMPed to, not called.  It assumes a
;                 tranfer descriptor has been loaded into the driver
;                 USB_CurrentTD data structure.
;
;-----------------------------------------------------------------------------
 USB_ControlWriteDataStage:
    xor    [USB_EP0DataToggle], 1      ; Update data toggle

    mov    A, reg[USB_EP0CNT]          ; Get the count

    and     A, 0x0F
    sub     A, 2                       ; Count include the two byte checksum

    mov     [USB_t2], A                ; Assume we have room to receive the whole packet

    mov     A, 0
    cmp     A, [USB_TransferSize]      ; If the MSB has anything just use the count
    jnz     .L1

    mov     A, [USB_t2]
    cmp     A, [USB_TransferSize+1]    ;
    jz      .L6
.L1:
    jc      .L6
    mov     [USB_t2], [USB_TransferSize+1]

.L6:
    mov     A, [USB_t2]
    sub     [USB_TransferSize+1], A    ; Update the bytes remaining
    sbb     [USB_TransferSize], 0      ;

    add     [USB_TransferByteCount + 1], A   ; Update the transfer byte count
    adc     [USB_TransferByteCount], 0   ;

    mov     X, 0                       ; Start the index at 0

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_PRESERVE MVW_PP
    mov     A, [USB_DataPtr]  ; set proper page for mvi command
    mov     reg[MVW_PP], A
ENDIF

.RAM_COPY:
    mov     A, reg[X+USB_EP0DATA]      ; Get the data
    mvi     [USB_DataPtr+1], A         ; Store the data, bump the destination

    inc     X                          ; Bump the destination offset
    mov     A, X                       ; Are we done?
    cmp     A, [USB_t2]
    jc      .RAM_COPY                  ; Not done

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE MVW_PP
ENDIF

    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_ACK_OUT_STATUS_IN
    jmp    USB_EP0_UPD_MODE_EXIT

; Jump here on data toggle error
.error:
    mov    [USB_TransferType], USB_TRANS_STATE_IDLE    ; This simply aborts the transfer
    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STALL_IN_OUT
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_ControlWriteStatusStage
;
;  DESCRIPTION:   This routine processes the status stage of a control
;                 write.  It must be JUMPed to, not called.  It assumes a
;                 tranfer descriptor has been loaded into the driver
;                 USB_CurrentTD data structure.
;
;-----------------------------------------------------------------------------
 USB_ControlWriteStatusStage:
    mov    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
    call   USB_UpdateStatusBlock
    mov    [USB_TransferType], USB_TRANS_STATE_IDLE    ; The packet is done
    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STALL_IN_OUT
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_NoDataControlStatusStage
;
;  DESCRIPTION:   This routine processes the status stage of a control
;                 write.  It must be JUMPed to, not called.  It assumes a
;                 tranfer descriptor has been loaded into the driver
;                 USB_CurrentTD data structure.
;
;                 USB Device Addressing happens here because we can't change
;                 the SIE Address before the Status IN is received.
;
;-----------------------------------------------------------------------------
 USB_NoDataControlStatusStage:
    mov     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
    call    USB_UpdateStatusBlock
    ; Dispatch to the proper handler
    cmp     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING
    jnz     .L1

    ; USB ADDRESS CHANGE
    mov     A, [USB_TransferBuffer]    ; Get the pending data

    or      A, USB_ADDR_ENABLE         ; Set the enable bit
    mov     reg[USB_ADDR], A           ; Update the SIE address
    jmp     .EXIT
.L1:

.EXIT:
    mov     [USB_fDataPending], 0      ; Clear data pending

    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_NoDataControlError
;
;  DESCRIPTION:   This routine handles the condition when we expected a
;                 status IN, but receive an OUT
;
;-----------------------------------------------------------------------------
 USB_NoDataControlError:
    mov    A, USB_XFER_ERROR           ; Return Transaction Error
    call   USB_UpdateStatusBlock
    mov    A, 0                        ; Count Register
    mov    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_LoadEndpoint
;
;  DESCRIPTION: Moves data from either RAM or ROM - depending on the request
;               type and then places the appropriate number of bytes -
;               depending on the request size into the endpoint FIFO.
;               It finally sets up the endpoint to send data.
;
USB_LoadEndpoint:
    mov     A, [USB_LastSize]          ; Get the number of bytes from the last transfer
    add     [USB_TransferByteCount + 1], A   ; Update the transfer byte count
    adc     [USB_TransferByteCount], 0   ;
    mov     A,  [USB_TransferSize]     ; Check to see if we have any
    or      A,  [USB_TransferSize+1]   ;  more data to send
    jnz     .cont                      ; Jump if we have to send more data

; Flow here if there is no more data to send
    cmp     [USB_LastSize], 8          ; Was it a full packet?
    JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)

; Flow here if we are entering the status stage
    mov     A, 0                       ; Count Register
    mov     [USB_LastSize], A          ; Clear the byte count
    mov     X, USB_MODE_STATUS_OUT_ONLY   ; Only ACK the Status Out
    jmp     USB_EP0_UPD_MODE_EXIT

; Jump here to determine how many bytes should we transfer
.cont:
    cmp     [USB_TransferSize], 0      ; Check the MSB
    jnz     .L1

    cmp     [USB_TransferSize+1], 8    ; Check the LSB
    jnc     .L1

    mov     A, [USB_TransferSize+1]    ; Transfer all the remaing data
    jmp     .L3

.L1:
    mov     A, 8                       ; Just transfer the next 8 bytes

.L3:

    sub     [USB_TransferSize+1], A    ; Update the bytes remaining
    sbb     [USB_TransferSize], 0
    mov     [USB_t2], A                ; Save the count
    mov     X, 0

    cmp     [USB_DataSource], USB_DS_ROM    ; RAM or ROM copy?
    jnz     .RAM_COPY

; Copy data from a ROM source
.ROM_COPY:
    push    X                          ; Save the destination offset
    mov     A, [USB_DataPtr]           ; Get the transfer source MSB
    mov     X, [USB_DataPtr+1]         ; Set the transfer source LSB
    inc     [USB_DataPtr+1]            ; Increment the data pointer
    adc     [USB_DataPtr], 0           ;   MSB if necessary

    romx                               ; Get the data byte

    pop     X                          ; Get the destination offset
    mov     reg[X + USB_EP0DATA], A    ; Load the data
    inc     X                          ; Bump the destination offset
    mov     A, X                       ; Are we done?
    cmp     A, [USB_t2]
    jc      .ROM_COPY                  ; Not done
    jmp     .START_TRANSFER            ; Otherwise go start the transfer

; Copy data from a RAM source
.RAM_COPY:
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_PRESERVE MVR_PP
    mov     A, [USB_DataPtr]  ; set proper page for mvi command
    mov     reg[MVR_PP], A
ENDIF
.CP1:
    mvi     A, [USB_DataPtr+1]         ; Get the data, bump the source

    mov     reg[X +USB_EP0DATA], A     ; Load the data
    inc     X                          ; Bump the destination offset
    mov     A, X                       ; Are we done?
    cmp     A, [USB_t2]
    jc      .CP1                       ; Not done

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE MVR_PP
    mov     A, X                       ; Restore A
ENDIF

;; Set up the IN transfer count/mode/etc
;    A contains the byte count
.START_TRANSFER:
    mov     [USB_LastSize], A          ; Save the packet size

    mov     A, 1
    and     A, [USB_EP0DataToggle]
    jz      .BYPASS_T1
    mov     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle

.BYPASS_T1:
    or      A, [USB_LastSize]
    xor     [USB_EP0DataToggle], 1     ; Update the data toggle for next time

    mov     X, USB_MODE_ACK_IN_STATUS_OUT    ; Set the mode register
    jmp    USB_EP0_UPD_MODE_EXIT


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_GetTableEntry
;
;  DESCRIPTION: This function figures out based on the various bytes in the
;               setup packet where to get the data from or put the data to.
;               Transfer Data structures are defined each of the supported
;               control transfers, this function finds the right one and
;               saves it in the CurrentTD structure in RAM.  It then
;               calls InitControlRead or InitControlWrite to being the
;               transaction.
;
;-----------------------------------------------------------------------------
export USB_GetTableEntry
USB_GetTableEntry:

    inc     X                          ; Point to the first table entry
    adc     A, 0                       ;

    TD_INDEX_TO_OFFSET USB_t2 ; Convert the index

    swap    A, X
    add     A, [USB_t2]
    swap    A, X
    adc     A, 0                       ; A:X now points to the descriptor table entry we want

; Flow here to load the Transfer Descriptor (TD_ENTRY)
    mov     [USB_t2], USB_CurrentTD    ; Use Temp as mvi pointer
    call     USB_GETBYTE               ; Get the descriptor data source
    call     USB_GETWORD               ; Get the descriptor size
    call     USB_GETWORD               ; Get the descriptor address
    call     USB_GETWORD               ; Get the Status Pointer
; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
    mov     A, reg[USB_EP0DATA+bmRequestType] ; Get bmRequestType
    and     A, 0x80                         ; Control Read or Write
    jz      .control_write

    jmp     USB_InitControlRead

.control_write:
    jmp     USB_InitControlWrite


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_LOOKUP
;
;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A:X Point to the lookup table
;                USB_t2 contain the table index
;
;  RETURNS:      Address of the LT_ENTRY in A:X
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export USB_LOOKUP
USB_LOOKUP:
    inc     X                          ; Point to the first table entry
    adc     A, 0                       ;

    LT_INDEX_TO_OFFSET USB_t2          ; Convert the index
    swap    A, X
    add     A, [USB_t2]                ;
    swap    A, X
    adc     A, 0
    ret


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_GETWORD/USB_GETBYTE
;
;  DESCRIPTION:    Get a word value from ROM
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A:X is the ROM Address
;                USB_t2 is the destination address
;
;  RETURNS:      USB_t1
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;                USES USB_t2
;                A:X points to the subsequent locaction ROM location
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export USB_GETWORD
USB_GETWORD:

    push    A                          ; Don't loose the pointer MSB
    romx                               ; Data source flag
    mvi     [USB_t2], A                ; Save the data source
    pop     A                          ; Get the MSB back
    inc     X                          ; Point to the next  entry
    adc     A, 0                       ;

export USB_GETBYTE
USB_GETBYTE:

    push    A                          ; Don't loose the pointer MSB
    romx                               ; Data source flag
    mvi     [USB_t2], A                ; Save the data source
    pop     A                          ; Get the MSB back
    inc     X                          ; Point to the next  entry
    adc     A, 0                       ;
    ret


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_GET_DEVICE_TABLE_ENTRY
;
;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
;                  Not intended for use by C fucntions
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:        A:X points the the current DEVICE_TABLE entry
;                  Carry flag is set if the current device index is out of range
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export USB_GET_DEVICE_TABLE_ENTRY
USB_GET_DEVICE_TABLE_ENTRY:
    mov     [USB_t2], [USB_bCurrentDevice]    ; Use the UM temp var--Selector

    mov     A, >USB_DEVICE_LOOKUP      ; Get the ROM Address MSB
    mov     X, <USB_DEVICE_LOOKUP      ; Get the ROM Address LSB
    romx                               ; First entry is the table size (only a byte)
    cmp     A, [USB_t2]                ; Range check
    mov     A, >USB_DEVICE_LOOKUP      ; Get the ROM Address MSB
    jc      .exit
; Flow here if the index is valid
    call    USB_LOOKUP                 ; Look up the configuration
; Jump or flow here on exit
.exit:
    ret


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_GET_CONFIG_TABLE_ENTRY
;
;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
;                  Not intended fOR use by C fucntions
;                  Does not do range checking on
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:        A:X points the the current CONFIG_TABLE entry
;                  Carry flag is set if the current device index is out of range
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export USB_GET_CONFIG_TABLE_ENTRY
USB_GET_CONFIG_TABLE_ENTRY:
    call    USB_GET_DEVICE_TABLE_ENTRY    ; Get the selected device
    mov     [USB_t2], USB_t1           ; Set the GETWORD destination
    call    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the configuration number
    mov     [USB_t2], A                ; Save it
    mov     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
    mov     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB

; A:X Points to the CONFIG_LOOKUP, so get the current entry
    mov     [USB_t2], [USB_Configuration]   ; Get the configuration number
    DEC     [USB_t2]                   ; We don't populate the 0th entry
    call    USB_LOOKUP                 ; Look up the configuration
    ret


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_UpdateStatusBlock
;
;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
;                  block is updated with the completion code from the
;                  argument (A) and the _TransferByteCount.
;
;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
;                  to make sure no other updates are made to the StatusBlock by
;                  the USB User Module.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the Completion Status Code
;
;  RETURNS:        None
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
USB_UpdateStatusBlock:
    mov     X, [USB_StatusBlockPtr + 1]   ;
    swap    A, X                       ; Don't loose the completion code
    cmp     A, 0                       ; NULL?
    jz      .done                      ; No update on NULL
; Flow here to update the VSR Completion Status Block
    swap    A, X                       ; Completion code A, Pointer in X
    mov     [X + 0], A                 ; Update the completion Code
    mov     A, [USB_TransferByteCount]   ; Actual Byte Count MSB
    mov     [X + 1], A
    mov     A, [USB_TransferByteCount + 1]   ; Actual Byte Count LSB
    mov     [X + 2], A
    mov     [USB_StatusBlockPtr + 1], 0   ; Clear the Block Pointer
.done:
    ret                                ; All done


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_InitializeStatusBlock
;
;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
;                  The completion code is set to USB_XFER_IDLE.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      None
;
;  RETURNS:        None
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
USB_InitializeStatusBlock:
    mov     A, [USB_StatusBlockPtr + 1]   ;
    cmp     A, 0                       ; NULL?
    jz      .done                      ; No update on NULL
; Flow here to initialize the Completion Status Block
    swap    A, X                       ; Pointer in X
    mov     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
    mov     [USB_TransferByteCount], 0   ; Clear the byte count
    mov     [USB_TransferByteCount + 1], 0   ;
.done:
    ret                                ; All done


;-----------------------------------------------------------------------------
;  FUNCTION NAME: ;  USB 1st Tier Dispactch Jump Table (based on bmRequestType)
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
MACRO BMREQUEST_DISPATCH
IF (USB_CB_@0_@1_@2 & 1)
    jmp     USB_DT_@0_@1_@2_Dispatch
ELSE
    jmp     USB_Not_Supported_Local_Drv
ENDIF
ENDM

USB_DT_bmRequestType::
    BMREQUEST_DISPATCH    h2d, std, dev
    BMREQUEST_DISPATCH    h2d, std, ifc
    BMREQUEST_DISPATCH    h2d, std, ep
    BMREQUEST_DISPATCH    h2d, std, oth
    BMREQUEST_DISPATCH    h2d, cls, dev
    BMREQUEST_DISPATCH    h2d, cls, ifc
    BMREQUEST_DISPATCH    h2d, cls, ep
    BMREQUEST_DISPATCH    h2d, cls, oth
    BMREQUEST_DISPATCH    h2d, vnd, dev
    BMREQUEST_DISPATCH    h2d, vnd, ifc
    BMREQUEST_DISPATCH    h2d, vnd, ep
    BMREQUEST_DISPATCH    h2d, vnd, oth
    BMREQUEST_DISPATCH    h2d, rsv, dev
    BMREQUEST_DISPATCH    h2d, rsv, ifc
    BMREQUEST_DISPATCH    h2d, rsv, ep
    BMREQUEST_DISPATCH    h2d, rsv, oth
    BMREQUEST_DISPATCH    d2h, std, dev
    BMREQUEST_DISPATCH    d2h, std, ifc
    BMREQUEST_DISPATCH    d2h, std, ep
    BMREQUEST_DISPATCH    d2h, std, oth
    BMREQUEST_DISPATCH    d2h, cls, dev
    BMREQUEST_DISPATCH    d2h, cls, ifc
    BMREQUEST_DISPATCH    d2h, cls, ep
    BMREQUEST_DISPATCH    d2h, cls, oth
    BMREQUEST_DISPATCH    d2h, vnd, dev
    BMREQUEST_DISPATCH    d2h, vnd, ifc
    BMREQUEST_DISPATCH    d2h, vnd, ep
    BMREQUEST_DISPATCH    d2h, vnd, oth
    BMREQUEST_DISPATCH    d2h, rsv, dev
    BMREQUEST_DISPATCH    d2h, rsv, ifc
    BMREQUEST_DISPATCH    d2h, rsv, ep
    BMREQUEST_DISPATCH    d2h, rsv, oth
USB_DT_End:
USB_DT_Size: equ (USB_DT_End-USB_DT_bmRequestType) / 2
USB_bmRequestType_Dispatch::
    DISPATCHER USB_DT_bmRequestType, USB_DT_Size, USB_Not_Supported_Local_Drv

USB_Not_Supported_Local_Drv:
    ljmp     USB_Not_Supported


;-----------------------------------------------
; Add custom application code for routines
;-----------------------------------------------

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

; End of File USB_drv.asm
