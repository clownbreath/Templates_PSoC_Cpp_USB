0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;@Id: boot.tpl#848 @
                                   (0004) ;=============================================================================
                                   (0005) ;  FILENAME:   boot.asm
                                   (0006) ;  VERSION:    4.18
                                   (0007) ;  DATE:       28 june 2007
                                   (0008) ;
                                   (0009) ;  DESCRIPTION:
                                   (0010) ;  M8C Boot Code for CY8C24x90 microcontroller devices.
                                   (0011) ;
                                   (0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0013) ;
                                   (0014) ; NOTES:
                                   (0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0016) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0017) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                   (0020) ; are not accidentally modified.
                                   (0021) ;
                                   (0022) ;=============================================================================
                                   (0023) 
                                   (0024) include ".\lib\GlobalParams.inc"
                                   (0025) include "m8c.inc"
                                   (0026) include "m8ssc.inc"
                                   (0027) include "memory.inc"
                                   (0028) 
                                   (0029) ;--------------------------------------
                                   (0030) ; Export Declarations
                                   (0031) ;--------------------------------------
                                   (0032) 
                                   (0033) export __Start
                                   (0034) IF	(TOOLCHAIN & HITECH)
                                   (0035) ELSE
                                   (0036) export __bss_start
                                   (0037) export __data_start
                                   (0038) export __idata_start
                                   (0039) export __func_lit_start
                                   (0040) export __text_start
                                   (0041) ENDIF
                                   (0042) export  _bGetPowerSetting
                                   (0043) export   bGetPowerSetting
                                   (0044) 
                                   (0045) 
                                   (0046) ;--------------------------------------
                                   (0047) ; Optimization flags
                                   (0048) ;--------------------------------------
                                   (0049) ;
                                   (0050) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0051) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0052) ; this file.
                                   (0053) 
                                   (0054) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0055) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0056) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0057) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0058) ;
                                   (0059) IF	(TOOLCHAIN & HITECH)
                                   (0060) ; The C compiler will customize the startup code - it's not required here
                                   (0061) 
                                   (0062) C_LANGUAGE_SUPPORT:              equ 0
                                   (0063) ELSE
                                   (0064) C_LANGUAGE_SUPPORT:              equ 1
                                   (0065) ENDIF
                                   (0066) 
                                   (0067) 
                                   (0068) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0069) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0070) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0071) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0072) ; bytes on the stack which are otherwise required for the return address. If
                                   (0073) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0074) ; release, the C compiler automatically places an infinite loop at the end
                                   (0075) ; of main, rather than a return instruction.)
                                   (0076) ;
                                   (0077) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0078) 
                                   (0079) 
                                   (0080) ;-----------------------------------------------------------------------------
                                   (0081) ; Interrupt Vector Table
                                   (0082) ;-----------------------------------------------------------------------------
                                   (0083) ;
                                   (0084) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0085) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0086) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0087) ; vector jump targets are modified automatically according to the user
                                   (0088) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0089) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0090) ; configuration files. If you need to hard code a vector, update the
                                   (0091) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0092) ; of this file.
                                   (0093) ;-----------------------------------------------------------------------------
                                   (0094) 
                                   (0095)     AREA TOP (ROM, ABS, CON)
                                   (0096) 
                                   (0097)     org   0                        ;Reset Interrupt Vector
                                   (0098) IF	(TOOLCHAIN & HITECH)
                                   (0099) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0100) ELSE
                                   (0101)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0102) ENDIF
                                   (0103) 
                                   (0104)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                (0105)     halt                           ;Stop execution if power falls too low
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0106) 
                                   (0107)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0108)     // call	void_handler
0008: 7E       RETI                (0109)     reti
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0110) 
                                   (0111)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                   (0112)     // call	void_handler
000C: 7E       RETI                (0113)     reti
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
0010: 30       HALT  
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
0014: 30       HALT  
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0114) 
                                   (0115)     org   18h                      ;VC3 Interrupt Vector
                                   (0116)     // call	void_handler
0018: 7E       RETI                (0117)     reti
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0118) 
                                   (0119)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0120)     // call	void_handler
001C: 7E       RETI                (0121)     reti
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0122) 
                                   (0123)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0124)     // call	void_handler
0020: 7E       RETI                (0125)     reti
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0126) 
                                   (0127)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0128)     // call	void_handler
0024: 7E       RETI                (0129)     reti
0025: 30       HALT  
0026: 30       HALT  
0027: 30       HALT  
                                   (0130) 
                                   (0131)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0132)     // call	void_handler
0028: 7E       RETI                (0133)     reti
0029: 30       HALT  
002A: 30       HALT  
002B: 30       HALT  
                                   (0134) 
                                   (0135)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0136)     // call	void_handler
002C: 7E       RETI                (0137)     reti
002D: 30       HALT  
002E: 30       HALT  
002F: 30       HALT  
0030: 30       HALT  
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
0034: 30       HALT  
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
0038: 30       HALT  
0039: 30       HALT  
003A: 30       HALT  
003B: 30       HALT  
003C: 30       HALT  
003D: 30       HALT  
003E: 30       HALT  
003F: 30       HALT  
                                   (0138) 
                                   (0139)     org   40h                      ;USB Reset Interrupt Vector
0040: 7D 0F 91 LJMP  USB_RESET_ISR (0140)     ljmp	_USB_RESET_ISR
0043: 7E       RETI                (0141)     reti
                                   (0142) 
                                   (0143)     org   44h                      ;USB SOF Interrupt Vector
0044: 7D 0F C0 LJMP  USB_SOF_ISR   (0144)     ljmp	_USB_SOF_ISR
0047: 7E       RETI                (0145)     reti
                                   (0146) 
                                   (0147)     org   48h                      ;USB EP0 Interrupt Vector
0048: 7D 06 AD LJMP  0x06AD        (0148)     ljmp	_USB_EP0_ISR
004B: 7E       RETI                (0149)     reti
                                   (0150) 
                                   (0151)     org   4Ch                      ;USB EP1 Interrupt Vector
004C: 7D 0F 55 LJMP  _USB_EP1_ISR  (0152)     ljmp	_USB_EP1_ISR
004F: 7E       RETI                (0153)     reti
                                   (0154) 
                                   (0155)     org   50h                      ;USB EP2 Interrupt Vector
0050: 7D 0F 64 LJMP  USB_EP2_ISR   (0156)     ljmp	_USB_EP2_ISR
0053: 7E       RETI                (0157)     reti
                                   (0158) 
                                   (0159)     org   54h                      ;USB EP3 Interrupt Vector
0054: 7D 0F 73 LJMP  _USB_EP3_ISR  (0160)     ljmp	_USB_EP3_ISR
0057: 7E       RETI                (0161)     reti
                                   (0162) 
                                   (0163)     org   58h                      ;USB EP4 Interrupt Vector
0058: 7D 0F 82 LJMP  _USB_EP4_ISR  (0164)     ljmp	_USB_EP4_ISR
005B: 7E       RETI                (0165)     reti
                                   (0166) 
                                   (0167)     org   5Ch                      ;USB Wakeup Interrupt Vector
005C: 7D 0F C1 LJMP  USB_WAKEUP_ISR(0168)     ljmp	_USB_WAKEUP_ISR
005F: 7E       RETI                (0169)     reti
                                   (0170) 
                                   (0171)     org   60h                      ;PSoC I2C Interrupt Vector
                                   (0172)     // call	void_handler
0060: 7E       RETI                (0173)     reti
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0174) 
                                   (0175)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0176)     // call	void_handler
0064: 7E       RETI                (0177)     reti
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0178) 
                                   (0179) ;-----------------------------------------------------------------------------
                                   (0180) ;  Start of Execution.
                                   (0181) ;-----------------------------------------------------------------------------
                                   (0182) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0183) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0184) ;
                                   (0185) 
                                   (0186) IF	(TOOLCHAIN & HITECH)
                                   (0187)  	AREA PD_startup(CODE, REL, CON)
                                   (0188) ELSE
                                   (0189)     org 68h
                                   (0190) ENDIF
                                   (0191) __Start:
                                   (0192) 
                                   (0193)     ; initialize values for voltage stabilization, if required,
                                   (0194)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0195)     ; least for now. 
                                   (0196)     ;
0068: 71 10    OR    F,16          (0197)     M8C_SetBank1
006A: 62 E3 07 MOV   REG[227],7    (0198)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,239         (0199)     M8C_SetBank0
                                   (0200) 
                                   (0201)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
006F: 50 20    MOV   A,32          (0202)     mov   A, 20h
0071: 28       ROMX                (0203)     romx
                                   (0204)     ; %45%20%46%46% End workaround
                                   (0205) 	
                                   (0206) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0207)     M8C_EnableWatchDog
                                   (0208) ENDIF
                                   (0209) 
0072: 41 FE FB AND   REG[254],251  (0210)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0211) 
                                   (0212)     ;---------------------------
                                   (0213)     ; Set up the Temporary stack
                                   (0214)     ;---------------------------
                                   (0215)     ; A temporary stack is set up for the SSC instructions.
                                   (0216)     ; The real stack start will be assigned later.
                                   (0217)     ;
                                   (0218) _stack_start:          equ 80h
0075: 50 80    MOV   A,128         (0219)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A          (0220)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0221) 
                                   (0222)     ;------------------------
                                   (0223)     ; Set Power-related Trim 
                                   (0224)     ;------------------------
                                   (0225) 
                                   (0226) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                   (0227) 
                                   (0228)   IF ( AGND_BYPASS )
                                   (0229)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0230)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0231)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0232)     ; value using the proper trim values.
                                   (0233)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0234)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0235)   ENDIF
                                   (0236) ELSE
                                   (0237) 	; 3.3V operation trim codes
                                   (0238) 	; Set the IMO and Bandgap trims for 3v operation
                                   (0239)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                   (0240) 	
                                   (0241) 	; Set the IMO Gain Trim for 3v operation
                                   (0242) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                   (0243) 
                                   (0244) ENDIF ; 3.3 Volt Operation
                                   (0245) 
0078: 55 F8 00 MOV   [248],0       (0246)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007B: 55 F9 00 MOV   [249],0       (0247)     mov  [bSSC_KEYSP], 0
                                   (0248) 				
                                   (0249)     ;---------------------------------------
                                   (0250)     ; Initialize Crystal Oscillator and PLL
                                   (0251)     ;---------------------------------------
                                   (0252) 
                                   (0253)     ; Either no ECO, or waiting for stable clock is to be done in main
007E: 71 10    OR    F,16          (0254)     M8C_SetBank1
0080: 62 E0 02 MOV   REG[224],2    (0255)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0083: 70 EF    AND   F,239         (0256)     M8C_SetBank0
0085: 62 E3 38 MOV   REG[227],56   (0257)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0258) 
                                   (0259) 
                                   (0260) IF	(TOOLCHAIN & HITECH)
                                   (0261)     ;---------------------------------------------
                                   (0262)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0263)     ;---------------------------------------------
                                   (0264) 	global		__Lstackps
                                   (0265) 	mov     a,low __Lstackps
                                   (0266) 	swap    a,sp
                                   (0267) 
                                   (0268) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0269)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0270)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0271)     RAM_SETPAGE_CUR 0
                                   (0272)     RAM_SETPAGE_MVW 0
                                   (0273)     RAM_SETPAGE_MVR 0
                                   (0274)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0275)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0276)     ELSE
                                   (0277)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0278)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0279) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0280) ELSE
                                   (0281)     ;---------------------------------------------
                                   (0282)     ; ImageCraft Enter the Large Memory Model, if applicable
                                   (0283)     ;---------------------------------------------
                                   (0284) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0088: 62 D1 03 MOV   REG[209],3    (0285)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
008B: 50 00    MOV   A,0           (0286)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
008D: 4E       SWAP  SP,A          (0287)     swap  A, SP
008E: 62 D3 03 MOV   REG[211],3    (0288)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
0091: 62 D0 00 MOV   REG[208],0    (0289)     RAM_SETPAGE_CUR 0
0094: 62 D5 00 MOV   REG[213],0    (0290)     RAM_SETPAGE_MVW 0
0097: 62 D4 00 MOV   REG[212],0    (0291)     RAM_SETPAGE_MVR 0
                                   (0292) 
                                   (0293)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
009A: 71 C0    OR    F,192         (0294)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0295)   ELSE
                                   (0296)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0297)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0298) ELSE
                                   (0299)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                   (0300)     swap  SP, A
                                   (0301) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0302) ENDIF ;	TOOLCHAIN
                                   (0303) 
                                   (0304)     ;------------------------
                                   (0305)     ; Close CT leakage path.
                                   (0306)     ;------------------------
009C: 62 71 05 MOV   REG[113],5    (0307)     mov   reg[ACB00CR0], 05h
009F: 62 75 05 MOV   REG[117],5    (0308)     mov   reg[ACB01CR0], 05h
                                   (0309) 
                                   (0310)     ;-------------------------
                                   (0311)     ; Load Base Configuration
                                   (0312)     ;-------------------------
                                   (0313)     ; Load global parameter settings and load the user modules in the
                                   (0314)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0315)     ; to minimize start up time; (2) We may still need to play with the
                                   (0316)     ; Sleep Timer.
                                   (0317)     ;
00A2: 7C 03 5C LCALL 0x035C        (0318)     lcall LoadConfigInit
00A5: 71 10    OR    F,16          (0319) 	M8C_SetBank1
00A7: 41 E7 3F AND   REG[231],63   (0320) 	and  reg[DEC_CR1], 0x3F
00AA: 43 E7 80 OR    REG[231],128  (0321) 	or   reg[DEC_CR1], 0x80
00AD: 70 EF    AND   F,239         (0322) 	M8C_SetBank0
                                   (0323)     ;-----------------------------------
                                   (0324)     ; Initialize C Run-Time Environment
                                   (0325)     ;-----------------------------------
                                   (0326) IF ( C_LANGUAGE_SUPPORT )
                                   (0327) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                   (0328)     mov  A,0                           ; clear the 'bss' segment to zero
                                   (0329)     mov  [__r0],<__bss_start
                                   (0330) BssLoop:
                                   (0331)     cmp  [__r0],<__bss_end
                                   (0332)     jz   BssDone
                                   (0333)     mvi  [__r0],A
                                   (0334)     jmp  BssLoop
                                   (0335) BssDone:
                                   (0336)     mov  A,>__idata_start              ; copy idata to data segment
                                   (0337)     mov  X,<__idata_start
                                   (0338)     mov  [__r0],<__data_start
                                   (0339) IDataLoop:
                                   (0340)     cmp  [__r0],<__data_end
                                   (0341)     jz   C_RTE_Done
                                   (0342)     push A
                                   (0343)     romx
                                   (0344)     mvi  [__r0],A
                                   (0345)     pop  A
                                   (0346)     inc  X
                                   (0347)     adc  A,0
                                   (0348)     jmp  IDataLoop
                                   (0349) 
                                   (0350) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0351) 
                                   (0352) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00AF: 62 D0 00 MOV   REG[208],0    (0353)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0354)                                        ; to use the Virtual Register page.
                                   (0355) 
                                   (0356)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0357)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0358)     ; text segment and may have been relocated by the Code Compressor.
                                   (0359)     ;
00B2: 50 02    MOV   A,2           (0360)     mov   A, >__pXIData                ; Get the address of the flash
00B4: 57 F8    MOV   X,248         (0361)     mov   X, <__pXIData                ;   pointer to the xidata area.
00B6: 08       PUSH  A             (0362)     push  A
00B7: 28       ROMX                (0363)     romx                               ; get the MSB of xidata's address
00B8: 53 C8    MOV   [__r0],A      (0364)     mov   [__r0], A
00BA: 18       POP   A             (0365)     pop   A
00BB: 75       INC   X             (0366)     inc   X
00BC: 09 00    ADC   A,0           (0367)     adc   A, 0
00BE: 28       ROMX                (0368)     romx                               ; get the LSB of xidata's address
00BF: 4B       SWAP  A,X           (0369)     swap  A, X
00C0: 51 C8    MOV   A,[200]       (0370)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0371)                                        ;   XIData structure list in flash
00C2: 80 04    JMP   0x00C7        (0372)     jmp   .AccessStruct
                                   (0373) 
                                   (0374)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0375)     ; values of C variables. Each structure contains 3 member elements.
                                   (0376)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0377)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0378)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0379)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0380)     ; value in the second member element, an unsigned byte:
                                   (0381)     ; (1) If the value of the second element is non-zero, it represents
                                   (0382)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0383)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0384)     ; the bytes are copied to the block of RAM.
                                   (0385)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0386)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0387)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0388) 
                                   (0389) .AccessNextStructLoop:
00C4: 75       INC   X             (0390)     inc   X                            ; pXIData++
00C5: 09 00    ADC   A,0           (0391)     adc   A, 0
                                   (0392) .AccessStruct:                         ; Entry point for first block
                                   (0393)     ;
                                   (0394)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0395)     ;
00C7: 62 E3 00 MOV   REG[227],0    (0396)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CA: 08       PUSH  A             (0397)     push  A
00CB: 28       ROMX                (0398)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00CC: 60 D5    MOV   REG[213],A    (0399)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00CE: 74       INC   A             (0400)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00CF: A0 4B    JZ    0x011B        (0401)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D1: 18       POP   A             (0402)     pop   A                            ; restore pXIData to [A,X]
00D2: 75       INC   X             (0403)     inc   X                            ; pXIData++
00D3: 09 00    ADC   A,0           (0404)     adc   A, 0
00D5: 08       PUSH  A             (0405)     push  A
00D6: 28       ROMX                (0406)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00D7: 53 C8    MOV   [__r0],A      (0407)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00D9: 18       POP   A             (0408)     pop   A                            ; restore pXIData to [A,X]
00DA: 75       INC   X             (0409)     inc   X                            ; pXIData++ (point to size)
00DB: 09 00    ADC   A,0           (0410)     adc   A, 0
00DD: 08       PUSH  A             (0411)     push  A
00DE: 28       ROMX                (0412)     romx                               ; Get the size (CPU.A <- *pXIData)
00DF: A0 1C    JZ    0x00FC        (0413)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E1: 53 C7    MOV   [__r1],A      (0414)     mov   [__r1], A                    ;             else downcount in __r1
00E3: 18       POP   A             (0415)     pop   A                            ; restore pXIData to [A,X]
                                   (0416) 
                                   (0417) .CopyNextByteLoop:
                                   (0418)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0419)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0420)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0421)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0422)     ;
00E4: 75       INC   X             (0423)     inc   X                            ; pXIData++ (point to next data byte)
00E5: 09 00    ADC   A,0           (0424)     adc   A, 0
00E7: 08       PUSH  A             (0425)     push  A
00E8: 28       ROMX                (0426)     romx                               ; Get the data value (CPU.A <- *pXIData)
00E9: 3F C8    MVI   [__r0],A      (0427)     mvi   [__r0], A                    ; Transfer the data to RAM
00EB: 47 C8 FF TST   [200],255     (0428)     tst   [__r0], 0xff                 ; Check for page crossing
00EE: B0 06    JNZ   0x00F5        (0429)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F0: 5D D5    MOV   A,REG[213]    (0430)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F2: 74       INC   A             (0431)     inc   A
00F3: 60 D5    MOV   REG[213],A    (0432)     mov   reg[ MVW_PP], A
                                   (0433) .CopyLoopTail:
00F5: 18       POP   A             (0434)     pop   A                            ; restore pXIData to [A,X]
00F6: 7A C7    DEC   [__r1]        (0435)     dec   [__r1]                       ; End of this array in flash?
00F8: BF EB    JNZ   0x00E4        (0436)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FA: 8F C9    JMP   0x00C4        (0437)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0438) 
                                   (0439) .ClearRAMBlockToZero:
00FC: 18       POP   A             (0440)     pop   A                            ; restore pXIData to [A,X]
00FD: 75       INC   X             (0441)     inc   X                            ; pXIData++ (point to next data byte)
00FE: 09 00    ADC   A,0           (0442)     adc   A, 0
0100: 08       PUSH  A             (0443)     push  A
0101: 28       ROMX                (0444)     romx                               ; Get the run length (CPU.A <- *pXIData)
0102: 53 C7    MOV   [__r1],A      (0445)     mov   [__r1], A                    ; Initialize downcounter
0104: 50 00    MOV   A,0           (0446)     mov   A, 0                         ; Initialize source data
                                   (0447) 
                                   (0448) .ClearRAMBlockLoop:
                                   (0449)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0450)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0451)     ;
0106: 3F C8    MVI   [__r0],A      (0452)     mvi   [__r0], A                    ; Clear a byte
0108: 47 C8 FF TST   [200],255     (0453)     tst   [__r0], 0xff                 ; Check for page crossing
010B: B0 08    JNZ   0x0114        (0454)     jnz   .ClearLoopTail               ;   No crossing, keep going
010D: 5D D5    MOV   A,REG[213]    (0455)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
010F: 74       INC   A             (0456)     inc   A
0110: 60 D5    MOV   REG[213],A    (0457)     mov   reg[ MVW_PP], A
0112: 50 00    MOV   A,0           (0458)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0459) .ClearLoopTail:
0114: 7A C7    DEC   [__r1]        (0460)     dec   [__r1]                       ; Was this the last byte?
0116: BF EF    JNZ   0x0106        (0461)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0118: 18       POP   A             (0462)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0119: 8F AA    JMP   0x00C4        (0463)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0464) 
                                   (0465) .C_RTE_WrapUp:
011B: 18       POP   A             (0466)     pop   A                            ; balance stack
                                   (0467) 
                                   (0468) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                   (0469) 
                                   (0470) C_RTE_Done:
                                   (0471) 
                                   (0472) ENDIF ; C_LANGUAGE_SUPPORT
                                   (0473) 
                                   (0474) 
                                   (0475)     ;-------------------------------
                                   (0476)     ; Set Power-On Reset (POR) Level
                                   (0477)     ;-------------------------------
011C: 71 10    OR    F,16          (0478)     M8C_SetBank1
                                   (0479) 
                                   (0480) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                   (0481)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                   (0482) ELSE										   ; 5V Operation
                                   (0483)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
011E: 43 E3 00 OR    REG[227],0    (0484)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
                                   (0485)   ELSE ; 24HMz                                 ;
                                   (0486)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                   (0487)   ENDIF ; 24MHz
                                   (0488) ENDIF ; 3.3V Operation
                                   (0489) 
0121: 70 EF    AND   F,239         (0490)     M8C_SetBank0
                                   (0491) 
                                   (0492)     ;----------------------------
                                   (0493)     ; Wrap up and invoke "main"
                                   (0494)     ;----------------------------
                                   (0495) 
                                   (0496)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                   (0497)     ; no interrupts should be enabled now, so may as well clear the register.
                                   (0498)     ;
0123: 62 E0 00 MOV   REG[224],0    (0499)     mov  reg[INT_MSK0],0
                                   (0500) 
                                   (0501)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                   (0502)     ;
0126: 71 10    OR    F,16          (0503)     M8C_SetBank1
0128: 62 E0 00 MOV   REG[224],0    (0504)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012B: 70 EF    AND   F,239         (0505)     M8C_SetBank0
                                   (0506) 
                                   (0507)     ; Global Interrupt are NOT enabled, this should be done in main().
                                   (0508)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                   (0509)     ; Global Interrupts should be enabled as soon as possible in main().
                                   (0510)     ;
012D: 62 E2 00 MOV   REG[226],0    (0511)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                   (0512)                                    ; have been set during the boot process.
                                   (0513) IF	(TOOLCHAIN & HITECH)
                                   (0514) 	ljmp  startup                  ; Jump to C compiler startup code
                                   (0515) ELSE
                                   (0516) IF ENABLE_LJMP_TO_MAIN
                                   (0517)     ljmp  _main                    ; goto main (no return)
                                   (0518) ELSE
0130: 7C 0E A5 LCALL _main         (0519)     lcall _main                    ; call main
                                   (0520) .Exit:
0133: 8F FF    JMP   0x0133        (0521)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                   (0522) ENDIF
                                   (0523) ENDIF ; TOOLCHAIN
                                   (0524) 
                                   (0525)     ;---------------------------------
                                   (0526)     ; Library Access to Global Parms
                                   (0527)     ;---------------------------------
                                   (0528)     ;
                                   (0529)  bGetPowerSetting:
                                   (0530) _bGetPowerSetting:
                                   (0531)     ; Returns value of POWER_SETTING in the A register.
                                   (0532)     ; No inputs. No Side Effects.
                                   (0533)     ;
0135: 50 10    MOV   A,16          (0534)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
0137: 7F       RET                 (0535)     ret
0138: 30       HALT  
0139: 30       HALT  
013A: 30       HALT  
013B: 30       HALT  
013C: 30       HALT  
013D: 30       HALT  
013E: 30       HALT  
013F: 30       HALT  
0140: 30       HALT  
0141: 30       HALT  
0142: 30       HALT  
0143: 30       HALT  
0144: 30       HALT  
0145: 30       HALT  
0146: 30       HALT  
0147: 30       HALT  
0148: 30       HALT  
0149: 30       HALT  
014A: 30       HALT  
014B: 30       HALT  
014C: 30       HALT  
014D: 30       HALT  
014E: 30       HALT  
014F: 30       HALT  
0150: 30       HALT  
0151: 30       HALT  
0152: 30       HALT  
0153: 30       HALT  
0154: 30       HALT  
0155: 30       HALT  
0156: 30       HALT  
0157: 30       HALT  
0158: 30       HALT  
0159: 30       HALT  
015A: 30       HALT  
015B: 30       HALT  
015C: 30       HALT  
015D: 30       HALT  
015E: 30       HALT  
015F: 30       HALT  
0160: 30       HALT  
0161: 30       HALT  
0162: 30       HALT  
0163: 30       HALT  
0164: 30       HALT  
0165: 30       HALT  
0166: 30       HALT  
0167: 30       HALT  
0168: 30       HALT  
0169: 30       HALT  
016A: 30       HALT  
016B: 30       HALT  
016C: 30       HALT  
016D: 30       HALT  
016E: 30       HALT  
016F: 30       HALT  
0170: 30       HALT  
0171: 30       HALT  
0172: 30       HALT  
0173: 30       HALT  
0174: 30       HALT  
0175: 30       HALT  
0176: 30       HALT  
0177: 30       HALT  
0178: 30       HALT  
0179: 30       HALT  
017A: 30       HALT  
017B: 30       HALT  
017C: 30       HALT  
017D: 30       HALT  
017E: 30       HALT  
017F: 30       HALT  
0180: 30       HALT  
0181: 30       HALT  
0182: 30       HALT  
0183: 30       HALT  
0184: 30       HALT  
0185: 30       HALT  
0186: 30       HALT  
0187: 30       HALT  
0188: 30       HALT  
0189: 30       HALT  
018A: 30       HALT  
018B: 30       HALT  
018C: 30       HALT  
018D: 30       HALT  
018E: 30       HALT  
018F: 30       HALT  
0190: 30       HALT  
0191: 30       HALT  
0192: 30       HALT  
0193: 30       HALT  
0194: 30       HALT  
0195: 30       HALT  
0196: 30       HALT  
0197: 30       HALT  
0198: 30       HALT  
0199: 30       HALT  
019A: 30       HALT  
019B: 30       HALT  
019C: 30       HALT  
019D: 30       HALT  
019E: 30       HALT  
019F: 30       HALT  

FILE: lib\psocconfigtbl.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) include "m8c.inc"
                                   (0004) ;  Personalization tables 
                                   (0005) export LoadConfigTBL_t_Bank1
                                   (0006) export LoadConfigTBL_t_Bank0
                                   (0007) export LoadConfigTBL_t_Ordered
                                   (0008) AREA lit(rom, rel)
                                   (0009) LoadConfigTBL_t_Ordered:
                                   (0010) ;  Ordered Global Register values
01A0: 71 10    OR    F,16          (0011) 	M8C_SetBank1
01A2: 62 00 FF MOV   REG[0],255    (0012) 	mov	reg[00h], ffh		; Port_0_DriveMode_0 register (PRT0DM0)
01A5: 62 01 00 MOV   REG[1],0      (0013) 	mov	reg[01h], 00h		; Port_0_DriveMode_1 register (PRT0DM1)
01A8: 70 EF    AND   F,239         (0014) 	M8C_SetBank0
01AA: 62 03 00 MOV   REG[3],0      (0015) 	mov	reg[03h], 00h		; Port_0_DriveMode_2 register (PRT0DM2)
01AD: 62 02 00 MOV   REG[2],0      (0016) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
01B0: 71 10    OR    F,16          (0017) 	M8C_SetBank1
01B2: 62 02 00 MOV   REG[2],0      (0018) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01B5: 62 03 00 MOV   REG[3],0      (0019) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01B8: 70 EF    AND   F,239         (0020) 	M8C_SetBank0
01BA: 62 01 00 MOV   REG[1],0      (0021) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01BD: 71 10    OR    F,16          (0022) 	M8C_SetBank1
01BF: 62 04 00 MOV   REG[4],0      (0023) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
01C2: 62 05 FF MOV   REG[5],255    (0024) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
01C5: 70 EF    AND   F,239         (0025) 	M8C_SetBank0
01C7: 62 07 FF MOV   REG[7],255    (0026) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
01CA: 62 06 00 MOV   REG[6],0      (0027) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
01CD: 71 10    OR    F,16          (0028) 	M8C_SetBank1
01CF: 62 06 00 MOV   REG[6],0      (0029) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
01D2: 62 07 00 MOV   REG[7],0      (0030) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
01D5: 70 EF    AND   F,239         (0031) 	M8C_SetBank0
01D7: 62 05 00 MOV   REG[5],0      (0032) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
01DA: 71 10    OR    F,16          (0033) 	M8C_SetBank1
01DC: 62 08 01 MOV   REG[8],1      (0034) 	mov	reg[08h], 01h		; Port_2_DriveMode_0 register (PRT2DM0)
01DF: 62 09 FE MOV   REG[9],254    (0035) 	mov	reg[09h], feh		; Port_2_DriveMode_1 register (PRT2DM1)
01E2: 70 EF    AND   F,239         (0036) 	M8C_SetBank0
01E4: 62 0B FE MOV   REG[11],254   (0037) 	mov	reg[0bh], feh		; Port_2_DriveMode_2 register (PRT2DM2)
01E7: 62 0A 00 MOV   REG[10],0     (0038) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
01EA: 71 10    OR    F,16          (0039) 	M8C_SetBank1
01EC: 62 0A 00 MOV   REG[10],0     (0040) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
01EF: 62 0B 00 MOV   REG[11],0     (0041) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
01F2: 70 EF    AND   F,239         (0042) 	M8C_SetBank0
01F4: 62 09 00 MOV   REG[9],0      (0043) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
01F7: 71 10    OR    F,16          (0044) 	M8C_SetBank1
01F9: 62 0C 00 MOV   REG[12],0     (0045) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
01FC: 62 0D FF MOV   REG[13],255   (0046) 	mov	reg[0dh], ffh		; Port_3_DriveMode_1 register (PRT3DM1)
01FF: 70 EF    AND   F,239         (0047) 	M8C_SetBank0
0201: 62 0F FF MOV   REG[15],255   (0048) 	mov	reg[0fh], ffh		; Port_3_DriveMode_2 register (PRT3DM2)
0204: 62 0E 00 MOV   REG[14],0     (0049) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0207: 71 10    OR    F,16          (0050) 	M8C_SetBank1
0209: 62 0E 00 MOV   REG[14],0     (0051) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
020C: 62 0F 00 MOV   REG[15],0     (0052) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
020F: 70 EF    AND   F,239         (0053) 	M8C_SetBank0
0211: 62 0D 00 MOV   REG[13],0     (0054) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0214: 71 10    OR    F,16          (0055) 	M8C_SetBank1
0216: 62 10 00 MOV   REG[16],0     (0056) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0219: 62 11 FF MOV   REG[17],255   (0057) 	mov	reg[11h], ffh		; Port_4_DriveMode_1 register (PRT4DM1)
021C: 70 EF    AND   F,239         (0058) 	M8C_SetBank0
021E: 62 13 FF MOV   REG[19],255   (0059) 	mov	reg[13h], ffh		; Port_4_DriveMode_2 register (PRT4DM2)
0221: 62 12 00 MOV   REG[18],0     (0060) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0224: 71 10    OR    F,16          (0061) 	M8C_SetBank1
0226: 62 12 00 MOV   REG[18],0     (0062) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0229: 62 13 00 MOV   REG[19],0     (0063) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
022C: 70 EF    AND   F,239         (0064) 	M8C_SetBank0
022E: 62 11 00 MOV   REG[17],0     (0065) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0231: 71 10    OR    F,16          (0066) 	M8C_SetBank1
0233: 62 14 00 MOV   REG[20],0     (0067) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0236: 62 15 FF MOV   REG[21],255   (0068) 	mov	reg[15h], ffh		; Port_5_DriveMode_1 register (PRT5DM1)
0239: 70 EF    AND   F,239         (0069) 	M8C_SetBank0
023B: 62 17 FF MOV   REG[23],255   (0070) 	mov	reg[17h], ffh		; Port_5_DriveMode_2 register (PRT5DM2)
023E: 62 16 00 MOV   REG[22],0     (0071) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0241: 71 10    OR    F,16          (0072) 	M8C_SetBank1
0243: 62 16 00 MOV   REG[22],0     (0073) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0246: 62 17 00 MOV   REG[23],0     (0074) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0249: 70 EF    AND   F,239         (0075) 	M8C_SetBank0
024B: 62 15 00 MOV   REG[21],0     (0076) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
024E: 71 10    OR    F,16          (0077) 	M8C_SetBank1
0250: 62 1C 00 MOV   REG[28],0     (0078) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0253: 62 1D 81 MOV   REG[29],129   (0079) 	mov	reg[1dh], 81h		; Port_7_DriveMode_1 register (PRT7DM1)
0256: 70 EF    AND   F,239         (0080) 	M8C_SetBank0
0258: 62 1F 81 MOV   REG[31],129   (0081) 	mov	reg[1fh], 81h		; Port_7_DriveMode_2 register (PRT7DM2)
025B: 62 1E 00 MOV   REG[30],0     (0082) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
025E: 71 10    OR    F,16          (0083) 	M8C_SetBank1
0260: 62 1E 00 MOV   REG[30],0     (0084) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0263: 62 1F 00 MOV   REG[31],0     (0085) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0266: 70 EF    AND   F,239         (0086) 	M8C_SetBank0
0268: 62 1D 00 MOV   REG[29],0     (0087) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
026B: 7F       RET                 (0088) 	ret
026C: 60 09    MOV   REG[9],A
026E: 66 00    ASL   [X+0]
0270: 61 00    MOV   REG[X+0],A
0272: 63 05 65 MOV   REG[X+5],101
0275: 00       SWI   
0276: FD 00    INDEX 0xFF78
0278: E6 00    JACC  0x0879
027A: E7 00    JACC  0x097B
027C: 56 00 57 MOV   [X+0],87
027F: 00       SWI   
0280: 58 00    MOV   X,[0]
0282: 59 00    MOV   X,[X+0]
0284: 5A 00    MOV   [0],X
0286: 5B       MOV   A,X
0287: 00       SWI   
0288: 5C       MOV   X,A
0289: 00       SWI   
028A: 5D 00    MOV   A,REG[0]
028C: 5E 00    MOV   A,REG[X+0]
028E: 5F 00 4F MOV   [0],[79]
0291: 00       SWI   
0292: 4E       SWAP  SP,A
0293: 00       SWI   
0294: 51 00    MOV   A,[0]
0296: 50 00    MOV   A,0
0298: 53 00    MOV   [0],A
029A: 52 00    MOV   A,[X+0]
029C: 55 00 54 MOV   [0],84
029F: 00       SWI   
02A0: D6 00    JNC   0x08A1
02A2: B0 00    JNZ   0x02A3
02A4: B1 00    JNZ   0x03A5
02A6: B2 00    JNZ   0x04A7
02A8: B3 33    JNZ   0x05DC
02AA: B4 33    JNZ   0x06DE
02AC: B5 00    JNZ   0x07AD
02AE: B6 00    JNZ   0x08AF
02B0: 4A 00 4B TST   REG[X+0],75
02B3: 00       SWI   
02B4: 4C 00    SWAP  A,[0]
02B6: FF 61    INDEX 0x0219
02B8: 00       SWI   
02B9: 69 00    ASR   [X+0]
02BB: 60 00    MOV   REG[0],A
02BD: 62 00 67 MOV   REG[0],103
02C0: 33 68    XOR   A,[X+104]
02C2: 00       SWI   
02C3: 63 00 66 MOV   REG[X+0],102
02C6: 00       SWI   
02C7: 64       ASL   A
02C8: 00       SWI   
02C9: 64       ASL   A
02CA: 00       SWI   
02CB: FD 80    INDEX 0x004D
02CD: C4 00    JC    0x06CE
02CF: C5 00    JC    0x07D0
02D1: C6 00    JC    0x08D2
02D3: C7 00    JC    0x09D4
02D5: D1 00    JNC   0x03D6
02D7: D3 00    JNC   0x05D8
02D9: D0 00    JNC   0x02DA
02DB: D2 00    JNC   0x04DC
02DD: E1 00    JACC  0x03DE
02DF: E2 00    JACC  0x04E0
02E1: DF 00    JNC   0x01E2
02E3: DE 00    JNC   0x00E4
02E5: DD 00    JNC   0xFFE6
02E7: D8 00    JNC   0xFAE8
02E9: D9 00    JNC   0xFBEA
02EB: DA 00    JNC   0xFCEC
02ED: DB 00    JNC   0xFDEE
02EF: EC 00    JACC  0xFEF0
02F1: ED 00    JACC  0xFFF2
02F3: E7 00    JACC  0x09F4
02F5: C1 00    JC    0x03F6
02F7: FF 0F    INDEX 0x0208
02F9: C2 01    JC    0x04FB
02FB: 02 FF    ADD   A,[255]
02FD: 03 4A    ADD   A,[X+74]
02FF: 01 03    ADD   A,3
0301: 0A 03    ADC   A,[3]
0303: 04 03    ADD   [3],A
0305: 0E 03 19 ADC   [3],25
0308: 03 10    ADD   A,[X+16]
030A: 80 00    JMP   0x030B
030C: 7F       RET   
030D: 7F       RET   
030E: 03 22    ADD   A,[X+34]
0310: 00       SWI   
0311: 00       SWI   
0312: 00       SWI   
0313: 09 09    ADC   A,9
0315: 61 00    MOV   REG[X+0],A
0317: 00       SWI   
0318: DE 00    JNC   0x0119
031A: 00       SWI   
031B: 00       SWI   
031C: 25 09    AND   [X+9],A
031E: 78       DEC   A
031F: 00       SWI   
0320: 00       SWI   
0321: DE 04    JNC   0x0126
0323: 03 2F    ADD   A,[X+47]
0325: 00       SWI   
0326: 00       SWI   
0327: 03 38    ADD   A,[X+56]
0329: 00       SWI   
032A: 00       SWI   
032B: 03 41    ADD   A,[X+65]
032D: 00       SWI   
032E: 00       SWI   
032F: 00       SWI   
0330: 01 00    ADD   A,0
0332: 08       PUSH  A
0333: 00       SWI   
0334: 26 00 00 AND   [0],0
0337: DE 00    JNC   0x0138
0339: 01 00    ADD   A,0
033B: 08       PUSH  A
033C: 00       SWI   
033D: 2E 00 00 OR    [0],0
0340: DE 00    JNC   0x0141
0342: 01 00    ADD   A,0
0344: 00       SWI   
0345: 00       SWI   
0346: 36 00 00 XOR   [0],0
0349: DE 00    JNC   0x014A
034B: 00       SWI   
034C: 00       SWI   
034D: 29 09    OR    A,9
034F: 4F       MOV   X,SP
0350: 00       SWI   
0351: 00       SWI   
0352: DE 00    JNC   0x0153
0354: 00       SWI   
0355: 00       SWI   
0356: 12 09    SUB   A,[9]
0358: 3D 00 00 CMP   [X+0],0
035B: DE 55    JNC   0x01B1

FILE: lib\psocconfig.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;==========================================================================
                                   (0004) ;  PSoCConfig.asm
                                   (0005) ;  @PSOC_VERSION
                                   (0006) ;
                                   (0007) ;  Version: 0.85
                                   (0008) ;  Revised: June 22, 2004
                                   (0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;
                                   (0011) ;  This file is generated by the Device Editor on Application Generation.
                                   (0012) ;  It contains code which loads the configuration data table generated in
                                   (0013) ;  the file PSoCConfigTBL.asm
                                   (0014) ;
                                   (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0016) ;  Edits to this file will not be preserved.
                                   (0017) ;==========================================================================
                                   (0018) ;
                                   (0019) include "m8c.inc"
                                   (0020) include "memory.inc"
                                   (0021) include "GlobalParams.inc"
                                   (0022) 
                                   (0023) export LoadConfigInit
                                   (0024) export _LoadConfigInit
                                   (0025) export LoadConfig_t
                                   (0026) export _LoadConfig_t
                                   (0027) export Port_1_Data_SHADE
                                   (0028) export _Port_1_Data_SHADE
                                   (0029) 
                                   (0030) 
                                   (0031) export NO_SHADOW
                                   (0032) export _NO_SHADOW
                                   (0033) 
                                   (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0036) 
                                   (0037) AREA psoc_config(rom, rel)
                                   (0038) 
                                   (0039) ;---------------------------------------------------------------------------
                                   (0040) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0041) ;                  parameters handled by boot code, like CPU speed). This
                                   (0042) ;                  function can be called from user code, but typically it
                                   (0043) ;                  is only called from boot.
                                   (0044) ;
                                   (0045) ;       INPUTS: None.
                                   (0046) ;      RETURNS: Nothing.
                                   (0047) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0048) ;               In the large memory model currently only the page
                                   (0049) ;               pointer registers listed below are modified.  This does
                                   (0050) ;               not guarantee that in future implementations of this
                                   (0051) ;               function other page pointer registers will not be
                                   (0052) ;               modified.
                                   (0053) ;          
                                   (0054) ;               Page Pointer Registers Modified: 
                                   (0055) ;               CUR_PP
                                   (0056) ;
                                   (0057) _LoadConfigInit:
                                   (0058)  LoadConfigInit:
                                   (0059)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0060)     
035D: 46 00 7C XOR   REG[X+0],124  (0061) 	mov		[Port_1_Data_SHADE], 0h
                                   (0062) 
0360: 01 A0    ADD   A,160         (0063) 	lcall	LoadConfigTBL_t_Ordered
0362: 7C 03 66 LCALL 0x0366        (0064) 	lcall	LoadConfig_t
                                   (0065) 
                                   (0066) 
                                   (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
0365: 7F       RET                 (0068)     ret
                                   (0069) 
                                   (0070) ;---------------------------------------------------------------------------
                                   (0071) ; Load Configuration t
                                   (0072) ;
                                   (0073) ;    Load configuration registers for t.
                                   (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0075) ;
                                   (0076) ;       INPUTS: None.
                                   (0077) ;      RETURNS: Nothing.
                                   (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0079) ;               modified as may the Page Pointer registers!
                                   (0080) ;               In the large memory model currently only the page
                                   (0081) ;               pointer registers listed below are modified.  This does
                                   (0082) ;               not guarantee that in future implementations of this
                                   (0083) ;               function other page pointer registers will not be
                                   (0084) ;               modified.
                                   (0085) ;          
                                   (0086) ;               Page Pointer Registers Modified: 
                                   (0087) ;               CUR_PP
                                   (0088) ;
                                   (0089) _LoadConfig_t:
                                   (0090)  LoadConfig_t:
                                   (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0092) 
0366: 10       PUSH  X             (0093) 	push	x
0367: 70 EF    AND   F,239         (0094)     M8C_SetBank0                    ; Force bank 0
0369: 50 00    MOV   A,0           (0095)     mov     a, 0                    ; Specify bank 0
036B: 67       ASR   A             (0096)     asr     a                       ; Store in carry flag
                                   (0097)                                     ; Load bank 0 table:
036C: 50 02    MOV   A,2           (0098)     mov     A, >LoadConfigTBL_t_Bank0
036E: 57 6C    MOV   X,108         (0099)     mov     X, <LoadConfigTBL_t_Bank0
0370: 7C 03 81 LCALL 0x0381        (0100)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0101) 
0373: 50 01    MOV   A,1           (0102)     mov     a, 1                    ; Specify bank 1
0375: 67       ASR   A             (0103)     asr     a                       ; Store in carry flag
                                   (0104)                                     ; Load bank 1 table:
0376: 50 02    MOV   A,2           (0105)     mov     A, >LoadConfigTBL_t_Bank1
0378: 57 B7    MOV   X,183         (0106)     mov     X, <LoadConfigTBL_t_Bank1
037A: 7C 03 81 LCALL 0x0381        (0107)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0108) 
037D: 70 EF    AND   F,239         (0109)     M8C_SetBank0                    ; Force return to bank 0
037F: 20       POP   X             (0110) 	pop		x
                                   (0111) 
                                   (0112)     RAM_EPILOGUE RAM_USE_CLASS_4
0380: 7F       RET                 (0113)     ret
                                   (0114) 
                                   (0115) 
                                   (0116) 
                                   (0117) 
                                   (0118) ;---------------------------------------------------------------------------
                                   (0119) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                   (0120) ;              pairs. Terminate on address=0xFF.
                                   (0121) ;
                                   (0122) ;  INPUTS:  [A,X] points to the table to be loaded
                                   (0123) ;           Flag Register Carry bit encodes the Register Bank
                                   (0124) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                   (0125) ;
                                   (0126) ;  RETURNS: nothing.
                                   (0127) ;
                                   (0128) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                   (0129) ;                X-3 Temporary store for register address
                                   (0130) ;                X-2 LSB of config table address
                                   (0131) ;                X-1 MSB of config table address
                                   (0132) ;
                                   (0133) LoadConfig:
                                   (0134)     RAM_PROLOGUE RAM_USE_CLASS_2
0381: 38 02    ADD   SP,2          (0135)     add     SP, 2                   ; Set up local vars
0383: 10       PUSH  X             (0136)     push    X                       ; Save config table address on stack
0384: 08       PUSH  A             (0137)     push    A
0385: 4F       MOV   X,SP          (0138)     mov     X, SP
0386: 56 FC 00 MOV   [X-4],0       (0139)     mov     [X-4], 0                ; Set default Destination to Bank 0
0389: D0 04    JNC   0x038E        (0140)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
038B: 56 FC 01 MOV   [X-4],1       (0141)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                   (0142) .BankSelectSaved:
038E: 18       POP   A             (0143)     pop     A
038F: 20       POP   X             (0144)     pop     X
                                   (0145) 
                                   (0146) LoadConfigLp:
0390: 70 EF    AND   F,239         (0147)     M8C_SetBank0                    ; Switch to bank 0
0392: 62 E3 00 MOV   REG[227],0    (0148)     M8C_ClearWDT                    ; Clear the watchdog for long inits
0395: 10       PUSH  X             (0149)     push    X                       ; Preserve the config table address
0396: 08       PUSH  A             (0150)     push    A
0397: 28       ROMX                (0151)     romx                            ; Load register address from table
0398: 39 FF    CMP   A,255         (0152)     cmp     A, END_CONFIG_TABLE     ; End of table?
039A: A0 1F    JZ    0x03BA        (0153)     jz      EndLoadConfig           ;   Yes, go wrap it up
039C: 4F       MOV   X,SP          (0154)     mov     X, SP                   ;
039D: 48 FC 01 TST   [X-4],1       (0155)     tst     [X-4], 1                ; Loading IO Bank 1?
03A0: A0 03    JZ    0x03A4        (0156)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
03A2: 71 10    OR    F,16          (0157)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                   (0158) .IOBankNowSet:
03A4: 54 FD    MOV   [X-3],A       (0159)     mov     [X-3], A                ; Stash the register address
03A6: 18       POP   A             (0160)     pop     A                       ; Retrieve the table address
03A7: 20       POP   X             (0161)     pop     X
03A8: 75       INC   X             (0162)     inc     X                       ; Advance to the data byte
03A9: 09 00    ADC   A,0           (0163)     adc     A, 0
03AB: 10       PUSH  X             (0164)     push    X                       ; Save the config table address again
03AC: 08       PUSH  A             (0165)     push    A
03AD: 28       ROMX                (0166)     romx                            ; load config data from the table
03AE: 4F       MOV   X,SP          (0167)     mov     X, SP                   ; retrieve the register address
03AF: 59 FD    MOV   X,[X-3]       (0168)     mov     X, [X-3]
03B1: 61 00    MOV   REG[X+0],A    (0169)     mov     reg[X], A               ; Configure the register
03B3: 18       POP   A             (0170)     pop     A                       ; retrieve the table address
03B4: 20       POP   X             (0171)     pop     X
03B5: 75       INC   X             (0172)     inc     X                       ; advance to next table entry
03B6: 09 00    ADC   A,0           (0173)     adc     A, 0
03B8: 8F D7    JMP   0x0390        (0174)     jmp     LoadConfigLp            ; loop to configure another register
                                   (0175) EndLoadConfig:
03BA: 38 FC    ADD   SP,252        (0176)     add     SP, -4
03BC: 70 3F    AND   F,63
03BE: 71 C0    OR    F,192         (0177)     RAM_EPILOGUE RAM_USE_CLASS_2
03C0: 7F       RET                 (0178)     ret

FILE: lib\usb_std.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USB_std.asm
                                   (0004) ;;  Version: 1.3, Updated on 2007/09/28 at 14:23:41
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices.
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2005-2007. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "USB_macros.inc"
                                   (0025) include "USB.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ;  Global Symbols
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) AREA bss (RAM, REL)
                                   (0032) 
                                   (0033) ;-----------------------------------------------
                                   (0034) ;  Constant Definitions
                                   (0035) ;-----------------------------------------------
                                   (0036) ;-----------------------------------------------
                                   (0037) ; Variable Allocation
                                   (0038) ;-----------------------------------------------
                                   (0039) 
                                   (0040) AREA UserModules (ROM, REL)
                                   (0041) 
                                   (0042) ;-----------------------------------------------------------------------------
                                   (0043) ;  FUNCTION NAME: USB_Not_Supported
                                   (0044) ;
                                   (0045) ;  DESCRIPTION:
                                   (0046) ;
                                   (0047) ;-----------------------------------------------------------------------------
                                   (0048) ;
                                   (0049) ;  ARGUMENTS:
                                   (0050) ;
                                   (0051) ;  RETURNS:
                                   (0052) ;
                                   (0053) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0054) ;
                                   (0055) ;  THEORY of OPERATION or PROCEDURE:
                                   (0056) ;
                                   (0057) ;-----------------------------------------------------------------------------
                                   (0058) 
                                   (0059) ; d2h_std_dev
                                   (0060) IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                                   (0061) export  USB_CB_d2h_std_dev_00
                                   (0062) USB_CB_d2h_std_dev_00:
                                   (0063) ENDIF
                                   (0064) IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                                   (0065) export  USB_CB_d2h_std_dev_01
                                   (0066) USB_CB_d2h_std_dev_01:
                                   (0067) ENDIF
                                   (0068) IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                                   (0069) export  USB_CB_d2h_std_dev_02
                                   (0070) USB_CB_d2h_std_dev_02:
                                   (0071) ENDIF
                                   (0072) IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                                   (0073) export  USB_CB_d2h_std_dev_03
                                   (0074) USB_CB_d2h_std_dev_03:
                                   (0075) ENDIF
                                   (0076) IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                                   (0077) export  USB_CB_d2h_std_dev_04
                                   (0078) USB_CB_d2h_std_dev_04:
                                   (0079) ENDIF
                                   (0080) IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                                   (0081) export  USB_CB_d2h_std_dev_05
                                   (0082) USB_CB_d2h_std_dev_05:
                                   (0083) ENDIF
                                   (0084) IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                                   (0085) export  USB_CB_d2h_std_dev_06
                                   (0086) USB_CB_d2h_std_dev_06:
                                   (0087) ENDIF
                                   (0088) IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                                   (0089) export  USB_CB_d2h_std_dev_07
                                   (0090) USB_CB_d2h_std_dev_07:
                                   (0091) ENDIF
                                   (0092) IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                                   (0093) export  USB_CB_d2h_std_dev_08
                                   (0094) USB_CB_d2h_std_dev_08:
                                   (0095) ENDIF
                                   (0096) 
                                   (0097) ; h2d_std_dev
                                   (0098) IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                                   (0099) export  USB_CB_h2d_std_dev_00
                                   (0100) USB_CB_h2d_std_dev_00:
                                   (0101) ENDIF
                                   (0102) IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                                   (0103) export  USB_CB_h2d_std_dev_01
                                   (0104) USB_CB_h2d_std_dev_01:
                                   (0105) ENDIF
                                   (0106) IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                                   (0107) export  USB_CB_h2d_std_dev_02
                                   (0108) USB_CB_h2d_std_dev_02:
                                   (0109) ENDIF
                                   (0110) IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                                   (0111) export  USB_CB_h2d_std_dev_03
                                   (0112) USB_CB_h2d_std_dev_03:
                                   (0113) ENDIF
                                   (0114) IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                                   (0115) export  USB_CB_h2d_std_dev_04
                                   (0116) USB_CB_h2d_std_dev_04:
                                   (0117) ENDIF
                                   (0118) IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                                   (0119) export  USB_CB_h2d_std_dev_05
                                   (0120) USB_CB_h2d_std_dev_05:
                                   (0121) ENDIF
                                   (0122) IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                                   (0123) export  USB_CB_h2d_std_dev_06
                                   (0124) USB_CB_h2d_std_dev_06:
                                   (0125) ENDIF
                                   (0126) IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                                   (0127) export  USB_CB_h2d_std_dev_07
                                   (0128) USB_CB_h2d_std_dev_07:
                                   (0129) ENDIF
                                   (0130) IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                                   (0131) export  USB_CB_h2d_std_dev_08
                                   (0132) USB_CB_h2d_std_dev_08:
                                   (0133) ENDIF
                                   (0134) IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                                   (0135) export  USB_CB_h2d_std_dev_09
                                   (0136) USB_CB_h2d_std_dev_09:
                                   (0137) ENDIF
                                   (0138) 
                                   (0139) ; d2h_std_ifc
                                   (0140) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                                   (0141) export  USB_CB_d2h_std_ifc_00
                                   (0142) USB_CB_d2h_std_ifc_00:
                                   (0143) ENDIF
                                   (0144) IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                                   (0145) export  USB_CB_d2h_std_ifc_01
                                   (0146) USB_CB_d2h_std_ifc_01:
                                   (0147) ENDIF
                                   (0148) IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                                   (0149) export  USB_CB_d2h_std_ifc_02
                                   (0150) USB_CB_d2h_std_ifc_02:
                                   (0151) ENDIF
                                   (0152) IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                                   (0153) export  USB_CB_d2h_std_ifc_03
                                   (0154) USB_CB_d2h_std_ifc_03:
                                   (0155) ENDIF
                                   (0156) IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                                   (0157) export  USB_CB_d2h_std_ifc_04
                                   (0158) USB_CB_d2h_std_ifc_04:
                                   (0159) ENDIF
                                   (0160) IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                                   (0161) export  USB_CB_d2h_std_ifc_05
                                   (0162) USB_CB_d2h_std_ifc_05:
                                   (0163) ENDIF
                                   (0164) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                                   (0165) export  USB_CB_d2h_std_ifc_06
                                   (0166) USB_CB_d2h_std_ifc_06:
                                   (0167) ENDIF
                                   (0168) IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                                   (0169) export  USB_CB_d2h_std_ifc_07
                                   (0170) USB_CB_d2h_std_ifc_07:
                                   (0171) ENDIF
                                   (0172) IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                                   (0173) export  USB_CB_d2h_std_ifc_08
                                   (0174) USB_CB_d2h_std_ifc_08:
                                   (0175) ENDIF
                                   (0176) IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                                   (0177) export  USB_CB_d2h_std_ifc_09
                                   (0178) USB_CB_d2h_std_ifc_09:
                                   (0179) ENDIF
                                   (0180) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                                   (0181) export  USB_CB_d2h_std_ifc_10
                                   (0182) USB_CB_d2h_std_ifc_10:
                                   (0183) ENDIF
                                   (0184) 
                                   (0185) ; h2d_std_ifc
                                   (0186) IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                                   (0187) export  USB_CB_h2d_std_ifc_00
                                   (0188) USB_CB_h2d_std_ifc_00:
                                   (0189) ENDIF
                                   (0190) IF (USB_CB_SRC_h2d_std_ifc_01 & USB_NOT_SUPPORTED)
                                   (0191) export  USB_CB_h2d_std_ifc_01
                                   (0192) USB_CB_h2d_std_ifc_01:
                                   (0193) ENDIF
                                   (0194) IF (USB_CB_SRC_h2d_std_ifc_02 & USB_NOT_SUPPORTED)
                                   (0195) export  USB_CB_h2d_std_ifc_02
                                   (0196) USB_CB_h2d_std_ifc_02:
                                   (0197) ENDIF
                                   (0198) IF (USB_CB_SRC_h2d_std_ifc_03 & USB_NOT_SUPPORTED)
                                   (0199) export  USB_CB_h2d_std_ifc_03
                                   (0200) USB_CB_h2d_std_ifc_03:
                                   (0201) ENDIF
                                   (0202) IF (USB_CB_SRC_h2d_std_ifc_04 & USB_NOT_SUPPORTED)
                                   (0203) export  USB_CB_h2d_std_ifc_04
                                   (0204) USB_CB_h2d_std_ifc_04:
                                   (0205) ENDIF
                                   (0206) IF (USB_CB_SRC_h2d_std_ifc_05 & USB_NOT_SUPPORTED)
                                   (0207) export  USB_CB_h2d_std_ifc_05
                                   (0208) USB_CB_h2d_std_ifc_05:
                                   (0209) ENDIF
                                   (0210) IF (USB_CB_SRC_h2d_std_ifc_06 & USB_NOT_SUPPORTED)
                                   (0211) export  USB_CB_h2d_std_ifc_06
                                   (0212) USB_CB_h2d_std_ifc_06:
                                   (0213) ENDIF
                                   (0214) IF (USB_CB_SRC_h2d_std_ifc_07 & USB_NOT_SUPPORTED)
                                   (0215) export  USB_CB_h2d_std_ifc_07
                                   (0216) USB_CB_h2d_std_ifc_07:
                                   (0217) ENDIF
                                   (0218) IF (USB_CB_SRC_h2d_std_ifc_08 & USB_NOT_SUPPORTED)
                                   (0219) export  USB_CB_h2d_std_ifc_08
                                   (0220) USB_CB_h2d_std_ifc_08:
                                   (0221) ENDIF
                                   (0222) IF (USB_CB_SRC_h2d_std_ifc_09 & USB_NOT_SUPPORTED)
                                   (0223) export  USB_CB_h2d_std_ifc_09
                                   (0224) USB_CB_h2d_std_ifc_09:
                                   (0225) ENDIF
                                   (0226) IF (USB_CB_SRC_h2d_std_ifc_10 & USB_NOT_SUPPORTED)
                                   (0227) export  USB_CB_h2d_std_ifc_10
                                   (0228) USB_CB_h2d_std_ifc_10:
                                   (0229) ENDIF
                                   (0230) IF (USB_CB_SRC_h2d_std_ifc_11 & USB_NOT_SUPPORTED)
                                   (0231) export  USB_CB_h2d_std_ifc_11
                                   (0232) USB_CB_h2d_std_ifc_11:
                                   (0233) ENDIF
                                   (0234) 
                                   (0235) ; d2h_std_ep
                                   (0236) IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                                   (0237) export  USB_CB_d2h_std_ep_00
                                   (0238) USB_CB_d2h_std_ep_00:
                                   (0239) ENDIF
                                   (0240) IF (USB_CB_SRC_d2h_std_ep_01 & USB_NOT_SUPPORTED)
                                   (0241) export  USB_CB_d2h_std_ep_01
                                   (0242) USB_CB_d2h_std_ep_01:
                                   (0243) ENDIF
                                   (0244) IF (USB_CB_SRC_d2h_std_ep_02 & USB_NOT_SUPPORTED)
                                   (0245) export  USB_CB_d2h_std_ep_02
                                   (0246) USB_CB_d2h_std_ep_02:
                                   (0247) ENDIF
                                   (0248) IF (USB_CB_SRC_d2h_std_ep_03 & USB_NOT_SUPPORTED)
                                   (0249) export  USB_CB_d2h_std_ep_03
                                   (0250) USB_CB_d2h_std_ep_03:
                                   (0251) ENDIF
                                   (0252) IF (USB_CB_SRC_d2h_std_ep_04 & USB_NOT_SUPPORTED)
                                   (0253) export  USB_CB_d2h_std_ep_04
                                   (0254) USB_CB_d2h_std_ep_04:
                                   (0255) ENDIF
                                   (0256) IF (USB_CB_SRC_d2h_std_ep_05 & USB_NOT_SUPPORTED)
                                   (0257) export  USB_CB_d2h_std_ep_05
                                   (0258) USB_CB_d2h_std_ep_05:
                                   (0259) ENDIF
                                   (0260) IF (USB_CB_SRC_d2h_std_ep_06 & USB_NOT_SUPPORTED)
                                   (0261) export  USB_CB_d2h_std_ep_06
                                   (0262) USB_CB_d2h_std_ep_06:
                                   (0263) ENDIF
                                   (0264) IF (USB_CB_SRC_d2h_std_ep_07 & USB_NOT_SUPPORTED)
                                   (0265) export  USB_CB_d2h_std_ep_07
                                   (0266) USB_CB_d2h_std_ep_07:
                                   (0267) ENDIF
                                   (0268) IF (USB_CB_SRC_d2h_std_ep_08 & USB_NOT_SUPPORTED)
                                   (0269) export  USB_CB_d2h_std_ep_08
                                   (0270) USB_CB_d2h_std_ep_08:
                                   (0271) ENDIF
                                   (0272) IF (USB_CB_SRC_d2h_std_ep_09 & USB_NOT_SUPPORTED)
                                   (0273) export  USB_CB_d2h_std_ep_09
                                   (0274) USB_CB_d2h_std_ep_09:
                                   (0275) ENDIF
                                   (0276) IF (USB_CB_SRC_d2h_std_ep_10 & USB_NOT_SUPPORTED)
                                   (0277) export  USB_CB_d2h_std_ep_10
                                   (0278) USB_CB_d2h_std_ep_10:
                                   (0279) ENDIF
                                   (0280) IF (USB_CB_SRC_d2h_std_ep_11 & USB_NOT_SUPPORTED)
                                   (0281) export  USB_CB_d2h_std_ep_11
                                   (0282) USB_CB_d2h_std_ep_11:
                                   (0283) ENDIF
                                   (0284) IF (USB_CB_SRC_d2h_std_ep_12 & USB_NOT_SUPPORTED)
                                   (0285) export  USB_CB_d2h_std_ep_12
                                   (0286) USB_CB_d2h_std_ep_12:
                                   (0287) ENDIF
                                   (0288) 
                                   (0289) ; h2d_std_ep
                                   (0290) IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                                   (0291) export  USB_CB_h2d_std_ep_00
                                   (0292) USB_CB_h2d_std_ep_00:
                                   (0293) ENDIF
                                   (0294) IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                                   (0295) export  USB_CB_h2d_std_ep_01
                                   (0296) USB_CB_h2d_std_ep_01:
                                   (0297) ENDIF
                                   (0298) IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                                   (0299) export  USB_CB_h2d_std_ep_02
                                   (0300) USB_CB_h2d_std_ep_02:
                                   (0301) ENDIF
                                   (0302) IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                                   (0303) export  USB_CB_h2d_std_ep_03
                                   (0304) USB_CB_h2d_std_ep_03:
                                   (0305) ENDIF
                                   (0306) 
                                   (0307) export  USB_Not_Supported
                                   (0308) export _USB_Not_Supported
                                   (0309)  USB_Not_Supported:
                                   (0310) _USB_Not_Supported:
03C1: 50 00    MOV   A,0           (0311)    mov    A, 0                         ; Count 0
03C3: 57 03    MOV   X,3           (0312)    mov    X, USB_MODE_STALL_IN_OUT     ; Stall the request
03C5: 7D 06 C8 LJMP  0x06C8        (0313)    ljmp   USB_EP0_UPD_MODE_EXIT
03C8: 00       SWI   
03C9: 01 00    ADD   A,0
03CB: 02 00    ADD   A,[0]
03CD: 0B 00    ADC   A,[X+0]
03CF: 00       SWI   
03D0: DE 55    JNC   0x0226
                                   (0314) ;-----------------------------------------------------------------------------
                                   (0315) ;  FUNCTION NAME: USB_CB_d2h_std_dev_00
                                   (0316) ;
                                   (0317) ;  DESCRIPTION:   Get Device Status
                                   (0318) ;
                                   (0319) ;****************************************************************
                                   (0320) ; STANDARD DEVICE IN REQUEST: Get_Device_Status
                                   (0321) ;****************************************************************
                                   (0322) ;
                                   (0323) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                   (0324) ; bRequest       : GET_STATUS                     = 00h
                                   (0325) ; wValue         : RESERVED                       = 0000h
                                   (0326) ; wIndex         : RESERVED                       = 0000h
                                   (0327) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                   (0328) ;
                                   (0329) ; The GET_DEVICE_STATUS request returns the current device status.
                                   (0330) ;
                                   (0331) ;****************************************************************
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:
                                   (0335) ;
                                   (0336) ;  RETURNS:
                                   (0337) ;
                                   (0338) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0339) ;
                                   (0340) ;  THEORY of OPERATION or PROCEDURE:
                                   (0341) ;
                                   (0342) ;-----------------------------------------------------------------------------
                                   (0343) .LITERAL
                                   (0344) GetStatusTransferDescrTable:
                                   (0345)     TD_START_TABLE 1                   ; One entry
                                   (0346)     TD_ENTRY    USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR    ; Intermediate Buffer
                                   (0347) .ENDLITERAL
                                   (0348) IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                                   (0349) export  USB_CB_d2h_std_dev_00
                                   (0350) USB_CB_d2h_std_dev_00:
03D2: 1E 00 55 SBB   [0],85        (0351)     mov     [USB_t2], 0                ; Use the UM temp var--Selector
                                   (0352) 
03D5: 0C 00    ADC   [0],A         (0353)     mov     [USB_TransferBuffer+1], 0    ; Use the UM Transfer Buffer
03D7: 5F 0B 02 MOV   [11],[2]      (0354)     mov     [USB_TransferBuffer], [USB_DeviceStatus]
                                   (0355) 
03DA: 50 03    MOV   A,3           (0356)     mov     A, >GetStatusTransferDescrTable    ; Get the ROM Address MSB
03DC: 57 C8    MOV   X,200         (0357)     mov     X, <GetStatusTransferDescrTable    ; Get the ROM Address LSB
03DE: 80 E9    JMP   0x04C8        (0358)     jmp     USB_GetTableEntry_Local_Std
                                   (0359) ELSE
                                   (0360) IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
                                   (0361) export  USB_CB_d2h_std_dev_00
                                   (0362) USB_CB_d2h_std_dev_00:
                                   (0363)     ljmp    APP_USB_CB_d2h_std_dev_00
                                   (0364) ENDIF
                                   (0365) ENDIF
                                   (0366) 
                                   (0367) ;-----------------------------------------------------------------------------
                                   (0368) ;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
                                   (0369) ;-----------------------------------------------------------------------------
                                   (0370) ;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
                                   (0371) ;
                                   (0372) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                   (0373) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                   (0374) ;
                                   (0375) ;-----------------------------------------------------------------------------
                                   (0376) ;
                                   (0377) ;  ARGUMENTS:
                                   (0378) ;
                                   (0379) ;  RETURNS:
                                   (0380) ;
                                   (0381) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0382) ;
                                   (0383) ;  THEORY of OPERATION or PROCEDURE:
                                   (0384) ;
                                   (0385) ;-----------------------------------------------------------------------------
                                   (0386) .LITERAL
                                   (0387) USB_DT_d2h_std_dev:
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) 
03E0: 8F F0    JMP   0x03D1        (0390)     jmp     USB_CB_d2h_std_dev_00
03E2: 8F DE    JMP   0x03C1        (0391)     jmp     USB_CB_d2h_std_dev_01
03E4: 8F DC    JMP   0x03C1        (0392)     jmp     USB_CB_d2h_std_dev_02
03E6: 8F DA    JMP   0x03C1        (0393)     jmp     USB_CB_d2h_std_dev_03
03E8: 8F D8    JMP   0x03C1        (0394)     jmp     USB_CB_d2h_std_dev_04
03EA: 8F D6    JMP   0x03C1        (0395)     jmp     USB_CB_d2h_std_dev_05
03EC: 80 E1    JMP   0x04CE        (0396)     jmp     USB_CB_d2h_std_dev_06
03EE: 8F D2    JMP   0x03C1        (0397)     jmp     USB_CB_d2h_std_dev_07
03F0: 81 3B    JMP   0x052C        (0398)     jmp     USB_CB_d2h_std_dev_08
                                   (0399) 
                                   (0400) USB_DT_d2h_std_dev_End:
                                   (0401) USB_DT_d2h_std_dev_Size: equ (USB_DT_d2h_std_dev_End-USB_DT_d2h_std_dev) / 2
                                   (0402) USB_DT_d2h_std_dev_Dispatch::
03F2: 5D 59    MOV   A,REG[89]     (0403)     mov     A, reg[USB_EP0DATA + bRequest]
03F4: 39 09    CMP   A,9
03F6: D0 04    JNC   0x03FB        (0404)     DISPATCHER USB_DT_d2h_std_dev, USB_DT_d2h_std_dev_Size, USB_Not_Supported
03F8: 64       ASL   A
03F9: EF E6    JACC  0x03E0
03FB: 8F C5    JMP   0x03C1
                                   (0405) 
                                   (0406) .ENDLITERAL
                                   (0407) ;-----------------------------------------------------------------------------
                                   (0408) .LITERAL
                                   (0409) USB_DT_h2d_std_dev:
                                   (0410) ;-----------------------------------------------------------------------------
                                   (0411) 
03FD: 8F C3    JMP   0x03C1        (0412)     jmp     USB_CB_h2d_std_dev_00
03FF: 81 35    JMP   0x0535        (0413)     jmp     USB_CB_h2d_std_dev_01
0401: 8F BF    JMP   0x03C1        (0414)     jmp     USB_CB_h2d_std_dev_02
0403: 81 3C    JMP   0x0540        (0415)     jmp     USB_CB_h2d_std_dev_03
0405: 8F BB    JMP   0x03C1        (0416)     jmp     USB_CB_h2d_std_dev_04
0407: 81 4D    JMP   0x0555        (0417)     jmp     USB_CB_h2d_std_dev_05
0409: 8F B7    JMP   0x03C1        (0418)     jmp     USB_CB_h2d_std_dev_06
040B: 8F B5    JMP   0x03C1        (0419)     jmp     USB_CB_h2d_std_dev_07
040D: 8F B3    JMP   0x03C1        (0420)     jmp     USB_CB_h2d_std_dev_08
040F: 81 4E    JMP   0x055E        (0421)     jmp     USB_CB_h2d_std_dev_09
                                   (0422) 
                                   (0423) USB_DT_h2d_std_dev_End:
                                   (0424) USB_DT_h2d_std_dev_Size: equ (USB_DT_h2d_std_dev_End-USB_DT_h2d_std_dev) / 2
                                   (0425) USB_DT_h2d_std_dev_Dispatch::
                                   (0426) 
0411: 5D 59    MOV   A,REG[89]     (0427)     mov     A, reg[USB_EP0DATA + bRequest]
0413: 39 0A    CMP   A,10
0415: D0 04    JNC   0x041A        (0428)     DISPATCHER USB_DT_h2d_std_dev, USB_DT_h2d_std_dev_Size, USB_Not_Supported
0417: 64       ASL   A
0418: EF E4    JACC  0x03FD
041A: 8F A6    JMP   0x03C1
                                   (0429) 
                                   (0430) .ENDLITERAL
                                   (0431) 
                                   (0432) ;-----------------------------------------------------------------------------
                                   (0433) .LITERAL
                                   (0434) USB_DT_d2h_std_ifc:
                                   (0435) ;-----------------------------------------------------------------------------
                                   (0436) 
041C: 81 9B    JMP   0x05B8        (0437)     jmp     USB_CB_d2h_std_ifc_00
041E: 8F A2    JMP   0x03C1        (0438)     jmp     USB_CB_d2h_std_ifc_01
0420: 8F A0    JMP   0x03C1        (0439)     jmp     USB_CB_d2h_std_ifc_02
0422: 8F 9E    JMP   0x03C1        (0440)     jmp     USB_CB_d2h_std_ifc_03
0424: 8F 9C    JMP   0x03C1        (0441)     jmp     USB_CB_d2h_std_ifc_04
0426: 8F 9A    JMP   0x03C1        (0442)     jmp     USB_CB_d2h_std_ifc_05
0428: 86 8A    JMP   0x0AB3        (0443)     jmp     USB_CB_d2h_std_ifc_06
042A: 8F 96    JMP   0x03C1        (0444)     jmp     USB_CB_d2h_std_ifc_07
042C: 8F 94    JMP   0x03C1        (0445)     jmp     USB_CB_d2h_std_ifc_08
042E: 8F 92    JMP   0x03C1        (0446)     jmp     USB_CB_d2h_std_ifc_09
0430: 81 9F    JMP   0x05D0        (0447)     jmp     USB_CB_d2h_std_ifc_10
                                   (0448) 
                                   (0449) USB_DT_d2h_std_ifc_End:
                                   (0450) USB_DT_d2h_std_ifc_Size: equ (USB_DT_d2h_std_ifc_End-USB_DT_d2h_std_ifc) / 2
                                   (0451) USB_DT_d2h_std_ifc_Dispatch::
0432: 3C 01 00 CMP   [1],0         (0452)     cmp     [USB_Configuration], 0     ; Is the device configured?
0435: B0 03    JNZ   0x0439        (0453)     jnz     .configured                ; Jump on configured
0437: 8F 89    JMP   0x03C1        (0454)     jmp     _USB_Not_Supported         ; Stall the request if not configured
                                   (0455) ; Jump here if the device is configured
                                   (0456) .configured:
0439: 5D 59    MOV   A,REG[89]     (0457)     mov     A, reg[USB_EP0DATA + bRequest]
043B: 39 0B    CMP   A,11
043D: D0 04    JNC   0x0442        (0458)     DISPATCHER USB_DT_d2h_std_ifc, USB_DT_d2h_std_ifc_Size, USB_Not_Supported
043F: 64       ASL   A
0440: EF DB    JACC  0x041C
0442: 8F 7E    JMP   0x03C1
                                   (0459) .ENDLITERAL
                                   (0460) 
                                   (0461) ;-----------------------------------------------------------------------------
                                   (0462) .LITERAL
                                   (0463) USB_DT_h2d_std_ifc:
                                   (0464) ;-----------------------------------------------------------------------------
                                   (0465) 
0444: 8F 7C    JMP   0x03C1        (0466)     jmp     USB_CB_h2d_std_ifc_00
0446: 8F 7A    JMP   0x03C1        (0467)     jmp     USB_CB_h2d_std_ifc_01
0448: 8F 78    JMP   0x03C1        (0468)     jmp     USB_CB_h2d_std_ifc_02
044A: 8F 76    JMP   0x03C1        (0469)     jmp     USB_CB_h2d_std_ifc_03
044C: 8F 74    JMP   0x03C1        (0470)     jmp     USB_CB_h2d_std_ifc_04
044E: 8F 72    JMP   0x03C1        (0471)     jmp     USB_CB_h2d_std_ifc_05
0450: 8F 70    JMP   0x03C1        (0472)     jmp     USB_CB_h2d_std_ifc_06
0452: 8F 6E    JMP   0x03C1        (0473)     jmp     USB_CB_h2d_std_ifc_07
0454: 8F 6C    JMP   0x03C1        (0474)     jmp     USB_CB_h2d_std_ifc_08
0456: 8F 6A    JMP   0x03C1        (0475)     jmp     USB_CB_h2d_std_ifc_09
0458: 8F 68    JMP   0x03C1        (0476)     jmp     USB_CB_h2d_std_ifc_10
045A: 8F 66    JMP   0x03C1        (0477)     jmp     USB_CB_h2d_std_ifc_11
                                   (0478) 
                                   (0479) USB_DT_h2d_std_ifc_End:
                                   (0480) USB_DT_h2d_std_ifc_Size: equ (USB_DT_h2d_std_ifc_End-USB_DT_h2d_std_ifc) / 2
                                   (0481) USB_DT_h2d_std_ifc_Dispatch::
045C: 3C 01 00 CMP   [1],0         (0482)     cmp     [USB_Configuration], 0     ; Is the device configured?
045F: B0 03    JNZ   0x0463        (0483)     jnz     .configured                ; Jump on configured
0461: 8F 5F    JMP   0x03C1        (0484)     jmp     _USB_Not_Supported         ; Stall the request if not configured
                                   (0485) ; Jump here if the device is configured
                                   (0486) .configured:
0463: 5D 59    MOV   A,REG[89]     (0487)     mov     A, reg[USB_EP0DATA + bRequest]
0465: 39 0C    CMP   A,12
                                   (0488) 
                                   (0489)    ;---------------------------------------------------
                                   (0490)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0491)    ;---------------------------------------------------
                                   (0492)    ; Add your custom Interface change logic below
                                   (0493)    ;---------------------------------------------------
                                   (0494) 
                                   (0495)    ;---------------------------------------------------
                                   (0496)    ; Insert your custom code above this banner
                                   (0497)    ;---------------------------------------------------
                                   (0498)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0499) 
0467: D0 04    JNC   0x046C        (0500)     DISPATCHER USB_DT_h2d_std_ifc, USB_DT_h2d_std_ifc_Size, USB_Not_Supported
0469: 64       ASL   A
046A: EF D9    JACC  0x0444
046C: 8F 54    JMP   0x03C1
                                   (0501) .ENDLITERAL
                                   (0502) 
                                   (0503) ;-----------------------------------------------------------------------------
                                   (0504) .LITERAL
                                   (0505) USB_DT_d2h_std_ep:
                                   (0506) ;-----------------------------------------------------------------------------
046E: 81 75    JMP   0x05E4        (0507)     jmp     USB_CB_d2h_std_ep_00
0470: 8F 50    JMP   0x03C1        (0508)     jmp     USB_CB_d2h_std_ep_01
0472: 8F 4E    JMP   0x03C1        (0509)     jmp     USB_CB_d2h_std_ep_02
0474: 8F 4C    JMP   0x03C1        (0510)     jmp     USB_CB_d2h_std_ep_03
0476: 8F 4A    JMP   0x03C1        (0511)     jmp     USB_CB_d2h_std_ep_04
0478: 8F 48    JMP   0x03C1        (0512)     jmp     USB_CB_d2h_std_ep_05
047A: 8F 46    JMP   0x03C1        (0513)     jmp     USB_CB_d2h_std_ep_06
047C: 8F 44    JMP   0x03C1        (0514)     jmp     USB_CB_d2h_std_ep_07
047E: 8F 42    JMP   0x03C1        (0515)     jmp     USB_CB_d2h_std_ep_08
0480: 8F 40    JMP   0x03C1        (0516)     jmp     USB_CB_d2h_std_ep_09
0482: 8F 3E    JMP   0x03C1        (0517)     jmp     USB_CB_d2h_std_ep_10
0484: 8F 3C    JMP   0x03C1        (0518)     jmp     USB_CB_d2h_std_ep_11
0486: 8F 3A    JMP   0x03C1        (0519)     jmp     USB_CB_d2h_std_ep_12
                                   (0520) 
                                   (0521) USB_DT_d2h_std_ep_End:
                                   (0522) USB_DT_d2h_std_ep_Size: equ (USB_DT_d2h_std_ep_End-USB_DT_d2h_std_ep) / 2
                                   (0523) USB_DT_d2h_std_ep_Dispatch::
0488: 3C 01 00 CMP   [1],0         (0524)     cmp     [USB_Configuration], 0     ; Is the device configured?
048B: B0 0D    JNZ   0x0499        (0525)     jnz     .configured                ; Jump on configured
                                   (0526) 
048D: 5D 5D    MOV   A,REG[93]     (0527)     mov     A, reg[USB_EP0DATA + wIndexHi]   ; Is the request for EP0?
048F: 53 1E    MOV   [30],A        (0528)     mov     [USB_t2], A                ; Use the UM temp var--Selector
0491: 5D 5C    MOV   A,REG[92]     (0529)     mov     A, reg[USB_EP0DATA + wIndexLo]   ;
0493: 2C 1E    OR    [30],A        (0530)     or      [USB_t2], A                ; Use the UM temp var--Selector
0495: A0 03    JZ    0x0499        (0531)     jz      .ep0_request
                                   (0532) 
0497: 8F 29    JMP   0x03C1        (0533)     jmp    _USB_Not_Supported          ; Stall the request if not configured
                                   (0534) ; Jump here if the device is configured or EP0 request
                                   (0535) .configured:
                                   (0536) .ep0_request:
0499: 5D 59    MOV   A,REG[89]     (0537)     mov     A, reg[USB_EP0DATA + bRequest]
049B: 39 0D    CMP   A,13
049D: D0 04    JNC   0x04A2        (0538)     DISPATCHER USB_DT_d2h_std_ep, USB_DT_d2h_std_ep_Size, USB_Not_Supported
049F: 64       ASL   A
04A0: EF CD    JACC  0x046E
04A2: 8F 1E    JMP   0x03C1
                                   (0539) 
                                   (0540) .ENDLITERAL
                                   (0541) 
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) .LITERAL
                                   (0544) USB_DT_h2d_std_ep:
                                   (0545) ;-----------------------------------------------------------------------------
04A4: 8F 1C    JMP   0x03C1        (0546)     jmp     USB_CB_h2d_std_ep_00
04A6: 81 56    JMP   0x05FD        (0547)     jmp     USB_CB_h2d_std_ep_01
04A8: 8F 18    JMP   0x03C1        (0548)     jmp     USB_CB_h2d_std_ep_02
04AA: 81 87    JMP   0x0632        (0549)     jmp     USB_CB_h2d_std_ep_03
                                   (0550) 
                                   (0551) USB_DT_h2d_std_ep_End:
                                   (0552) USB_DT_h2d_std_ep_Size: equ (USB_DT_h2d_std_ep_End-USB_DT_h2d_std_ep) / 2
                                   (0553) USB_DT_h2d_std_ep_Dispatch::
04AC: 3C 01 00 CMP   [1],0         (0554)     cmp     [USB_Configuration], 0     ; Is the device configured?
04AF: B0 0D    JNZ   0x04BD        (0555)     jnz     .configured                ; Jump on configured
                                   (0556) 
04B1: 5D 5D    MOV   A,REG[93]     (0557)     mov     A, reg[USB_EP0DATA + wIndexHi]   ; Is the request for EP0?
04B3: 53 1E    MOV   [30],A        (0558)     mov     [USB_t2], A                ; Use the UM temp var--Selector
04B5: 5D 5C    MOV   A,REG[92]     (0559)     mov     A, reg[USB_EP0DATA + wIndexLo]   ;
04B7: 2C 1E    OR    [30],A        (0560)     or      [USB_t2], A                ; Use the UM temp var--Selector
04B9: A0 03    JZ    0x04BD        (0561)     jz      .ep0_request
                                   (0562) 
04BB: 8F 05    JMP   0x03C1        (0563)     jmp    _USB_Not_Supported          ; Stall the request if not configured
                                   (0564) ; Jump here if the device is configured or EP0 request
                                   (0565) .configured:
                                   (0566) .ep0_request:
04BD: 5D 59    MOV   A,REG[89]     (0567)     mov     A, reg[USB_EP0DATA + bRequest]
04BF: 39 04    CMP   A,4
04C1: D0 04    JNC   0x04C6        (0568)     DISPATCHER USB_DT_h2d_std_ep, USB_DT_h2d_std_ep_Size, USB_Not_Supported
04C3: 64       ASL   A
04C4: EF DF    JACC  0x04A4
04C6: 8E FA    JMP   0x03C1
                                   (0569) 
                                   (0570) USB_GetTableEntry_Local_Std:
04C8: 7D 08 5D LJMP  0x085D        (0571)     ljmp    USB_GetTableEntry
                                   (0572) 
                                   (0573) USB_NoDataStageControlTransfer_Local_Std:
04CB: 7D 07 4A LJMP  0x074A        (0574)     ljmp    USB_NoDataStageControlTransfer
                                   (0575) 
                                   (0576) .ENDLITERAL
                                   (0577) ;-----------------------------------------------
                                   (0578) ; Add custom application code for routines
                                   (0579) ; redefined by USB_APP_SUPPLIED in USB_HID.inc
                                   (0580) ;-----------------------------------------------
                                   (0581) 
                                   (0582)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0583)    ;---------------------------------------------------
                                   (0584)    ; Insert your custom code below this banner
                                   (0585)    ;---------------------------------------------------
                                   (0586) 
                                   (0587)    ;---------------------------------------------------
                                   (0588)    ; Insert your custom code above this banner
                                   (0589)    ;---------------------------------------------------
                                   (0590)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0591) 
                                   (0592) ;-----------------------------------------------------------------------------
                                   (0593) ; FUNCTION NAME: USB_CB_d2h_std_dev_06
                                   (0594) ;
                                   (0595) ; DESCRIPTION:   Get Device Descriptor
                                   (0596) ;
                                   (0597) ;****************************************************************
                                   (0598) ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                                   (0599) ;****************************************************************
                                   (0600) ;
                                   (0601) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                   (0602) ; bRequest       : GET_DESCRIPTOR                 = 06h
                                   (0603) ; wValue         : DESCRIPTOR TYPE | index        = xxxxh
                                   (0604) ; wIndex         : ZERO or LANG_ID                = xxxxh
                                   (0605) ; wLength        : SIZEOF_DESCRIPTOR              = --xxh
                                   (0606) ;
                                   (0607) ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if
                                   (0608) ; the descriptor exists.
                                   (0609) ;
                                   (0610) ; The upper byte of wValue contains the descriptor type and
                                   (0611) ; the lower byte contains the descriptor index. wIndex
                                   (0612) ; contains either 0000h or the Language ID. wLength contains
                                   (0613) ; the descriptor length. The actual descriptor information is
                                   (0614) ; transferred in subsequent data packets.
                                   (0615) ;
                                   (0616) ;****************************************************************
                                   (0617) ;
                                   (0618) ;-----------------------------------------------------------------------------
                                   (0619) ;
                                   (0620) ;  ARGUMENTS:
                                   (0621) ;
                                   (0622) ;  RETURNS:
                                   (0623) ;
                                   (0624) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0625) ;
                                   (0626) ;  THEORY of OPERATION or PROCEDURE:
                                   (0627) ;
                                   (0628) ;-----------------------------------------------------------------------------
                                   (0629) IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                                   (0630) export  USB_CB_d2h_std_dev_06
                                   (0631) USB_CB_d2h_std_dev_06:
                                   (0632) ;-----------------------------------------------------------------------------
                                   (0633) ; Dispatch to the proper handler
                                   (0634) ;-----------------------------------------------------------------------------
04CE: 5D 5B    MOV   A,REG[91]     (0635)     mov     A, reg[USB_EP0DATA+wValueHi]   ; Get the descrptor type
04D0: 64       ASL   A             (0636)     asl     A                          ; Make it into a offset
04D1: 39 08    CMP   A,8           (0637)     cmp     A, GET_DESCR_DISPATCH_SIZE           ; Validity check
04D3: DE ED    JNC   0x03C1        (0638)     jnc     USB_Not_Supported
                                   (0639) 
04D5: E0 01    JACC  0x04D7        (0640)     jacc    GET_DESCR_DISPATCH
                                   (0641) 
                                   (0642) GET_DESCR_DISPATCH:
04D7: 8E E9    JMP   0x03C1        (0643)     jmp     USB_Not_Supported          ; Invalid
04D9: 80 28    JMP   0x0502        (0644)     jmp     USB_SendDeviceDescr        ; Device Descriptor
04DB: 80 03    JMP   0x04DF        (0645)     jmp     USB_SendConfigDescr        ; Configuration Descriptor
                                   (0646) IF  USB_bNumStringDescrs               ; Number of String Descriptor defined with the Wizard
04DD: 80 34    JMP   0x0512        (0647)     jmp     USB_SendStringDescr        ; String Descriptor
                                   (0648) ELSE
                                   (0649)     jmp     USB_Not_Supported          ; Not supported if we don't have
                                   (0650)                                               ; any String Descriptor
                                   (0651) ENDIF
                                   (0652) 
                                   (0653) GET_DESCR_DISPATCH_END:
                                   (0654) GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)
                                   (0655) ;-----------------------------------------------------------------------------
                                   (0656) ; Configuration Descriptor Handler
                                   (0657) ;-----------------------------------------------------------------------------
                                   (0658) USB_SendConfigDescr:
04DF: 93 C1    CALL  0x08A2        (0659)     call    USB_GET_DEVICE_TABLE_ENTRY
04E1: 4B       SWAP  A,X           (0660)     swap    A, X
04E2: 01 02    ADD   A,2           (0661)     add     A, 2                       ; We want the pointer to the descriptor table (second entry)
04E4: 4B       SWAP  A,X           (0662)     swap    A, X
04E5: 09 00    ADC   A,0           (0663)     adc     A, 0                       ; Don't forget the carry
04E7: 55 1E 1F MOV   [30],31       (0664)     mov     [USB_t2], USB_t1           ; Set up the destination
04EA: 93 A5    CALL  0x0891        (0665)     call    USB_GETWORD                ; Get the pointer
                                   (0666) 
04EC: 51 1F    MOV   A,[31]        (0667)     mov     A, [USB_t1]                ; Pointer MSB
04EE: 58 20    MOV   X,[32]        (0668)     mov     X, [USB_t1+1]              ; Pointer LSB
                                   (0669) 
04F0: 08       PUSH  A             (0670)     push    A                          ; Save the MSB
                                   (0671) 
04F1: 5D 5A    MOV   A,REG[90]     (0672)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the descrptor index
04F3: 53 1E    MOV   [30],A        (0673)     mov     [USB_t2], A                ; Use the UM temp var--Selector
04F5: 18       POP   A             (0674)     pop     A                          ; Need the MSB for the range check
04F6: 08       PUSH  A             (0675)     push    A                          ; Save the MSB for after the range check
04F7: 28       ROMX                (0676)     romx                               ; First entry is the table size (only a byte)
04F8: 3A 1E    CMP   A,[30]        (0677)     cmp     A, [USB_t2]                ; Range check
04FA: D0 04    JNC   0x04FF        (0678)     jnc     .range_ok
                                   (0679) 
04FC: 18       POP   A             (0680)     pop     A                          ; Fix the stack
04FD: 8E C3    JMP   0x03C1        (0681)     jmp     USB_Not_Supported
                                   (0682) 
                                   (0683) .range_ok:
04FF: 18       POP   A             (0684)     pop     A                          ; Get the MSB back
0500: 8F C7    JMP   0x04C8        (0685)     jmp     USB_GetTableEntry_Local_Std
                                   (0686) ;-----------------------------------------------------------------------------
                                   (0687) ; Device Descriptor Handler
                                   (0688) ;-----------------------------------------------------------------------------
                                   (0689) USB_SendDeviceDescr:
0502: 5F 1E 00 MOV   [30],[0]      (0690)     mov     [USB_t2], [USB_bCurrentDevice]    ; Use the UM temp var--Selector
0505: 50 03    MOV   A,3           (0691)     mov     A, >USB_DEVICE_DESCR_TABLE    ; Get the ROM Address MSB
0507: 57 53    MOV   X,83          (0692)     mov     X, <USB_DEVICE_DESCR_TABLE    ; Get the ROM Address LSB
0509: 28       ROMX                (0693)     romx                               ; First entry is the table size (only a byte)
050A: 3A 1E    CMP   A,[30]        (0694)     cmp     A, [USB_t2]                ; Range check
050C: CE B4    JC    0x03C1        (0695)     jc      USB_Not_Supported
                                   (0696) 
050E: 50 03    MOV   A,3           (0697)     mov     A, >USB_DEVICE_DESCR_TABLE    ; Get the ROM Address MSB
                                   (0698) 
0510: 8F B7    JMP   0x04C8        (0699)     jmp     USB_GetTableEntry_Local_Std
                                   (0700) ;-----------------------------------------------------------------------------
                                   (0701) ; String Descriptor Handler
                                   (0702) ;-----------------------------------------------------------------------------
                                   (0703) IF  USB_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
                                   (0704) USB_SendStringDescr:
0512: 5D 5A    MOV   A,REG[90]     (0705)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the descrptor index
0514: 53 1E    MOV   [30],A        (0706)     mov     [USB_t2], A                ; Use the UM temp var--Selector
                                   (0707) 
0516: 50 09    MOV   A,9           (0708)     mov     A, >USB_StringTable        ; Get the ROM Address MSB
0518: 57 9D    MOV   X,157         (0709)     mov     X, <USB_StringTable        ; Get the ROM Address LSB
051A: 28       ROMX                (0710)     romx                               ; First entry is the table size (only a byte)
051B: 3A 1E    CMP   A,[30]        (0711)     cmp     A, [USB_t2]                ; Range check
051D: CE A3    JC    0x03C1        (0712)     jc      USB_Not_Supported
                                   (0713) 
051F: 50 09    MOV   A,9           (0714)     mov     A, >USB_StringTable        ; Get the ROM Address MSB
                                   (0715) 
0521: 8F A6    JMP   0x04C8        (0716)     jmp     USB_GetTableEntry_Local_Std
0523: 00       SWI   
0524: 01 00    ADD   A,0
0526: 01 00    ADD   A,0
0528: 01 00    ADD   A,0
052A: 00       SWI   
052B: DE 55    JNC   0x0381
                                   (0717) ENDIF
                                   (0718) ELSE
                                   (0719) IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
                                   (0720) export  USB_CB_d2h_std_dev_06
                                   (0721) USB_CB_d2h_std_dev_06:
                                   (0722)     ljmp    APP_USB_CB_d2h_std_dev_06
                                   (0723) ENDIF
                                   (0724) ENDIF
                                   (0725) ;-----------------------------------------------------------------------------
                                   (0726) ;  FUNCTION NAME: USB_CB_d2h_std_dev_08
                                   (0727) ;
                                   (0728) ;  DESCRIPTION:   Get Device Configuration
                                   (0729) ;
                                   (0730) ;****************************************************************
                                   (0731) ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                                   (0732) ;****************************************************************
                                   (0733) ;
                                   (0734) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                   (0735) ; bRequest       : GET_CONFIGURATION              = 08h
                                   (0736) ; wValue         : RESERVED                       = 0000h
                                   (0737) ; wIndex         : RESERVED                       = 0000h
                                   (0738) ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h
                                   (0739) ;
                                   (0740) ; The GET_DEVICE_CONFIGURATION request returns the currently
                                   (0741) ; selected device configuration number.
                                   (0742) ;
                                   (0743) ; request_value and request_index contain 0000h. request_length
                                   (0744) ; contains 0001h and the one-byte configuration number is returned
                                   (0745) ; in a separate data transfer.
                                   (0746) ;
                                   (0747) ;-----------------------------------------------------------------------------
                                   (0748) ;
                                   (0749) ;  ARGUMENTS:
                                   (0750) ;
                                   (0751) ;  RETURNS:
                                   (0752) ;
                                   (0753) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0754) ;
                                   (0755) ;  THEORY of OPERATION or PROCEDURE:
                                   (0756) ;
                                   (0757) ;-----------------------------------------------------------------------------
                                   (0758) IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
                                   (0759) .LITERAL
                                   (0760) GetConfigTransferDescrTable:
                                   (0761)     TD_START_TABLE  1                  ; One entry
                                   (0762)     TD_ENTRY    USB_DS_RAM, 1, USB_Configuration, NULL_PTR    ; Current configuration
                                   (0763) .ENDLITERAL
                                   (0764) export  USB_CB_d2h_std_dev_08
                                   (0765) USB_CB_d2h_std_dev_08:
052D: 1E 00 50 SBB   [0],80        (0766)     mov     [USB_t2], 0                ; Use the UM temp var--Selector
0530: 05 57    ADD   [X+87],A      (0767)     mov     A, >GetConfigTransferDescrTable    ; Get the ROM Address MSB
0532: 23 8F    AND   A,[X-113]     (0768)     mov     X, <GetConfigTransferDescrTable    ; Get the ROM Address LSB
0534: 94 5D    CALL  0x0993        (0769)     jmp     USB_GetTableEntry_Local_Std
                                   (0770) ELSE
                                   (0771) IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
                                   (0772) export  USB_CB_d2h_std_dev_08
                                   (0773) USB_CB_d2h_std_dev_08:
                                   (0774)     ljmp    APP_USB_CB_d2h_std_dev_08
                                   (0775) ENDIF
                                   (0776) ENDIF
                                   (0777) ;-----------------------------------------------------------------------------
                                   (0778) ;  FUNCTION NAME: USB_CB_h2d_std_dev_01
                                   (0779) ;
                                   (0780) ;  DESCRIPTION:   Clear Device Feature
                                   (0781) ;
                                   (0782) ;****************************************************************
                                   (0783) ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                                   (0784) ;****************************************************************
                                   (0785) ;
                                   (0786) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0787) ; bRequest       : CLEAR_FEATURE                  = 01h
                                   (0788) ; wValue         : FEATURE_SELECTOR               = --xxh
                                   (0789) ; wIndex         : RESERVED                       = 0000h
                                   (0790) ; wLength        : RESERVED                       = 0000h
                                   (0791) ;
                                   (0792) ; The CLEAR_DEVICE_FEATURE request disables a particular feature
                                   (0793) ; for a device. The only feature supported for a device is the
                                   (0794) ; REMOTE_WAKEUP feature.
                                   (0795) ;
                                   (0796) ;****************************************************************
                                   (0797) ;-----------------------------------------------------------------------------
                                   (0798) ;
                                   (0799) ;  ARGUMENTS:
                                   (0800) ;
                                   (0801) ;  RETURNS:
                                   (0802) ;
                                   (0803) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0804) ;
                                   (0805) ;  THEORY of OPERATION or PROCEDURE:
                                   (0806) ;
                                   (0807) ;-----------------------------------------------------------------------------
                                   (0808) IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                                   (0809) export  USB_CB_h2d_std_dev_01
                                   (0810) USB_CB_h2d_std_dev_01:
0536: 5A 39    MOV   [57],X        (0811)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the Feature Selector
                                   (0812)                                        ; Check against valid features
                                   (0813)                                        ;  for device receipient
0538: 01 BE    ADD   A,190         (0814)     cmp     A, USB_DEVICE_REMOTE_WAKEUP    ; Only remote wakeup is defined for clear
053A: 87 26    JMP   0x0C61        (0815)     jnz     USB_Not_Supported          ;
053C: 02 FD    ADD   A,[253]       (0816)     and     [USB_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
053E: 8F 8C    JMP   0x04CB        (0817)     jmp     USB_NoDataStageControlTransfer_Local_Std
                                   (0818) ELSE
                                   (0819) IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
                                   (0820) export  USB_CB_h2d_std_dev_01
                                   (0821) USB_CB_h2d_std_dev_01:
                                   (0822)     ljmp    APP_USB_CB_h2d_std_dev_01
                                   (0823) ENDIF
                                   (0824) ENDIF
                                   (0825) ;-----------------------------------------------------------------------------
                                   (0826) ;  FUNCTION NAME: USB_CB_h2d_std_dev_03
                                   (0827) ;
                                   (0828) ;  DESCRIPTION:   Set Device Featue
                                   (0829) ;
                                   (0830) ;****************************************************************
                                   (0831) ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                                   (0832) ;****************************************************************
                                   (0833) ;
                                   (0834) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0835) ; bRequest       : SET_FEATURE                    = 03h
                                   (0836) ; wValue         : FEATURE_SELECTOR               = --xxh
                                   (0837) ; wIndex         : RESERVED                       = 0000h
                                   (0838) ; wLength        : RESERVED                       = 0000h
                                   (0839) ;
                                   (0840) ; The SET_DEVICE_FEATURE request enables a particular feature
                                   (0841) ; on a device. The only feature supported for a device is the
                                   (0842) ; REMOTE_WAKEUP feature.
                                   (0843) ;
                                   (0844) ;****************************************************************
                                   (0845) ;-----------------------------------------------------------------------------
                                   (0846) ;
                                   (0847) ;  ARGUMENTS:
                                   (0848) ;
                                   (0849) ;  RETURNS:
                                   (0850) ;
                                   (0851) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0852) ;
                                   (0853) ;  THEORY of OPERATION or PROCEDURE:
                                   (0854) ;
                                   (0855) ;-----------------------------------------------------------------------------
                                   (0856) IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                                   (0857) export  USB_CB_h2d_std_dev_03
                                   (0858) USB_CB_h2d_std_dev_03:
0540: 5D 5A    MOV   A,REG[90]     (0859)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the Feature Selector
                                   (0860)                                        ; Check against valid features
                                   (0861)                                        ;  for device receipient
0542: 39 01    CMP   A,1           (0862)     cmp     A, USB_DEVICE_REMOTE_WAKEUP    ; Remote wakeup?
0544: A0 07    JZ    0x054C        (0863)     jz      .remote_wakeup
                                   (0864) 
0546: 39 02    CMP   A,2           (0865)     cmp     A, USB_TEST_MODE           ; Test Mode
0548: A0 08    JZ    0x0551        (0866)     jz      .test_mode
                                   (0867) ; Flow here for any other selector is invalid for device receipient
054A: 8E 76    JMP   0x03C1        (0868)     jmp     USB_Not_Supported
                                   (0869) ; Jump here to enable remote wake up
                                   (0870) .remote_wakeup:
054C: 2E 02 02 OR    [2],2         (0871)     or      [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
054F: 80 03    JMP   0x0553        (0872)     jmp     .finish
                                   (0873) ; Jump here to enable test mode
                                   (0874) .test_mode:
0551: 8E 6F    JMP   0x03C1        (0875)     jmp     USB_Not_Supported
                                   (0876) .finish:
0553: 8F 77    JMP   0x04CB        (0877)     jmp     USB_NoDataStageControlTransfer_Local_Std
                                   (0878) ELSE
                                   (0879) IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
                                   (0880) export  USB_CB_h2d_std_dev_03
                                   (0881) USB_CB_h2d_std_dev_03:
                                   (0882)     ljmp    APP_USB_CB_h2d_std_dev_03
                                   (0883) ENDIF
                                   (0884) ENDIF
                                   (0885) ;-----------------------------------------------------------------------------
                                   (0886) ;  FUNCTION NAME: USB_CB_h2d_std_dev_05
                                   (0887) ;
                                   (0888) ;  DESCRIPTION:   Set Device Address
                                   (0889) ;
                                   (0890) ;****************************************************************
                                   (0891) ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                                   (0892) ;****************************************************************
                                   (0893) ;
                                   (0894) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0895) ; bRequest       : SET_ADDRESS                    = 05h
                                   (0896) ; wValue         : DEVICE_ADDRESS                 = 00xxh
                                   (0897) ; wIndex         : RESERVED                       = 0000h
                                   (0898) ; wLength        : RESERVED                       = 0000h
                                   (0899) ;
                                   (0900) ; The SET_DEVICE_ADDRESS request sets the USB device address
                                   (0901) ; for all future USB accesses.
                                   (0902) ;
                                   (0903) ;****************************************************************
                                   (0904) ;
                                   (0905) ;-----------------------------------------------------------------------------
                                   (0906) ;
                                   (0907) ;  ARGUMENTS:
                                   (0908) ;
                                   (0909) ;  RETURNS:
                                   (0910) ;
                                   (0911) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0912) ;
                                   (0913) ;  THEORY of OPERATION or PROCEDURE:
                                   (0914) ;
                                   (0915) ;-----------------------------------------------------------------------------
                                   (0916) IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                                   (0917) export  USB_CB_h2d_std_dev_05
                                   (0918) USB_CB_h2d_std_dev_05:
                                   (0919)       
0555: 55 1D 01 MOV   [29],1        (0920)     mov     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING       
0558: 5D 5A    MOV   A,REG[90]     (0921)     mov     A, reg[USB_EP0DATA+wValueLo]       
055A: 53 0B    MOV   [11],A        (0922)     mov     [USB_TransferBuffer], A       
                                   (0923)                                                    
055C: 8F 6E    JMP   0x04CB        (0924)     jmp     USB_NoDataStageControlTransfer_Local_Std
                                   (0925) ELSE
                                   (0926) IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
                                   (0927) export  USB_CB_h2d_std_dev_05
                                   (0928) USB_CB_h2d_std_dev_05:
                                   (0929)     ljmp    APP_USB_CB_h2d_std_dev_05
                                   (0930) ENDIF
                                   (0931) ENDIF
                                   (0932) 
                                   (0933) 
                                   (0934) ;-----------------------------------------------------------------------------
                                   (0935) ;  FUNCTION NAME: USB_CB_h2d_std_dev_09
                                   (0936) ;
                                   (0937) ;  DESCRIPTION:   Set Configuration
                                   (0938) ;
                                   (0939) ;****************************************************************
                                   (0940) ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                                   (0941) ;****************************************************************
                                   (0942) ;
                                   (0943) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0944) ; bRequest       : SET_CONFIGURATION              = 09h
                                   (0945) ; wValue         : CONFIGURATION_VALUE            = --xxh
                                   (0946) ; wIndex         : RESERVED                       = 0000h
                                   (0947) ; wLength        : RESERVED                       = 0000h
                                   (0948) ;
                                   (0949) ; The SET_DEVICE_CONFIGURATION request selects a device
                                   (0950) ; configuration to be activated as the current configuration.
                                   (0951) ;
                                   (0952) ;****************************************************************
                                   (0953) ;-----------------------------------------------------------------------------
                                   (0954) ;
                                   (0955) ;  ARGUMENTS:
                                   (0956) ;
                                   (0957) ;  RETURNS:
                                   (0958) ;
                                   (0959) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0960) ;
                                   (0961) ;  THEORY of OPERATION or PROCEDURE:
                                   (0962) ;
                                   (0963) ;-----------------------------------------------------------------------------
                                   (0964) IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                                   (0965) export  USB_CB_h2d_std_dev_09
                                   (0966) USB_CB_h2d_std_dev_09:
055E: 93 42    CALL  0x08A2        (0967)     call    USB_GET_DEVICE_TABLE_ENTRY    ; Get the selected device
0560: 55 1E 1F MOV   [30],31       (0968)     mov     [USB_t2], USB_t1           ; Set the GETWORD destination
0563: 93 2C    CALL  0x0891        (0969)     call    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                   (0970)                                        ; ITempW has the address
0565: 5D 5A    MOV   A,REG[90]     (0971)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the configuration number
0567: 53 1E    MOV   [30],A        (0972)     mov     [USB_t2], A                ; Save it
0569: 51 1F    MOV   A,[31]        (0973)     mov     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
056B: 58 20    MOV   X,[32]        (0974)     mov     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
056D: 28       ROMX                (0975)     romx                               ; First entry is the table size (only a byte)
056E: 3A 1E    CMP   A,[30]        (0976)     cmp     A, [USB_t2]                ; Range check
0570: CE 50    JC    0x03C1        (0977)     jc      USB_Not_Supported
                                   (0978) 
                                   (0979) ; Refactored from the two loops below
0572: 5F 01 1E MOV   [1],[30]      (0980)     mov     [USB_Configuration], [USB_t2]    ; Save the config number
                                   (0981) 
0575: 3C 1E 00 CMP   [30],0        (0982)     cmp     [USB_t2], 0                ; Unconfigure?
0578: A0 25    JZ    0x059E        (0983)     jz      .unconfigure
                                   (0984) 
                                   (0985) ; Flow here to configure the endpoints
057A: 51 1F    MOV   A,[31]        (0986)     mov     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
057C: 58 20    MOV   X,[32]        (0987)     mov     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
057E: 75       INC   X             (0988)     inc     X                          ; Point to the first table entry
057F: 09 00    ADC   A,0           (0989)     adc     A, 0                       ;
0581: 55 1E 1F MOV   [30],31       (0990)     mov     [USB_t2], USB_t1           ; Set up the destination
0584: 93 0B    CALL  0x0891        (0991)     call    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                   (0992)                                        ; ITempW has the address
0586: 57 00    MOV   X,0           (0993)     mov     X, 0                       ; Start the index at 0, but we inc first
                                   (0994) .configure_next:
0588: 75       INC   X             (0995)     inc     X                          ; Do the next one
0589: 10       PUSH  X             (0996)     push    X                          ; Save the endpoint number
058A: 51 1F    MOV   A,[31]        (0997)     mov     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
058C: 58 20    MOV   X,[32]        (0998)     mov     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
058E: 28       ROMX                (0999)     romx
058F: 76 20    INC   [32]          (1000)     inc     [USB_t1+1]                 ; Point to the next
0591: 0E 1F 00 ADC   [31],0        (1001)     adc     [USB_t1], 0                ;
0594: 20       POP   X             (1002)     pop     X
0595: 90 C7    CALL  0x065E        (1003)     call    ConfigureEP                ; X contains the EP number
                                   (1004)                                        ; A contains the EP Direction
0597: 5B       MOV   A,X           (1005)     mov     A, X                       ;
0598: 39 04    CMP   A,4           (1006)     cmp     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
059A: BF ED    JNZ   0x0588        (1007)     jnz     .configure_next            ; Do another one?
                                   (1008) ; Flow here when we are done
059C: 80 10    JMP   0x05AD        (1009)     jmp     .done
                                   (1010) 
                                   (1011) ; Jump here to unconfigure the endpoints
                                   (1012) .unconfigure:
059E: 71 10    OR    F,16          (1013)     M8C_SetBank1	; _EP1MODE is in Bank 1
05A0: 57 04    MOV   X,4           (1014)     mov     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
                                   (1015) .unconfigure_next:
05A2: 56 21 02 MOV   [X+33],2      (1016)     mov     [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED   ; For the API
05A5: 63 C3 00 MOV   REG[X+195],0  (1017)     mov     reg[X+USB_EP1MODE-1], USB_MODE_DISABLE   ; Disable the endpoint
05A8: 79       DEC   X             (1018)     dec     X                          ; One more down
05A9: BF F8    JNZ   0x05A2        (1019)     jnz     .unconfigure_next          ; Don't unconfigure EP0
05AB: 70 EF    AND   F,239         (1020) 	M8C_SetBank0
                                   (1021) .done:
05AD: 8F 1D    JMP   0x04CB        (1022)     jmp     USB_NoDataStageControlTransfer_Local_Std
05AF: 00       SWI   
05B0: 01 00    ADD   A,0
05B2: 02 00    ADD   A,[0]
05B4: 0B 00    ADC   A,[X+0]
05B6: 00       SWI   
05B7: DE 55    JNC   0x040D
                                   (1023) ELSE
                                   (1024) IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
                                   (1025) export  USB_CB_h2d_std_dev_09
                                   (1026) USB_CB_h2d_std_dev_09:
                                   (1027)     ljmp    APP_USB_CB_h2d_std_dev_09
                                   (1028) ENDIF
                                   (1029) ENDIF
                                   (1030) ;-----------------------------------------------------------------------------
                                   (1031) ;  FUNCTION NAME: USB_CB_d2h_std_ifc_00
                                   (1032) ;
                                   (1033) ;  DESCRIPTION:   Get Interface Status
                                   (1034) ;
                                   (1035) ;****************************************************************
                                   (1036) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                                   (1037) ;****************************************************************
                                   (1038) ;
                                   (1039) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                   (1040) ; bRequest       : GET_STATUS                     = 00h
                                   (1041) ; wValue         : RESERVED                       = 0000h
                                   (1042) ; wIndex         : INTERFACE                      = --xxh
                                   (1043) ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h
                                   (1044) ;
                                   (1045) ; The GET_INTERFACE_STATUS request returns status for the
                                   (1046) ; specified interface.
                                   (1047) ;
                                   (1048) ;****************************************************************
                                   (1049) ;-----------------------------------------------------------------------------
                                   (1050) ;
                                   (1051) ;  ARGUMENTS:
                                   (1052) ;
                                   (1053) ;  RETURNS:
                                   (1054) ;
                                   (1055) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (1056) ;
                                   (1057) ;  THEORY of OPERATION or PROCEDURE:
                                   (1058) ;
                                   (1059) ;-----------------------------------------------------------------------------
                                   (1060) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
                                   (1061) .LITERAL
                                   (1062) GetInterfaceStatusTransferDescrTable:
                                   (1063)     TD_START_TABLE  1                  ; One entry
                                   (1064)     TD_ENTRY        USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR    ; Reuse the transfer buffer
                                   (1065) .ENDLITERAL
                                   (1066) export  USB_CB_d2h_std_ifc_00
                                   (1067) USB_CB_d2h_std_ifc_00:
05B9: 0B 00    ADC   A,[X+0]       (1068)     mov     [USB_TransferBuffer], 0       ; Zero the transfer buffer
05BB: 55 0C 00 MOV   [12],0        (1069)     mov     [USB_TransferBuffer+1], 0    ;
                                   (1070) 
05BE: 55 1E 00 MOV   [30],0        (1071)     mov     [USB_t2], 0                ; Use the UM temp var--Selector
05C1: 50 05    MOV   A,5           (1072)     mov     A, >GetInterfaceStatusTransferDescrTable    ; Get the ROM Address MSB
05C3: 57 AF    MOV   X,175         (1073)     mov     X, <GetInterfaceStatusTransferDescrTable    ; Get the ROM Address LSB
                                   (1074) 
05C5: 8F 02    JMP   0x04C8        (1075)     jmp     USB_GetTableEntry_Local_Std
05C7: 00       SWI   
05C8: 01 00    ADD   A,0
05CA: 01 00    ADD   A,0
05CC: 0B 00    ADC   A,[X+0]
05CE: 00       SWI   
05CF: DE 5D    JNC   0x042D
                                   (1076) ELSE
                                   (1077) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
                                   (1078) export  USB_CB_d2h_std_ifc_00
                                   (1079) USB_CB_d2h_std_ifc_00:
                                   (1080)     ljmp    APP_USB_CB_d2h_std_ifc_00
                                   (1081) ENDIF
                                   (1082) ENDIF
                                   (1083) ;-----------------------------------------------------------------------------
                                   (1084) ;  FUNCTION NAME: USB_CB_d2h_std_ifc_10
                                   (1085) ;
                                   (1086) ;  DESCRIPTION:   Get Interface
                                   (1087) ;
                                   (1088) ;****************************************************************
                                   (1089) ; STANDARD INTERFACE IN REQUEST: Get_Interface
                                   (1090) ;****************************************************************
                                   (1091) ;
                                   (1092) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                   (1093) ; bRequest       : GET_INTERFACE                  = 0Ah
                                   (1094) ; wValue         : RESERVED                       = 0000h
                                   (1095) ; wIndex         : INTERFACE                      = xxxxh
                                   (1096) ; wLength        : SIZEOF_GET_INTERFACE           = 0001h
                                   (1097) ;
                                   (1098) ; The GET_INTERFACE request returns the selected alternate
                                   (1099) ; setting for the specified interface.
                                   (1100) ;
                                   (1101) ;****************************************************************
                                   (1102) ;-----------------------------------------------------------------------------
                                   (1103) ;
                                   (1104) ;  ARGUMENTS:
                                   (1105) ;
                                   (1106) ;  RETURNS:
                                   (1107) ;
                                   (1108) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (1109) ;
                                   (1110) ;  THEORY of OPERATION or PROCEDURE:
                                   (1111) ;
                                   (1112) ;-----------------------------------------------------------------------------
                                   (1113) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
                                   (1114) .LITERAL
                                   (1115) GetInterfaceTransferDescrTable:
                                   (1116)     TD_START_TABLE  1                  ; One entry
                                   (1117)     TD_ENTRY        USB_DS_RAM, 1, USB_TransferBuffer, NULL_PTR    ; Reuse the transfer buffer
                                   (1118) .ENDLITERAL
                                   (1119) export  USB_CB_d2h_std_ifc_10
                                   (1120) USB_CB_d2h_std_ifc_10:
05D1: 5C       MOV   X,A           (1121)     mov     A, reg[USB_EP0DATA+wIndexLo]    ; Get the interface number
05D2: 39 01    CMP   A,1           (1122)     cmp     A, 1h                      ; Valid interface number? (UM Parameter: NumInterfaces)
05D4: DD EC    JNC   0x03C1        (1123)     jnc     USB_Not_Supported
                                   (1124) 
05D6: 5C       MOV   X,A           (1125)     mov     X, A                       ; The interface number is the index into alternates settings table
                                   (1126) 
05D7: 52 03    MOV   A,[X+3]       (1127)     mov     A, [X + USB_InterfaceSetting]    ; Save the current interface setting
05D9: 53 0B    MOV   [11],A        (1128)     mov     [USB_TransferBuffer], A       ; into the transfer buffer
                                   (1129) 
05DB: 55 1E 00 MOV   [30],0        (1130)     mov     [USB_t2], 0                ; Use the UM temp var--Selector
05DE: 50 05    MOV   A,5           (1131)     mov     A, >GetInterfaceTransferDescrTable    ; Get the ROM Address MSB
05E0: 57 C7    MOV   X,199         (1132)     mov     X, <GetInterfaceTransferDescrTable    ; Get the ROM Address LSB
                                   (1133) 
05E2: 8E E5    JMP   0x04C8        (1134)     jmp     USB_GetTableEntry_Local_Std
                                   (1135) ELSE
                                   (1136) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
                                   (1137) export  USB_CB_d2h_std_ifc_10
                                   (1138) USB_CB_d2h_std_ifc_10:
                                   (1139)     ljmp    APP_USB_CB_d2h_std_ifc_10
                                   (1140) ENDIF
                                   (1141) ENDIF
                                   (1142) ;-----------------------------------------------------------------------------
                                   (1143) ;  FUNCTION NAME: USB_CB_d2h_std_ep_00
                                   (1144) ;
                                   (1145) ;  DESCRIPTION:   Get Endpoint Status
                                   (1146) ;
                                   (1147) ;****************************************************************
                                   (1148) ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                                   (1149) ;****************************************************************
                                   (1150) ;
                                   (1151) ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h
                                   (1152) ; bRequest       : GET_STATUS                     = 00h
                                   (1153) ; wValue         : RESERVED                       = 0000h
                                   (1154) ; wIndex         : ENDPOINT                       = 00xxh
                                   (1155) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                   (1156) ;
                                   (1157) ; The GET_ENDPOINT_STATUS request returns status for the specified
                                   (1158) ; endpoint.
                                   (1159) ;
                                   (1160) ;****************************************************************
                                   (1161) ;-----------------------------------------------------------------------------
                                   (1162) ;
                                   (1163) ;  ARGUMENTS:
                                   (1164) ;
                                   (1165) ;  RETURNS:
                                   (1166) ;
                                   (1167) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (1168) ;
                                   (1169) ;  THEORY of OPERATION or PROCEDURE:
                                   (1170) ;
                                   (1171) ;-----------------------------------------------------------------------------
                                   (1172) IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                                   (1173) export  USB_CB_d2h_std_ep_00
                                   (1174) USB_CB_d2h_std_ep_00:
05E4: 5D 5C    MOV   A,REG[92]     (1175)     mov     A, reg[USB_EP0DATA+wIndexLo]    ; Get the endpoint number
05E6: 21 7F    AND   A,127         (1176)     and     A, ~USB_DIR_IN             ; Strip off the direction bit
05E8: 39 05    CMP   A,5           (1177)     cmp     A, USB_NUM_ENDPOINTS       ; Range check
05EA: DD D6    JNC   0x03C1        (1178)     jnc     USB_Not_Supported
                                   (1179) 
05EC: 5C       MOV   X,A           (1180)     mov     X, A                       ; The endpoint number is the index
                                   (1181) 
05ED: 55 1E 00 MOV   [30],0        (1182)     mov     [USB_t2], 0                ; Use the UM temp var--Selector
                                   (1183) 
05F0: 55 0C 00 MOV   [12],0        (1184)     mov     [USB_TransferBuffer + 1], 0    ; Use the UM Transfer Buffer
05F3: 52 04    MOV   A,[X+4]       (1185)     mov     A, [X + USB_EndpointStatus]    ; Get the status
05F5: 53 0B    MOV   [11],A        (1186)     mov     [USB_TransferBuffer], A    ; Save it in the report
                                   (1187) 
05F7: 50 03    MOV   A,3           (1188)     mov     A, >GetStatusTransferDescrTable    ; Get the ROM Address MSB
05F9: 57 C8    MOV   X,200         (1189)     mov     X, <GetStatusTransferDescrTable    ; Get the ROM Address LSB
                                   (1190) 
05FB: 8E CC    JMP   0x04C8        (1191)     jmp     USB_GetTableEntry_Local_Std
                                   (1192) ELSE
                                   (1193) IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
                                   (1194) export  USB_CB_d2h_std_ep_00
                                   (1195) USB_CB_d2h_std_ep_00:
                                   (1196)     ljmp    APP_USB_CB_d2h_std_ep_00
                                   (1197) ENDIF
                                   (1198) ENDIF
                                   (1199) 
                                   (1200) ;-----------------------------------------------------------------------------
                                   (1201) ;  FUNCTION NAME: USB_CB_h2d_std_ep_01
                                   (1202) ;
                                   (1203) ;  DESCRIPTION:   Clear Endpoint Feature
                                   (1204) ;
                                   (1205) ;****************************************************************
                                   (1206) ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                                   (1207) ;****************************************************************
                                   (1208) ;
                                   (1209) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                   (1210) ; bRequest       : CLEAR_FEATURE                  = 01h
                                   (1211) ; wValue         : FEATURE_SELECTOR               = --xxh
                                   (1212) ; wIndex         : ENDPOINT                       = 00xxh
                                   (1213) ; wLength        : RESERVED                       = 0000h
                                   (1214) ;
                                   (1215) ; The CLEAR_ENDPOINT_FEATURE request disables a particular
                                   (1216) ; feature for an endpoint.
                                   (1217) ;
                                   (1218) ; The only feature supported for an endpoint is the EP_HALT
                                   (1219) ; feature.
                                   (1220) ;
                                   (1221) ;****************************************************************
                                   (1222) ;-----------------------------------------------------------------------------
                                   (1223) ;
                                   (1224) ;  ARGUMENTS:
                                   (1225) ;
                                   (1226) ;  RETURNS:
                                   (1227) ;
                                   (1228) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (1229) ;
                                   (1230) ;  THEORY of OPERATION or PROCEDURE:
                                   (1231) ;
                                   (1232) ;-----------------------------------------------------------------------------
                                   (1233) IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                                   (1234) export  USB_CB_h2d_std_ep_01
                                   (1235) USB_CB_h2d_std_ep_01:
05FD: 5D 5A    MOV   A,REG[90]     (1236)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the feature selector
05FF: 39 00    CMP   A,0           (1237)     cmp     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0601: BD BF    JNZ   0x03C1        (1238)     jnz     USB_Not_Supported
                                   (1239) 
0603: 5D 5C    MOV   A,REG[92]     (1240)     mov     A, reg[USB_EP0DATA+wIndexLo]    ; Get the Endpoint number
0605: 21 7F    AND   A,127         (1241)     and     A, ~USB_DIR_IN             ; Strip off the direction bit
0607: 39 00    CMP   A,0           (1242)     cmp     A, 0                       ; Since we can't halt the Control Endpoint
0609: A0 24    JZ    0x062E        (1243)     jz      .done
                                   (1244) 
060B: 39 05    CMP   A,5           (1245)     cmp     A, USB_NUM_ENDPOINTS       ; Range check
060D: DD B3    JNC   0x03C1        (1246)     jnc     USB_Not_Supported
                                   (1247) 
060F: 5C       MOV   X,A           (1248)     mov     X, A                       ; Endpoint number is the index
0610: 27 04 FE AND   [X+4],254     (1249)     and     [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear the endpoint halt
                                   (1250) 
0613: F6 32    INDEX 0x0C47        (1251)     index   USB_USB_EP_BIT_LOOKUP	     ; Find bit position for endpoint
0615: 31 FF    XOR   A,255         (1252)     xor     A, FFh
0617: 24 1C    AND   [28],A        (1253)     and     [USB_EPDataToggle], A ; Clear the data toggle for this endpoint
                                   (1254) 
0619: 49 5C 80 TST   REG[92],128   (1255)     tst     reg[USB_EP0DATA+wIndexLo], USB_DIR_IN    ; IN or OUT endpoint?
061C: 71 10    OR    F,16          (1256)     M8C_SetBank1	                      ; For EP1_MODE register
061E: B0 09    JNZ   0x0628        (1257)     jnz     .in
                                   (1258) 
                                   (1259)     ; Mark endpoint as empty so it will be reloaded
0620: 56 21 00 MOV   [X+33],0      (1260)     mov     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING
0623: 63 C3 09 MOV   REG[X+195],9  (1261)     mov     reg[X + USB_EP1MODE - 1], USB_MODE_ACK_OUT    ; ACK the endpoint
0626: 80 07    JMP   0x062E        (1262)     jmp     .done
                                   (1263) .in:
0628: 56 21 01 MOV   [X+33],1      (1264)     mov     [X+USB_EndpointAPIStatus], EVENT_PENDING
062B: 63 C3 0C MOV   REG[X+195],12 (1265)     mov     reg[X + USB_EP1MODE - 1], USB_MODE_NAK_IN    ; NAK the endpoint
                                   (1266) .done:
062E: 70 EF    AND   F,239         (1267) 	M8C_SetBank0
0630: 8E 9A    JMP   0x04CB        (1268)     jmp     USB_NoDataStageControlTransfer_Local_Std
                                   (1269) ELSE
                                   (1270) IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
                                   (1271) export  USB_CB_h2d_std_ep_01
                                   (1272) USB_CB_h2d_std_ep_01:
                                   (1273)     ljmp    APP_USB_CB_h2d_std_ep_01
                                   (1274) ENDIF
                                   (1275) ENDIF
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;  FUNCTION NAME: USB_CB_h2d_std_ep_03
                                   (1278) ;
                                   (1279) ;  DESCRIPTION:   Set Endpoint Feature
                                   (1280) ;
                                   (1281) ;****************************************************************
                                   (1282) ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                                   (1283) ;****************************************************************
                                   (1284) ;
                                   (1285) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                   (1286) ; bRequest       : SET_FEATURE                    = 03h
                                   (1287) ; wValue         : FEATURE_SELECTOR               = --xxh
                                   (1288) ; wIndex         : ENDPOINT                       = 00xxh
                                   (1289) ; wLength        : RESERVED                       = 0000h
                                   (1290) ;
                                   (1291) ; The SET_ENDPOINT_FEATURE request enables a particular feature
                                   (1292) ; for a specific endpoint. The only feature supported for an
                                   (1293) ; endpoint is the EP_HALT feature.
                                   (1294) ;
                                   (1295) ;****************************************************************
                                   (1296) ;-----------------------------------------------------------------------------
                                   (1297) ;
                                   (1298) ;  ARGUMENTS:
                                   (1299) ;
                                   (1300) ;  RETURNS:
                                   (1301) ;
                                   (1302) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (1303) ;
                                   (1304) ;  THEORY of OPERATION or PROCEDURE:
                                   (1305) ;
                                   (1306) ;-----------------------------------------------------------------------------
                                   (1307) IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                                   (1308) export  USB_CB_h2d_std_ep_03
                                   (1309) USB_CB_h2d_std_ep_03:
0632: 5D 5A    MOV   A,REG[90]     (1310)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the feature selector
0634: 39 00    CMP   A,0           (1311)     cmp     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0636: BD 8A    JNZ   0x03C1        (1312)     jnz     USB_Not_Supported
                                   (1313) 
0638: 5D 5C    MOV   A,REG[92]     (1314)     mov     A, reg[USB_EP0DATA+wIndexLo]    ; Get the Endpoint number
063A: 21 7F    AND   A,127         (1315)     and     A, ~USB_DIR_IN             ; Strip off the direction bit
063C: 39 00    CMP   A,0           (1316)     cmp     A, 0                       ; Never halt the Control Endpoint
063E: A0 1B    JZ    0x065A        (1317)     jz      .done
                                   (1318) 
0640: 39 05    CMP   A,5           (1319)     cmp     A, USB_NUM_ENDPOINTS       ; Range check
0642: DD 7E    JNC   0x03C1        (1320)     jnc     USB_Not_Supported
                                   (1321) 
0644: 5C       MOV   X,A           (1322)     mov     X, A                       ; Endpoint number is the index
                                   (1323) 
0645: 2F 04 01 OR    [X+4],1       (1324)     or      [X+USB_EndpointStatus], USB_ENDPOINT_STATUS_HALT    ; Halt the endpoint
0648: 56 21 02 MOV   [X+33],2      (1325)     mov     [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED
                                   (1326) 
064B: 49 5C 80 TST   REG[92],128   (1327)     tst     reg[USB_EP0DATA+wIndexLo], USB_DIR_IN    ; IN or OUT endpoint?
064E: 71 10    OR    F,16          (1328)     M8C_SetBank1	                      ; For EP1_MODE register
0650: B0 06    JNZ   0x0657        (1329)     jnz     .in
                                   (1330) 
0652: 63 C3 89 MOV   REG[X+195],137(1331)     mov     reg[X + USB_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT    ; Stall the endpoint
0655: 80 04    JMP   0x065A        (1332)     jmp     .done
                                   (1333) .in:
0657: 63 C3 8D MOV   REG[X+195],141(1334)     mov     reg[X + USB_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN    ; Stall the endpoint
                                   (1335) .done:
065A: 70 EF    AND   F,239         (1336) 	M8C_SetBank0
065C: 8E 6E    JMP   0x04CB        (1337)     jmp     USB_NoDataStageControlTransfer_Local_Std
                                   (1338) ELSE
                                   (1339) IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
                                   (1340) export  USB_CB_h2d_std_ep_03
                                   (1341) USB_CB_h2d_std_ep_03:
                                   (1342)     ljmp    APP_USB_CB_h2d_std_ep_03
                                   (1343) ENDIF
                                   (1344) ENDIF
                                   (1345) ;-----------------------------------------------------------------------------
                                   (1346) ;  FUNCTION NAME: ConfigureEP
                                   (1347) ;
                                   (1348) ;  DESCRIPTION:   Configure an endpoint
                                   (1349) ;
                                   (1350) ;  ARGUMENTS:    A contains the endpoint direction
                                   (1351) ;                X contains the endpoint number
                                   (1352) ;
                                   (1353) ;  RETURNS:
                                   (1354) ;
                                   (1355) ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                                   (1356) ;
                                   (1357) ;  THEORY of OPERATION or PROCEDURE:
                                   (1358) ;
                                   (1359) ;-----------------------------------------------------------------------------
                                   (1360) ConfigureEP:
065E: 39 7F    CMP   A,127         (1361)     cmp     A, USB_DIR_UNUSED          ; Is this endpoint unused?
0660: B0 02    JNZ   0x0663        (1362)     jnz     .enable                    ; Only enable it if it is used
0662: 7F       RET                 (1363)     ret                                ; Quick exit if this endpoint is unused
                                   (1364) 
                                   (1365) ; Jump here to enable an endpoint
                                   (1366) .enable:
0663: 08       PUSH  A             (1367)     push    A		                        ; Save the endpoint direction
0664: 5B       MOV   A,X           (1368)     mov     A, X	                      ; We are using a jacc to dispatch to enable the interrupt
0665: 64       ASL   A             (1369)     asl     A		                        ;
0666: E0 01    JACC  0x0668        (1370)     jacc    .EP_INT_ENABLE             ;
                                   (1371) 
                                   (1372) 
                                   (1373) .LITERAL
                                   (1374) .EP_INT_ENABLE:
0668: 80 09    JMP   0x0672        (1375)     jmp     .EP0IntEnable              ; Enable EP0
066A: 80 0C    JMP   0x0677        (1376)     jmp     .EP1IntEnable              ; Enable EP1
066C: 80 0F    JMP   0x067C        (1377)     jmp     .EP2IntEnable              ; Enable EP2
066E: 80 12    JMP   0x0681        (1378)     jmp     .EP3IntEnable              ; Enable EP3
0670: 80 15    JMP   0x0686        (1379)     jmp     .EP4IntEnable              ; Enable EP4
                                   (1380) .ENDLITERAL
                                   (1381) 
                                   (1382) ; Jump here to enable EP0 Interrupts
                                   (1383) .EP0IntEnable:
0672: 43 DF 04 OR    REG[223],4    (1384)     M8C_EnableIntMask USB_INT_REG, USB_INT_EP0_MASK
                                   (1385) ;    jmp   .exit2
0675: 80 15    JMP   0x068B        (1386)     jmp     .cont
                                   (1387) .EP1IntEnable:
0677: 43 DF 08 OR    REG[223],8    (1388)     M8C_EnableIntMask USB_INT_REG, USB_INT_EP1_MASK
067A: 80 10    JMP   0x068B        (1389)     jmp     .cont
                                   (1390) .EP2IntEnable:
067C: 43 DF 10 OR    REG[223],16   (1391)     M8C_EnableIntMask USB_INT_REG, USB_INT_EP2_MASK
067F: 80 0B    JMP   0x068B        (1392)     jmp     .cont
                                   (1393) .EP3IntEnable:
0681: 43 DF 20 OR    REG[223],32   (1394)     M8C_EnableIntMask USB_INT_REG, USB_INT_EP3_MASK
0684: 80 06    JMP   0x068B        (1395)     jmp     .cont
                                   (1396) .EP4IntEnable:
0686: 43 DF 40 OR    REG[223],64   (1397)     M8C_EnableIntMask USB_INT_REG, USB_INT_EP4_MASK
0689: 80 01    JMP   0x068B        (1398) 	jmp     .cont
                                   (1399) 
                                   (1400) ; Jump or flow here to continue configuring the endpoint
                                   (1401) ;.contEP0:
                                   (1402) ;    pop   A                           ; Get the endpoint direction back
                                   (1403) ;    and   A, USB_DIR_IN               ; Is it an IN endpoint?
                                   (1404) ;    jnz   .inEP0                      ; Jump on IN
                                   (1405) ; Flow here for an OUT Endpoint
                                   (1406) ;    mov   [USB_TempMode], USB_MODE_NAK_OUT   ; NAK the endpoint
                                   (1407) ;    jmp   .exit2
                                   (1408) ; Jump here for an IN Endpoint
                                   (1409) ;.inEP0:
                                   (1410) ;    mov   [USB_TempMode], USB_MODE_NAK_IN   ; NAK the endpoint
                                   (1411) ;	jmp   .exit2
                                   (1412) .cont:
068B: 5B       MOV   A,X           (1413)     mov     A, X	                      ; Get the endpoint number from X
068C: F5 B9    INDEX 0x0C47        (1414)     index   USB_USB_EP_BIT_LOOKUP	     ; Find bit position for endpoint
068E: 31 FF    XOR   A,255         (1415)     xor     A, FFh
0690: 24 1C    AND   [28],A        (1416)     and     [USB_EPDataToggle], A ; Clear the data toggle for this endpoint
                                   (1417) 
0692: 27 04 FE AND   [X+4],254     (1418)     and     [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear any endpoint halts
                                   (1419) 
                                   (1420) ; if endpoint 0 set EP0MODE
                                   (1421) ; then exit
                                   (1422) ;    mov     A, X	                     ; Get the endpoint number from X
                                   (1423) ;    cmp     A, EP0	                   ; Is this endpoint zero?
                                   (1424) ;    jnz     .enable                   ; Only enable it if it is used
                                   (1425) 
0695: 71 10    OR    F,16          (1426)     M8C_SetBank1
0697: 18       POP   A             (1427)     pop     A                          ; Get the endpoint direction back
0698: 21 80    AND   A,128         (1428)     and     A, USB_DIR_IN              ; Is it an IN endpoint?
069A: B0 09    JNZ   0x06A4        (1429)     jnz     .in                        ; Jump on IN
                                   (1430) ; Flow here for an OUT Endpoint
069C: 63 C3 09 MOV   REG[X+195],9  (1431)     mov     reg[X+USB_EP1MODE-1], USB_MODE_ACK_OUT   ; ACK the endpoint
069F: 56 21 00 MOV   [X+33],0      (1432)     mov     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING   ; For the API
06A2: 80 07    JMP   0x06AA        (1433)     jmp     .exit1
                                   (1434) ; Jump here for an IN Endpoint
                                   (1435) .in:
06A4: 63 C3 0C MOV   REG[X+195],12 (1436)     mov     reg[X+USB_EP1MODE-1], USB_MODE_NAK_IN   ; NAK the endpoint
06A7: 56 21 01 MOV   [X+33],1      (1437)     mov     [X+USB_EndpointAPIStatus], EVENT_PENDING   ; For the API
                                   (1438) ; Jump or flow here to set the API event and exit
                                   (1439) .exit1:
06AA: 70 EF    AND   F,239         (1440) 	M8C_SetBank0
                                   (1441) .exit2:
                                   (1442) ;    mov   [X+USB_EPDataToggle], 0      ; Clear all EP data toggles?  Is this right?
06AC: 7F       RET                 (1443)     ret

FILE: lib\usb_drv.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USB_drv.asm
                                   (0004) ;;  Version: 1.3, Updated on 2007/09/28 at 14:23:41
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USB Device User Module control endpoint driver
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2005. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "USB_macros.inc"
                                   (0026) include "USB.inc"
                                   (0027) 
                                   (0028) ;-----------------------------------------------
                                   (0029) ;  Global Symbols
                                   (0030) ;-----------------------------------------------
                                   (0031) export  USB_EP0_ISR
                                   (0032) export _USB_EP0_ISR
                                   (0033) export  USB_InitControlRead
                                   (0034) export _USB_InitControlRead
                                   (0035) export  USB_InitControlWrite
                                   (0036) export _USB_InitControlWrite
                                   (0037) export  USB_InitNoDataStageControlTransfer
                                   (0038) export _USB_InitNoDataStageControlTransfer
                                   (0039) export  USB_NoDataStageControlTransfer
                                   (0040) 
                                   (0041) ;-----------------------------------------------
                                   (0042) ;  Macro Definitions
                                   (0043) ;-----------------------------------------------
                                   (0044) 
                                   (0045) ;-----------------------------------------------
                                   (0046) ;  Constant Definitions
                                   (0047) ;-----------------------------------------------
                                   (0048) 
                                   (0049) ;-----------------------------------------------
                                   (0050) ; Variable Allocation
                                   (0051) ;-----------------------------------------------
                                   (0052) AREA InterruptRAM (RAM, REL, CON)
                                   (0053) ;----------------------------------------------------------------------------
                                   (0054) ; Current Device
                                   (0055) ;----------------------------------------------------------------------------
                                   (0056) export USB_bCurrentDevice, _USB_bCurrentDevice
                                   (0057)  USB_bCurrentDevice:
                                   (0058) _USB_bCurrentDevice:                    BLK   1    ;  Current Device
                                   (0059) ;----------------------------------------------------------------------------
                                   (0060) ; Current Configuration
                                   (0061) ;----------------------------------------------------------------------------
                                   (0062) export USB_Configuration, _USB_Configuration
                                   (0063)  USB_Configuration:
                                   (0064) _USB_Configuration:                     BLK   1    ;  Current Configuration
                                   (0065) ;----------------------------------------------------------------------------
                                   (0066) ; Current Device Status
                                   (0067) ;----------------------------------------------------------------------------
                                   (0068) export USB_DeviceStatus, _USB_DeviceStatus
                                   (0069)  USB_DeviceStatus:
                                   (0070) _USB_DeviceStatus:                      BLK   1    ;  Current Device Status
                                   (0071) ;----------------------------------------------------------------------------
                                   (0072) ; Interface Setting
                                   (0073) ;----------------------------------------------------------------------------
                                   (0074) ;  User Module Parameter determines the number of interfaces
                                   (0075) export USB_InterfaceSetting, _USB_InterfaceSetting
                                   (0076)  USB_InterfaceSetting:
                                   (0077) _USB_InterfaceSetting:                  BLK   1h    ; Interface Setting
                                   (0078) ;----------------------------------------------------------------------------
                                   (0079) ; Endpoint Status--USB Status
                                   (0080) ;----------------------------------------------------------------------------
                                   (0081) export USB_EndpointStatus, _USB_EndpointStatus
                                   (0082)  USB_EndpointStatus:
                                   (0083) _USB_EndpointStatus:                    BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                   (0084) ;----------------------------------------------------------------------------
                                   (0085) ; Last Packet Size
                                   (0086) ;----------------------------------------------------------------------------
                                   (0087) export USB_LastSize
                                   (0088)  USB_LastSize:                          BLK   1    ; Last Packet Size
                                   (0089) ;----------------------------------------------------------------------------
                                   (0090) ; Control Transfer State Machine
                                   (0091) ; State values for Control Write
                                   (0092) ; State values for Control Read
                                   (0093) ;----------------------------------------------------------------------------
                                   (0094) export USB_TransferType
                                   (0095)  USB_TransferType:                      BLK   1    ; Control Transfer State Machine
                                   (0096) ;----------------------------------------------------------------------------
                                   (0097) ; Control Transfer Intermediate Buffer--Shared among the requests
                                   (0098) ;----------------------------------------------------------------------------
                                   (0099) export USB_TransferBuffer
                                   (0100)  USB_TransferBuffer:                    BLK   8
                                   (0101) ;----------------------------------------------------------------------------
                                   (0102) ; Transfer Descriptor Data for Control Transfer
                                   (0103) ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
                                   (0104) ;----------------------------------------------------------------------------
                                   (0105) ; Control Transfer Data Source
                                   (0106) ;   USB_DS_ROM
                                   (0107) ;   USB_DS_RAM
                                   (0108) ;   USB_DS_RAM_AS_NEEDED
                                   (0109) ;----------------------------------------------------------------------------
                                   (0110) export USB_CurrentTD, _USB_CurrentTD
                                   (0111) _USB_CurrentTD:
                                   (0112)  USB_CurrentTD:
                                   (0113) export USB_DataSource, _USB_DataSource
                                   (0114) _USB_DataSource:
                                   (0115)  USB_DataSource:                        BLK   1
                                   (0116) ;----------------------------------------------------------------------------
                                   (0117) ; Control Transfer Data Size
                                   (0118) ;----------------------------------------------------------------------------
                                   (0119) export USB_TransferSize, _USB_TransferSize
                                   (0120) _USB_TransferSize:
                                   (0121)  USB_TransferSize:                      BLK   2
                                   (0122) ;----------------------------------------------------------------------------
                                   (0123) ; Control Transfer Data Pointer
                                   (0124) ;   Source for Control Read
                                   (0125) ;   Destination for Control Write
                                   (0126) ;----------------------------------------------------------------------------
                                   (0127) export USB_DataPtr, _USB_DataPtr
                                   (0128) _USB_DataPtr:
                                   (0129)  USB_DataPtr:                           BLK   2
                                   (0130) ;----------------------------------------------------------------------------
                                   (0131) ; Transfer Completion Notification
                                   (0132) ;----------------------------------------------------------------------------
                                   (0133) export USB_StatusBlockPtr, _USB_StatusBlockPtr
                                   (0134) _USB_StatusBlockPtr:
                                   (0135)  USB_StatusBlockPtr:                    BLK   2
                                   (0136) 
                                   (0137) ;----------------------------------------------------------------------------
                                   (0138) ; Control Transfer _TransferByteCount (Actually transfered
                                   (0139) ;----------------------------------------------------------------------------
                                   (0140)  USB_TransferByteCount:                 BLK   2
                                   (0141) 
                                   (0142) ;----------------------------------------------------------------------------
                                   (0143) ; Control Endpoint Data toggle / krypton uses this ONLY for EP0  
                                   (0144) ; For 20x6x devices: See USB_EPXDataToggle defined in usb.asm
                                   (0145) export USB_EPDataToggle, _USB_EPDataToggle
                                   (0146)  _USB_EPDataToggle:
                                   (0147)  USB_EPDataToggle:
                                   (0148)  USB_EP0DataToggle:                     BLK   1
                                   (0149) ;----------------------------------------------------------------------------
                                   (0150) ; Control Endpoint Data Pending Flag
                                   (0151) export USB_fDataPending
                                   (0152)  USB_fDataPending:                      BLK   1
                                   (0153) ;----------------------------------------------------------------------------
                                   (0154) ; Control Endpoint Data Pending Flag
                                   (0155) ;export USB_PendingData
                                   (0156) ; USB_PendingData:                      BLK   1
                                   (0157) ;----------------------------------------------------------------------------
                                   (0158) ; Temporary Data registers
                                   (0159) export USB_t2, USB_t1, USB_t0
                                   (0160)  USB_t2:                                BLK   1    ; Temporary shared by the UM
                                   (0161)  USB_t1:                                BLK   1    ; Temporary shared by the UM
                                   (0162)  USB_t0:                                BLK   1    ; Temporary shared by the UM
                                   (0163) 
                                   (0164) ;export USB_IntState
                                   (0165) ; USB_IntState:                         BLK  1
                                   (0166) ;export USB_StackPointer
                                   (0167) ; USB_StackPointer:                     BLK  1
                                   (0168) ;export USB_TempMode
                                   (0169) ; USB_TempMode:                         BLK 1
                                   (0170) ;----------------------------------------------------------------------------
                                   (0171) ; Endpoint Transfer--API Status
                                   (0172) ;----------------------------------------------------------------------------
                                   (0173) export USB_EndpointAPIStatus, _USB_EndpointAPIStatus
                                   (0174)  USB_EndpointAPIStatus:
                                   (0175) _USB_EndpointAPIStatus:                 BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                   (0176) 
                                   (0177) IF 1
                                   (0178) ELSE
                                   (0179) ERROR_RUN_USB_WIZARD
                                   (0180) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0181) ; In order for the USB User Module to compile properly the USB Wizard must be run.
                                   (0182) ; To do this navigate back to the Device Editor Window, right click on the icon for the
                                   (0183) ; USB User Module and select the 'USB Setup Wizard...'.  Configure the device as needed
                                   (0184) ; and then click OK.  Re-generate source before compiling again.
                                   (0185) ; For HID devices it is important that all instances of HID Class Descriptors point to a valid
                                   (0186) ; HID report.
                                   (0187) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0188) ENDIF
                                   (0189) 
                                   (0190) AREA UserModules (ROM, REL)
                                   (0191) ;-----------------------------------------------------------------------------
                                   (0192) ;  FUNCTION NAME: USB_EP0_ISR
                                   (0193) 
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                                   (0196) ;                 dispaches all SETUP, IN, and OUT transfers to the proper
                                   (0197) ;                 dispatch routines for all supported USB requests.
                                   (0198) ;
                                   (0199) ;-----------------------------------------------------------------------------
                                   (0200) ;
                                   (0201) ;  ARGUMENTS:   n/a
                                   (0202) ;
                                   (0203) ;  RETURNS:     n/a
                                   (0204) ;
                                   (0205) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0206) ;
                                   (0207) ;  THEORY of OPERATION or PROCEDURE:
                                   (0208) ;
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210)  USB_EP0_ISR:
                                   (0211) _USB_EP0_ISR:
06AD: 08       PUSH  A             (0212)     push    A
06AE: 10       PUSH  X             (0213)     push    X
06AF: 5D D5    MOV   A,REG[213]
06B1: 08       PUSH  A             (0214)     REG_PRESERVE MVW_PP
06B2: 5D D4    MOV   A,REG[212]
06B4: 08       PUSH  A             (0215)     REG_PRESERVE MVR_PP
                                   (0216) 
06B5: 62 D5 00 MOV   REG[213],0    (0217)     RAM_SETPAGE_MVW 0
06B8: 62 D4 00 MOV   REG[212],0    (0218)     RAM_SETPAGE_MVR 0
                                   (0219) 
                                   (0220)     ; Dispatch to setup/in/out handlers
06BB: 5D 56    MOV   A,REG[86]     (0221)     mov     A, reg[USB_EP0MODE]         ; Get the mode reg
                                   (0222) 
                                   (0223)  ;   mov  [USB_TempMode], USB_MODE_NAK_IN_OUT
                                   (0224)  ;   mov  reg[USB_EP0MODE], USB_MODE_NAK_IN_OUT
                                   (0225)     ; MSB is the SETUP bit, followed by IN, then OUT
06BD: 64       ASL   A             (0226)     asl     A                           ; Shift to the carry and jump if SETUP bit set
06BE: C0 17    JC    0x06D6        (0227)     jc      USB_EP0_Setup
                                   (0228) 
06C0: 64       ASL   A             (0229)     asl     A                           ; Shift to the carry and jump if IN bit set
06C1: C0 34    JC    0x06F6        (0230)     jc      USB_EP0_IN
                                   (0231) 
06C3: 64       ASL   A             (0232)     asl     A                           ; Shift to the carry and jump if OUT bit set
06C4: C0 3D    JC    0x0702        (0233)     jc      USB_EP0_OUT
                                   (0234) 
06C6: 82 73    JMP   0x093A        (0235)     jmp     USB_Not_Supported_Local_Drv
                                   (0236) 
                                   (0237) ; ISR Exit Point to update the mode register
                                   (0238) ;   mode and count have been pushed onto the stack
                                   (0239) export USB_EP0_UPD_MODE_EXIT
                                   (0240) USB_EP0_UPD_MODE_EXIT:
                                   (0241) 
06C8: 60 57    MOV   REG[87],A     (0242)     mov     reg[USB_EP0CNT], A         ; Update the count
06CA: 5B       MOV   A,X           (0243)     mov     A, X                       ; Get the new mode
06CB: 60 56    MOV   REG[86],A     (0244)     mov     reg[USB_EP0MODE], A        ; Update the node
06CD: 18       POP   A
                                   (0245) 
                                   (0246) ; Common Exit Point
                                   (0247) USB_EP0_ISR_EXIT:
06CE: 60 D4    MOV   REG[212],A    (0248)     REG_RESTORE MVR_PP
06D0: 18       POP   A
06D1: 60 D5    MOV   REG[213],A    (0249)     REG_RESTORE MVW_PP
06D3: 20       POP   X             (0250)     pop     X                           ;
                                   (0251) ;       mov  A, [USB_TempMode]
                                   (0252) ;       mov  reg[USB_EP0MODE], A
06D4: 18       POP   A             (0253)     pop     A                           ; Restore Context
06D5: 7E       RETI                (0254)     reti
                                   (0255) 
                                   (0256) 
                                   (0257) ;-----------------------------------------------------------------------------
                                   (0258) ;  FUNCTION NAME: USB_EP0_Setup
                                   (0259) ;
                                   (0260) ;  DESCRIPTION:   Dispatch a USB SETUP
                                   (0261) ;
                                   (0262) ;-----------------------------------------------------------------------------
                                   (0263)  USB_EP0_Setup:
                                   (0264) _USB_EP0_Setup:
                                   (0265) ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
06D6: 08       PUSH  A             (0266)     push    A                          ; Save the mode register
06D7: 50 02    MOV   A,2           (0267)     mov     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
06D9: 91 EF    CALL  0x08CA        (0268)     call    USB_UpdateStatusBlock
06DB: 18       POP   A             (0269)     pop     A                          ; Restore the mode register
06DC: 5D 57    MOV   A,REG[87]     (0270)     mov     A, reg[USB_EP0CNT]               ; Get the count reg
06DE: 39 4A    CMP   A,74          (0271)     cmp     A, (USB_CNT_VALID | 0x0A)
06E0: A0 03    JZ    0x06E4        (0272)     jz      .dispatch
                                   (0273) 
06E2: 82 57    JMP   0x093A        (0274)     jmp     USB_Not_Supported_Local_Drv
                                   (0275) 
                                   (0276) 
                                   (0277) ;-----------------------------------------------------------------------------
                                   (0278) ; Jump here to dispatch the request
                                   (0279) ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
                                   (0280) ; 7, 6, 5, 1, 0 determine what the request is. Bits [2:4] are default to zero. The below code
                                   (0281) ; re-organizes [bmRequestType] to the following format:
                                   (0282) ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
                                   (0283) ; "re-organization", the firmware will jump to an appropriate table to handle the request.
                                   (0284) ;-----------------------------------------------------------------------------
                                   (0285) .dispatch:
06E4: 5D 58    MOV   A,REG[88]     (0286)     mov     A, reg[USB_EP0DATA+bmRequestType]   ; Get bmRequestType
06E6: 21 E3    AND   A,227         (0287)     and     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
06E8: 08       PUSH  A             (0288)     push    A                                ; store value on the stack
06E9: 67       ASR   A             (0289)     asr     A                                ; move bits 7-6-5 into 4-3-2's place
06EA: 67       ASR   A             (0290)     asr     A                                ; "asr" instruction shift all bits one place to the right.
06EB: 67       ASR   A             (0291)     asr     A                                ; Bit7 remains the same.
06EC: 53 1E    MOV   [30],A        (0292)     mov     [USB_t2], A                      ; store shifted value
06EE: 18       POP   A             (0293)     pop     A                                ; get original value
06EF: 2A 1E    OR    A,[30]        (0294)     or      A, [USB_t2]                      ; or the two to get the 5-bit field
06F1: 21 1F    AND   A,31          (0295)     and     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                   (0296)                                              ; Bit0 is loaded with a Zero. This results in multiplying
                                   (0297)                                              ; the accumulator by 2, and the reason to mutiply it by 2
                                   (0298)                                              ; is that each "jmp" instruction in the tables is two bytes long.
                                   (0299) 
06F3: 7D 09 31 LJMP  0x0931        (0300)     ljmp    USB_bmRequestType_Dispatch
                                   (0301) 
                                   (0302) 
                                   (0303) ;-----------------------------------------------------------------------------
                                   (0304) ;  FUNCTION NAME: USB_EP0_IN
                                   (0305) ;
                                   (0306) ;  DESCRIPTION: Handles an IN request.  Depending on the state of the
                                   (0307) ;               enumeration sequence it decides what to do next
                                   (0308) ;
                                   (0309) ;-----------------------------------------------------------------------------
                                   (0310)  USB_EP0_IN:
                                   (0311) _USB_EP0_IN:
                                   (0312) 
06F6: 51 0A    MOV   A,[10]        (0313)     mov     A, [USB_TransferType]
                                   (0314) ;    call USB_ControlInDispatch
                                   (0315) ;    jmp  USB_EP0_ISR_EXIT                   ; And exit
                                   (0316) USB_ControlInDispatch:
06F8: E0 01    JACC  0x06FA        (0317)     jacc    USB_ControlInDispatchTable
                                   (0318) .LITERAL
                                   (0319) USB_ControlInDispatchTable:
06FA: 82 3F    JMP   0x093A        (0320)     jmp     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
06FC: 80 37    JMP   0x0734        (0321)     jmp     USB_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
06FE: 80 B7    JMP   0x07B6        (0322)     jmp     USB_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
0700: 80 C2    JMP   0x07C3        (0323)     jmp     USB_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0324) .ENDLITERAL
                                   (0325) 
                                   (0326) 
                                   (0327) ;-----------------------------------------------------------------------------
                                   (0328) ;  FUNCTION NAME: USB_EP0_OUT
                                   (0329) ;
                                   (0330) ;  DESCRIPTION: HANDles an OUT request.  Depending on the state of the
                                   (0331) ;               enumeration sequence it decides what to do next
                                   (0332) ;
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334)  USB_EP0_OUT:
                                   (0335) _USB_EP0_OUT:
0702: 51 0A    MOV   A,[10]        (0336)     mov     A, [USB_TransferType]
0704: E0 01    JACC  0x0706        (0337)     jacc    USB_ControlOutDispatchTable
                                   (0338) .LITERAL
                                   (0339) USB_ControlOutDispatchTable:
0706: 82 33    JMP   0x093A        (0340)     jmp     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
0708: 80 2D    JMP   0x0736        (0341)     jmp     USB_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
070A: 80 5E    JMP   0x0769        (0342)     jmp     USB_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
070C: 80 D0    JMP   0x07DD        (0343)     jmp     USB_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0344) .ENDLITERAL
                                   (0345) 
                                   (0346) 
                                   (0347) ;-----------------------------------------------------------------------------
                                   (0348) ;  FUNCTION NAME: USB_InitControlRead
                                   (0349) ;
                                   (0350) ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
                                   (0351) ;                 not called.  It assumes a tranfer descriptor has been loaded
                                   (0352) ;                 into the driver USB_CurrentTD data structure.
                                   (0353) ;
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355)  USB_InitControlRead:
                                   (0356) _USB_InitControlRead:
070E: 53 09    MOV   [9],A         (0357)     mov     [USB_LastSize], A          ; Save the packet size?
0710: 91 CE    CALL  0x08E0        (0358)     call    USB_InitializeStatusBlock
0712: 55 0A 02 MOV   [10],2        (0359)     mov     [USB_TransferType], USB_TRANS_STATE_CONTROL_READ
                                   (0360) 
                                   (0361)     ; Check the transfer size against the request size
0715: 5D 5F    MOV   A,REG[95]     (0362)     mov     A, reg[USB_EP0DATA+wLengthHi]   ; MSB of wLength
0717: 3A 14    CMP   A,[20]        (0363)     cmp     A, [USB_TransferSize]
0719: B0 07    JNZ   0x0721        (0364)     jnz     .L1
                                   (0365) 
071B: 5D 5E    MOV   A,REG[94]     (0366)     mov     A, reg[USB_EP0DATA+wLengthLo]   ; LSB of wLength
071D: 3A 15    CMP   A,[21]        (0367)     cmp     A, [USB_TransferSize+1]
071F: A0 09    JZ    0x0729        (0368)     jz      .L9
                                   (0369) .L1:
0721: D0 07    JNC   0x0729        (0370)     jnc     .L9
                                   (0371) ;
0723: 53 15    MOV   [21],A        (0372)     mov    [USB_TransferSize+1], A     ;
0725: 5D 5F    MOV   A,REG[95]     (0373)     mov    A, reg[USB_EP0DATA+wLengthHi]   ;
0727: 53 14    MOV   [20],A        (0374)     mov    [USB_TransferSize], A       ;
                                   (0375) .L9:
0729: 55 1A 00 MOV   [26],0        (0376)     mov    [USB_TransferByteCount], 0  ;
072C: 55 1B 00 MOV   [27],0        (0377)     mov    [USB_TransferByteCount+1], 0   ;
                                   (0378) 
072F: 2E 1C 01 OR    [28],1        (0379)     or     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
0732: 80 B4    JMP   0x07E7        (0380)     jmp    USB_LoadEndpoint            ;
                                   (0381) ;-----------------------------------------------------------------------------
                                   (0382) ;  FUNCTION NAME: USB_ControlReadDataStage
                                   (0383) ;
                                   (0384) ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
                                   (0385) ;                 must be JUMPed to, not called.  It assumes a tranfer descriptor
                                   (0386) ;                 has been loaded into the driver USB_CurrentTD
                                   (0387) ;                 data structure.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390)  USB_ControlReadDataStage:
0734: 80 B2    JMP   0x07E7        (0391)     jmp     USB_LoadEndpoint
                                   (0392) 
                                   (0393) ;-----------------------------------------------------------------------------
                                   (0394) ;  FUNCTION NAME: USB_ControlReadStatusStage
                                   (0395) ;
                                   (0396) ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
                                   (0397) ;                 must be JUMPed to, not called.  It handles short or 0 packet
                                   (0398) ;                 It assumes a tranfer descriptor has been loaded into the
                                   (0399) ;                 driver USB_CurrentTD data structure.
                                   (0400) ;
                                   (0401) ;-----------------------------------------------------------------------------
                                   (0402)  USB_ControlReadStatusStage:
0736: 51 09    MOV   A,[9]         (0403)     mov    A, [USB_LastSize]           ; Get the number of bytes from the last transfer
0738: 04 1B    ADD   [27],A        (0404)     add    [USB_TransferByteCount + 1], A   ; Update the transfer byte count
073A: 0E 1A 00 ADC   [26],0        (0405)     adc    [USB_TransferByteCount], 0  ;
073D: 50 01    MOV   A,1           (0406)     mov    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
073F: 91 89    CALL  0x08CA        (0407)     call   USB_UpdateStatusBlock
0741: 55 0A 00 MOV   [10],0        (0408)     mov    [USB_TransferType], USB_TRANS_STATE_IDLE
0744: 50 00    MOV   A,0           (0409)     mov    A, 0                        ; Count Register
0746: 57 03    MOV   X,3           (0410)     mov    X, USB_MODE_STALL_IN_OUT
0748: 8F 7F    JMP   0x06C8        (0411)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0412) ;-----------------------------------------------------------------------------
                                   (0413) ;  FUNCTION NAME: USB_NoDataStageControlTransfer
                                   (0414) ;                 USB_InitNoDataStageControlTransfer
                                   (0415) ;
                                   (0416) ;  DESCRIPTION:   This routine processes the status stage of a no data control
                                   (0417) ;                 write.  It must be JUMPed to, not called.
                                   (0418) ;
                                   (0419) ;-----------------------------------------------------------------------------
                                   (0420)  USB_NoDataStageControlTransfer:
                                   (0421) _USB_InitNoDataStageControlTransfer:
                                   (0422)  USB_InitNoDataStageControlTransfer:
074A: 91 94    CALL  0x08E0        (0423)     call    USB_InitializeStatusBlock
                                   (0424) 
074C: 55 0A 06 MOV   [10],6        (0425)     mov    [USB_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0426) 
074F: 50 00    MOV   A,0           (0427)     mov    A, 0                        ; Count Register
0751: 57 06    MOV   X,6           (0428)     mov    X, USB_MODE_STATUS_IN_ONLY
0753: 8F 74    JMP   0x06C8        (0429)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0430) 
                                   (0431) 
                                   (0432) ;-----------------------------------------------------------------------------
                                   (0433) ;  FUNCTION NAME: USB_InitControlWrite
                                   (0434) ;
                                   (0435) ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
                                   (0436) ;                 to, not called.  It assumes a tranfer descriptor has been loaded
                                   (0437) ;                 into the driver USB_CurrentTD data structure.
                                   (0438) ;
                                   (0439) ;-----------------------------------------------------------------------------
                                   (0440)  USB_InitControlWrite:
                                   (0441) _USB_InitControlWrite:
0755: 51 13    MOV   A,[19]        (0442)     mov     A, [USB_DataSource]        ; Need to make sure the destination is not ROM
0757: 39 00    CMP   A,0           (0443)     cmp     A, USB_DS_ROM
0759: A1 E0    JZ    0x093A        (0444)     jz      USB_Not_Supported_Local_Drv
                                   (0445) 
075B: 91 83    CALL  0x08E0        (0446)     call    USB_InitializeStatusBlock
                                   (0447) 
075D: 55 0A 04 MOV   [10],4        (0448)     mov    [USB_TransferType], USB_TRANS_STATE_CONTROL_WRITE
                                   (0449) 
0760: 2E 1C 01 OR    [28],1        (0450)     or     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
                                   (0451) 
0763: 50 00    MOV   A,0           (0452)     mov    A, 0                        ; Count Register
0765: 57 0B    MOV   X,11          (0453)     mov    X, USB_MODE_ACK_OUT_STATUS_IN
0767: 8F 60    JMP   0x06C8        (0454)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0455) 
                                   (0456) 
                                   (0457) ;-----------------------------------------------------------------------------
                                   (0458) ;  FUNCTION NAME: USB_ControlWriteDataStage
                                   (0459) ;
                                   (0460) ;  DESCRIPTION:   This routine processes the data stage of a control
                                   (0461) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0462) ;                 tranfer descriptor has been loaded into the driver
                                   (0463) ;                 USB_CurrentTD data structure.
                                   (0464) ;
                                   (0465) ;-----------------------------------------------------------------------------
                                   (0466)  USB_ControlWriteDataStage:
0769: 36 1C 01 XOR   [28],1        (0467)     xor    [USB_EP0DataToggle], 1      ; Update data toggle
                                   (0468) 
076C: 5D 57    MOV   A,REG[87]     (0469)     mov    A, reg[USB_EP0CNT]          ; Get the count
                                   (0470) 
076E: 21 0F    AND   A,15          (0471)     and     A, 0x0F
0770: 11 02    SUB   A,2           (0472)     sub     A, 2                       ; Count include the two byte checksum
                                   (0473) 
0772: 53 1E    MOV   [30],A        (0474)     mov     [USB_t2], A                ; Assume we have room to receive the whole packet
                                   (0475) 
0774: 50 00    MOV   A,0           (0476)     mov     A, 0
0776: 3A 14    CMP   A,[20]        (0477)     cmp     A, [USB_TransferSize]      ; If the MSB has anything just use the count
0778: B0 07    JNZ   0x0780        (0478)     jnz     .L1
                                   (0479) 
077A: 51 1E    MOV   A,[30]        (0480)     mov     A, [USB_t2]
077C: 3A 15    CMP   A,[21]        (0481)     cmp     A, [USB_TransferSize+1]    ;
077E: A0 06    JZ    0x0785        (0482)     jz      .L6
                                   (0483) .L1:
0780: C0 04    JC    0x0785        (0484)     jc      .L6
0782: 5F 1E 15 MOV   [30],[21]     (0485)     mov     [USB_t2], [USB_TransferSize+1]
                                   (0486) 
                                   (0487) .L6:
0785: 51 1E    MOV   A,[30]        (0488)     mov     A, [USB_t2]
0787: 14 15    SUB   [21],A        (0489)     sub     [USB_TransferSize+1], A    ; Update the bytes remaining
0789: 1E 14 00 SBB   [20],0        (0490)     sbb     [USB_TransferSize], 0      ;
                                   (0491) 
078C: 04 1B    ADD   [27],A        (0492)     add     [USB_TransferByteCount + 1], A   ; Update the transfer byte count
078E: 0E 1A 00 ADC   [26],0        (0493)     adc     [USB_TransferByteCount], 0   ;
                                   (0494) 
0791: 57 00    MOV   X,0           (0495)     mov     X, 0                       ; Start the index at 0
0793: 5D D5    MOV   A,REG[213]
                                   (0496) 
                                   (0497) IF SYSTEM_LARGE_MEMORY_MODEL
0795: 08       PUSH  A             (0498)     REG_PRESERVE MVW_PP
0796: 51 16    MOV   A,[22]        (0499)     mov     A, [USB_DataPtr]  ; set proper page for mvi command
0798: 60 D5    MOV   REG[213],A    (0500)     mov     reg[MVW_PP], A
                                   (0501) ENDIF
                                   (0502) 
                                   (0503) .RAM_COPY:
079A: 5E 58    MOV   A,REG[X+88]   (0504)     mov     A, reg[X+USB_EP0DATA]      ; Get the data
079C: 3F 17    MVI   [23],A        (0505)     mvi     [USB_DataPtr+1], A         ; Store the data, bump the destination
                                   (0506) 
079E: 75       INC   X             (0507)     inc     X                          ; Bump the destination offset
079F: 5B       MOV   A,X           (0508)     mov     A, X                       ; Are we done?
07A0: 3A 1E    CMP   A,[30]        (0509)     cmp     A, [USB_t2]
07A2: CF F7    JC    0x079A        (0510)     jc      .RAM_COPY                  ; Not done
07A4: 18       POP   A
                                   (0511) 
                                   (0512) IF SYSTEM_LARGE_MEMORY_MODEL
07A5: 60 D5    MOV   REG[213],A    (0513)     REG_RESTORE MVW_PP
                                   (0514) ENDIF
                                   (0515) 
07A7: 50 00    MOV   A,0           (0516)     mov    A, 0                        ; Count Register
07A9: 57 0B    MOV   X,11          (0517)     mov    X, USB_MODE_ACK_OUT_STATUS_IN
07AB: 8F 1C    JMP   0x06C8        (0518)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0519) 
                                   (0520) ; Jump here on data toggle error
                                   (0521) .error:
07AD: 55 0A 00 MOV   [10],0        (0522)     mov    [USB_TransferType], USB_TRANS_STATE_IDLE    ; This simply aborts the transfer
07B0: 50 00    MOV   A,0           (0523)     mov    A, 0                        ; Count Register
07B2: 57 03    MOV   X,3           (0524)     mov    X, USB_MODE_STALL_IN_OUT
07B4: 8F 13    JMP   0x06C8        (0525)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0526) 
                                   (0527) 
                                   (0528) ;-----------------------------------------------------------------------------
                                   (0529) ;  FUNCTION NAME: USB_ControlWriteStatusStage
                                   (0530) ;
                                   (0531) ;  DESCRIPTION:   This routine processes the status stage of a control
                                   (0532) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0533) ;                 tranfer descriptor has been loaded into the driver
                                   (0534) ;                 USB_CurrentTD data structure.
                                   (0535) ;
                                   (0536) ;-----------------------------------------------------------------------------
                                   (0537)  USB_ControlWriteStatusStage:
07B6: 50 01    MOV   A,1           (0538)     mov    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
07B8: 91 10    CALL  0x08CA        (0539)     call   USB_UpdateStatusBlock
07BA: 55 0A 00 MOV   [10],0        (0540)     mov    [USB_TransferType], USB_TRANS_STATE_IDLE    ; The packet is done
07BD: 50 00    MOV   A,0           (0541)     mov    A, 0                        ; Count Register
07BF: 57 03    MOV   X,3           (0542)     mov    X, USB_MODE_STALL_IN_OUT
07C1: 8F 06    JMP   0x06C8        (0543)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0544) 
                                   (0545) 
                                   (0546) ;-----------------------------------------------------------------------------
                                   (0547) ;  FUNCTION NAME: USB_NoDataControlStatusStage
                                   (0548) ;
                                   (0549) ;  DESCRIPTION:   This routine processes the status stage of a control
                                   (0550) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0551) ;                 tranfer descriptor has been loaded into the driver
                                   (0552) ;                 USB_CurrentTD data structure.
                                   (0553) ;
                                   (0554) ;                 USB Device Addressing happens here because we can't change
                                   (0555) ;                 the SIE Address before the Status IN is received.
                                   (0556) ;
                                   (0557) ;-----------------------------------------------------------------------------
                                   (0558)  USB_NoDataControlStatusStage:
07C3: 50 01    MOV   A,1           (0559)     mov     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
07C5: 91 03    CALL  0x08CA        (0560)     call    USB_UpdateStatusBlock
                                   (0561)     ; Dispatch to the proper handler
07C7: 3C 1D 01 CMP   [29],1        (0562)     cmp     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING
07CA: B0 09    JNZ   0x07D4        (0563)     jnz     .L1
                                   (0564) 
                                   (0565)     ; USB ADDRESS CHANGE
07CC: 51 0B    MOV   A,[11]        (0566)     mov     A, [USB_TransferBuffer]    ; Get the pending data
                                   (0567) 
07CE: 29 80    OR    A,128         (0568)     or      A, USB_ADDR_ENABLE         ; Set the enable bit
07D0: 60 4A    MOV   REG[74],A     (0569)     mov     reg[USB_ADDR], A           ; Update the SIE address
07D2: 80 01    JMP   0x07D4        (0570)     jmp     .EXIT
                                   (0571) .L1:
                                   (0572) 
                                   (0573) .EXIT:
07D4: 55 1D 00 MOV   [29],0        (0574)     mov     [USB_fDataPending], 0      ; Clear data pending
                                   (0575) 
07D7: 50 00    MOV   A,0           (0576)     mov    A, 0                        ; Count Register
07D9: 57 06    MOV   X,6           (0577)     mov    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
07DB: 8E EC    JMP   0x06C8        (0578)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0579) 
                                   (0580) 
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;  FUNCTION NAME: USB_NoDataControlError
                                   (0583) ;
                                   (0584) ;  DESCRIPTION:   This routine handles the condition when we expected a
                                   (0585) ;                 status IN, but receive an OUT
                                   (0586) ;
                                   (0587) ;-----------------------------------------------------------------------------
                                   (0588)  USB_NoDataControlError:
07DD: 50 03    MOV   A,3           (0589)     mov    A, USB_XFER_ERROR           ; Return Transaction Error
07DF: 90 E9    CALL  0x08CA        (0590)     call   USB_UpdateStatusBlock
07E1: 50 00    MOV   A,0           (0591)     mov    A, 0                        ; Count Register
07E3: 57 03    MOV   X,3           (0592)     mov    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
07E5: 8E E2    JMP   0x06C8        (0593)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0594) 
                                   (0595) 
                                   (0596) ;-----------------------------------------------------------------------------
                                   (0597) ;  FUNCTION NAME: USB_LoadEndpoint
                                   (0598) ;
                                   (0599) ;  DESCRIPTION: Moves data from either RAM or ROM - depending on the request
                                   (0600) ;               type and then places the appropriate number of bytes -
                                   (0601) ;               depending on the request size into the endpoint FIFO.
                                   (0602) ;               It finally sets up the endpoint to send data.
                                   (0603) ;
                                   (0604) USB_LoadEndpoint:
07E7: 51 09    MOV   A,[9]         (0605)     mov     A, [USB_LastSize]          ; Get the number of bytes from the last transfer
07E9: 04 1B    ADD   [27],A        (0606)     add     [USB_TransferByteCount + 1], A   ; Update the transfer byte count
07EB: 0E 1A 00 ADC   [26],0        (0607)     adc     [USB_TransferByteCount], 0   ;
07EE: 51 14    MOV   A,[20]        (0608)     mov     A,  [USB_TransferSize]     ; Check to see if we have any
07F0: 2A 15    OR    A,[21]        (0609)     or      A,  [USB_TransferSize+1]   ;  more data to send
07F2: B0 0E    JNZ   0x0801        (0610)     jnz     .cont                      ; Jump if we have to send more data
                                   (0611) 
                                   (0612) ; Flow here if there is no more data to send
07F4: 3C 09 08 CMP   [9],8         (0613)     cmp     [USB_LastSize], 8          ; Was it a full packet?
07F7: A0 52    JZ    0x084A        (0614)     JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
                                   (0615) 
                                   (0616) ; Flow here if we are entering the status stage
07F9: 50 00    MOV   A,0           (0617)     mov     A, 0                       ; Count Register
07FB: 53 09    MOV   [9],A         (0618)     mov     [USB_LastSize], A          ; Clear the byte count
07FD: 57 02    MOV   X,2           (0619)     mov     X, USB_MODE_STATUS_OUT_ONLY   ; Only ACK the Status Out
07FF: 8E C8    JMP   0x06C8        (0620)     jmp     USB_EP0_UPD_MODE_EXIT
                                   (0621) 
                                   (0622) ; Jump here to determine how many bytes should we transfer
                                   (0623) .cont:
0801: 3C 14 00 CMP   [20],0        (0624)     cmp     [USB_TransferSize], 0      ; Check the MSB
0804: B0 0A    JNZ   0x080F        (0625)     jnz     .L1
                                   (0626) 
0806: 3C 15 08 CMP   [21],8        (0627)     cmp     [USB_TransferSize+1], 8    ; Check the LSB
0809: D0 05    JNC   0x080F        (0628)     jnc     .L1
                                   (0629) 
080B: 51 15    MOV   A,[21]        (0630)     mov     A, [USB_TransferSize+1]    ; Transfer all the remaing data
080D: 80 03    JMP   0x0811        (0631)     jmp     .L3
                                   (0632) 
                                   (0633) .L1:
080F: 50 08    MOV   A,8           (0634)     mov     A, 8                       ; Just transfer the next 8 bytes
                                   (0635) 
                                   (0636) .L3:
                                   (0637) 
0811: 14 15    SUB   [21],A        (0638)     sub     [USB_TransferSize+1], A    ; Update the bytes remaining
0813: 1E 14 00 SBB   [20],0        (0639)     sbb     [USB_TransferSize], 0
0816: 53 1E    MOV   [30],A        (0640)     mov     [USB_t2], A                ; Save the count
0818: 57 00    MOV   X,0           (0641)     mov     X, 0
                                   (0642) 
081A: 3C 13 00 CMP   [19],0        (0643)     cmp     [USB_DataSource], USB_DS_ROM    ; RAM or ROM copy?
081D: B0 17    JNZ   0x0835        (0644)     jnz     .RAM_COPY
                                   (0645) 
                                   (0646) ; Copy data from a ROM source
                                   (0647) .ROM_COPY:
081F: 10       PUSH  X             (0648)     push    X                          ; Save the destination offset
0820: 51 16    MOV   A,[22]        (0649)     mov     A, [USB_DataPtr]           ; Get the transfer source MSB
0822: 58 17    MOV   X,[23]        (0650)     mov     X, [USB_DataPtr+1]         ; Set the transfer source LSB
0824: 76 17    INC   [23]          (0651)     inc     [USB_DataPtr+1]            ; Increment the data pointer
0826: 0E 16 00 ADC   [22],0        (0652)     adc     [USB_DataPtr], 0           ;   MSB if necessary
                                   (0653) 
0829: 28       ROMX                (0654)     romx                               ; Get the data byte
                                   (0655) 
082A: 20       POP   X             (0656)     pop     X                          ; Get the destination offset
082B: 61 58    MOV   REG[X+88],A   (0657)     mov     reg[X + USB_EP0DATA], A    ; Load the data
082D: 75       INC   X             (0658)     inc     X                          ; Bump the destination offset
082E: 5B       MOV   A,X           (0659)     mov     A, X                       ; Are we done?
082F: 3A 1E    CMP   A,[30]        (0660)     cmp     A, [USB_t2]
0831: CF ED    JC    0x081F        (0661)     jc      .ROM_COPY                  ; Not done
0833: 80 16    JMP   0x084A        (0662)     jmp     .START_TRANSFER            ; Otherwise go start the transfer
0835: 5D D4    MOV   A,REG[212]
                                   (0663) 
                                   (0664) ; Copy data from a RAM source
                                   (0665) .RAM_COPY:
                                   (0666) IF SYSTEM_LARGE_MEMORY_MODEL
0837: 08       PUSH  A             (0667)     REG_PRESERVE MVR_PP
0838: 51 16    MOV   A,[22]        (0668)     mov     A, [USB_DataPtr]  ; set proper page for mvi command
083A: 60 D4    MOV   REG[212],A    (0669)     mov     reg[MVR_PP], A
                                   (0670) ENDIF
                                   (0671) .CP1:
083C: 3E 17    MVI   A,[23]        (0672)     mvi     A, [USB_DataPtr+1]         ; Get the data, bump the source
                                   (0673) 
083E: 61 58    MOV   REG[X+88],A   (0674)     mov     reg[X +USB_EP0DATA], A     ; Load the data
0840: 75       INC   X             (0675)     inc     X                          ; Bump the destination offset
0841: 5B       MOV   A,X           (0676)     mov     A, X                       ; Are we done?
0842: 3A 1E    CMP   A,[30]        (0677)     cmp     A, [USB_t2]
0844: CF F7    JC    0x083C        (0678)     jc      .CP1                       ; Not done
0846: 18       POP   A
                                   (0679) 
                                   (0680) IF SYSTEM_LARGE_MEMORY_MODEL
0847: 60 D4    MOV   REG[212],A    (0681)     REG_RESTORE MVR_PP
0849: 5B       MOV   A,X           (0682)     mov     A, X                       ; Restore A
                                   (0683) ENDIF
                                   (0684) 
                                   (0685) ;; Set up the IN transfer count/mode/etc
                                   (0686) ;    A contains the byte count
                                   (0687) .START_TRANSFER:
084A: 53 09    MOV   [9],A         (0688)     mov     [USB_LastSize], A          ; Save the packet size
                                   (0689) 
084C: 50 01    MOV   A,1           (0690)     mov     A, 1
084E: 22 1C    AND   A,[28]        (0691)     and     A, [USB_EP0DataToggle]
0850: A0 03    JZ    0x0854        (0692)     jz      .BYPASS_T1
0852: 50 80    MOV   A,128         (0693)     mov     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
                                   (0694) 
                                   (0695) .BYPASS_T1:
0854: 2A 09    OR    A,[9]         (0696)     or      A, [USB_LastSize]
0856: 36 1C 01 XOR   [28],1        (0697)     xor     [USB_EP0DataToggle], 1     ; Update the data toggle for next time
                                   (0698) 
0859: 57 0F    MOV   X,15          (0699)     mov     X, USB_MODE_ACK_IN_STATUS_OUT    ; Set the mode register
085B: 8E 6C    JMP   0x06C8        (0700)     jmp    USB_EP0_UPD_MODE_EXIT
                                   (0701) 
                                   (0702) 
                                   (0703) ;-----------------------------------------------------------------------------
                                   (0704) ;  FUNCTION NAME: USB_GetTableEntry
                                   (0705) ;
                                   (0706) ;  DESCRIPTION: This function figures out based on the various bytes in the
                                   (0707) ;               setup packet where to get the data from or put the data to.
                                   (0708) ;               Transfer Data structures are defined each of the supported
                                   (0709) ;               control transfers, this function finds the right one and
                                   (0710) ;               saves it in the CurrentTD structure in RAM.  It then
                                   (0711) ;               calls InitControlRead or InitControlWrite to being the
                                   (0712) ;               transaction.
                                   (0713) ;
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) export USB_GetTableEntry
                                   (0716) USB_GetTableEntry:
                                   (0717) 
085D: 75       INC   X             (0718)     inc     X                          ; Point to the first table entry
085E: 09 00    ADC   A,0           (0719)     adc     A, 0                       ;
0860: 08       PUSH  A
                                   (0720) 
0861: 65 1E    ASL   [30]          (0721)     TD_INDEX_TO_OFFSET USB_t2 ; Convert the index
0863: 65 1E    ASL   [30]
0865: 65 1E    ASL   [30]
0867: 18       POP   A
                                   (0722) 
0868: 4B       SWAP  A,X           (0723)     swap    A, X
0869: 02 1E    ADD   A,[30]        (0724)     add     A, [USB_t2]
086B: 4B       SWAP  A,X           (0725)     swap    A, X
086C: 09 00    ADC   A,0           (0726)     adc     A, 0                       ; A:X now points to the descriptor table entry we want
                                   (0727) 
                                   (0728) ; Flow here to load the Transfer Descriptor (TD_ENTRY)
086E: 55 1E 13 MOV   [30],19       (0729)     mov     [USB_t2], USB_CurrentTD    ; Use Temp as mvi pointer
0871: 90 26    CALL  0x0899        (0730)     call     USB_GETBYTE               ; Get the descriptor data source
0873: 90 1C    CALL  0x0891        (0731)     call     USB_GETWORD               ; Get the descriptor size
0875: 90 1A    CALL  0x0891        (0732)     call     USB_GETWORD               ; Get the descriptor address
0877: 90 18    CALL  0x0891        (0733)     call     USB_GETWORD               ; Get the Status Pointer
                                   (0734) ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
0879: 5D 58    MOV   A,REG[88]     (0735)     mov     A, reg[USB_EP0DATA+bmRequestType] ; Get bmRequestType
087B: 21 80    AND   A,128         (0736)     and     A, 0x80                         ; Control Read or Write
087D: A0 03    JZ    0x0881        (0737)     jz      .control_write
                                   (0738) 
087F: 8E 8E    JMP   0x070E        (0739)     jmp     USB_InitControlRead
                                   (0740) 
                                   (0741) .control_write:
0881: 8E D3    JMP   0x0755        (0742)     jmp     USB_InitControlWrite
                                   (0743) 
                                   (0744) 
                                   (0745) ;-----------------------------------------------------------------------------
                                   (0746) ;  FUNCTION NAME: USB_LOOKUP
                                   (0747) ;
                                   (0748) ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
                                   (0749) ;
                                   (0750) ;-----------------------------------------------------------------------------
                                   (0751) ;
                                   (0752) ;  ARGUMENTS:    A:X Point to the lookup table
                                   (0753) ;                USB_t2 contain the table index
                                   (0754) ;
                                   (0755) ;  RETURNS:      Address of the LT_ENTRY in A:X
                                   (0756) ;
                                   (0757) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0758) ;
                                   (0759) ;  THEORY of OPERATION or PROCEDURE:
                                   (0760) ;
                                   (0761) ;-----------------------------------------------------------------------------
                                   (0762) export USB_LOOKUP
                                   (0763) USB_LOOKUP:
0883: 75       INC   X             (0764)     inc     X                          ; Point to the first table entry
0884: 09 00    ADC   A,0           (0765)     adc     A, 0                       ;
0886: 65 1E    ASL   [30]
                                   (0766) 
0888: 65 1E    ASL   [30]          (0767)     LT_INDEX_TO_OFFSET USB_t2          ; Convert the index
088A: 4B       SWAP  A,X           (0768)     swap    A, X
088B: 02 1E    ADD   A,[30]        (0769)     add     A, [USB_t2]                ;
088D: 4B       SWAP  A,X           (0770)     swap    A, X
088E: 09 00    ADC   A,0           (0771)     adc     A, 0
0890: 7F       RET                 (0772)     ret
                                   (0773) 
                                   (0774) 
                                   (0775) ;-----------------------------------------------------------------------------
                                   (0776) ;  FUNCTION NAME: USB_GETWORD/USB_GETBYTE
                                   (0777) ;
                                   (0778) ;  DESCRIPTION:    Get a word value from ROM
                                   (0779) ;
                                   (0780) ;-----------------------------------------------------------------------------
                                   (0781) ;
                                   (0782) ;  ARGUMENTS:    A:X is the ROM Address
                                   (0783) ;                USB_t2 is the destination address
                                   (0784) ;
                                   (0785) ;  RETURNS:      USB_t1
                                   (0786) ;
                                   (0787) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0788) ;                USES USB_t2
                                   (0789) ;                A:X points to the subsequent locaction ROM location
                                   (0790) ;  THEORY of OPERATION or PROCEDURE:
                                   (0791) ;
                                   (0792) ;-----------------------------------------------------------------------------
                                   (0793) export USB_GETWORD
                                   (0794) USB_GETWORD:
                                   (0795) 
0891: 08       PUSH  A             (0796)     push    A                          ; Don't loose the pointer MSB
0892: 28       ROMX                (0797)     romx                               ; Data source flag
0893: 3F 1E    MVI   [30],A        (0798)     mvi     [USB_t2], A                ; Save the data source
0895: 18       POP   A             (0799)     pop     A                          ; Get the MSB back
0896: 75       INC   X             (0800)     inc     X                          ; Point to the next  entry
0897: 09 00    ADC   A,0           (0801)     adc     A, 0                       ;
                                   (0802) 
                                   (0803) export USB_GETBYTE
                                   (0804) USB_GETBYTE:
                                   (0805) 
0899: 08       PUSH  A             (0806)     push    A                          ; Don't loose the pointer MSB
089A: 28       ROMX                (0807)     romx                               ; Data source flag
089B: 3F 1E    MVI   [30],A        (0808)     mvi     [USB_t2], A                ; Save the data source
089D: 18       POP   A             (0809)     pop     A                          ; Get the MSB back
089E: 75       INC   X             (0810)     inc     X                          ; Point to the next  entry
089F: 09 00    ADC   A,0           (0811)     adc     A, 0                       ;
08A1: 7F       RET                 (0812)     ret
                                   (0813) 
                                   (0814) 
                                   (0815) ;-----------------------------------------------------------------------------
                                   (0816) ;  FUNCTION NAME: USB_GET_DEVICE_TABLE_ENTRY
                                   (0817) ;
                                   (0818) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                   (0819) ;                  Not intended for use by C fucntions
                                   (0820) ;
                                   (0821) ;-----------------------------------------------------------------------------
                                   (0822) ;
                                   (0823) ;  ARGUMENTS:
                                   (0824) ;
                                   (0825) ;  RETURNS:        A:X points the the current DEVICE_TABLE entry
                                   (0826) ;                  Carry flag is set if the current device index is out of range
                                   (0827) ;
                                   (0828) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0829) ;
                                   (0830) ;  THEORY of OPERATION or PROCEDURE:
                                   (0831) ;
                                   (0832) ;-----------------------------------------------------------------------------
                                   (0833) export USB_GET_DEVICE_TABLE_ENTRY
                                   (0834) USB_GET_DEVICE_TABLE_ENTRY:
08A2: 5F 1E 00 MOV   [30],[0]      (0835)     mov     [USB_t2], [USB_bCurrentDevice]    ; Use the UM temp var--Selector
                                   (0836) 
08A5: 50 02    MOV   A,2           (0837)     mov     A, >USB_DEVICE_LOOKUP      ; Get the ROM Address MSB
08A7: 57 FA    MOV   X,250         (0838)     mov     X, <USB_DEVICE_LOOKUP      ; Get the ROM Address LSB
08A9: 28       ROMX                (0839)     romx                               ; First entry is the table size (only a byte)
08AA: 3A 1E    CMP   A,[30]        (0840)     cmp     A, [USB_t2]                ; Range check
08AC: 50 02    MOV   A,2           (0841)     mov     A, >USB_DEVICE_LOOKUP      ; Get the ROM Address MSB
08AE: C0 03    JC    0x08B2        (0842)     jc      .exit
                                   (0843) ; Flow here if the index is valid
08B0: 9F D1    CALL  0x0883        (0844)     call    USB_LOOKUP                 ; Look up the configuration
                                   (0845) ; Jump or flow here on exit
                                   (0846) .exit:
08B2: 7F       RET                 (0847)     ret
                                   (0848) 
                                   (0849) 
                                   (0850) ;-----------------------------------------------------------------------------
                                   (0851) ;  FUNCTION NAME: USB_GET_CONFIG_TABLE_ENTRY
                                   (0852) ;
                                   (0853) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                   (0854) ;                  Not intended fOR use by C fucntions
                                   (0855) ;                  Does not do range checking on
                                   (0856) ;
                                   (0857) ;-----------------------------------------------------------------------------
                                   (0858) ;
                                   (0859) ;  ARGUMENTS:
                                   (0860) ;
                                   (0861) ;  RETURNS:        A:X points the the current CONFIG_TABLE entry
                                   (0862) ;                  Carry flag is set if the current device index is out of range
                                   (0863) ;
                                   (0864) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0865) ;
                                   (0866) ;  THEORY of OPERATION or PROCEDURE:
                                   (0867) ;
                                   (0868) ;-----------------------------------------------------------------------------
                                   (0869) export USB_GET_CONFIG_TABLE_ENTRY
                                   (0870) USB_GET_CONFIG_TABLE_ENTRY:
08B3: 9F ED    CALL  0x08A2        (0871)     call    USB_GET_DEVICE_TABLE_ENTRY    ; Get the selected device
08B5: 55 1E 1F MOV   [30],31       (0872)     mov     [USB_t2], USB_t1           ; Set the GETWORD destination
08B8: 9F D7    CALL  0x0891        (0873)     call    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                   (0874)                                        ; ITempW has the address
08BA: 5D 5A    MOV   A,REG[90]     (0875)     mov     A, reg[USB_EP0DATA+wValueLo]    ; Get the configuration number
08BC: 53 1E    MOV   [30],A        (0876)     mov     [USB_t2], A                ; Save it
08BE: 51 1F    MOV   A,[31]        (0877)     mov     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
08C0: 58 20    MOV   X,[32]        (0878)     mov     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
                                   (0879) 
                                   (0880) ; A:X Points to the CONFIG_LOOKUP, so get the current entry
08C2: 5F 1E 01 MOV   [30],[1]      (0881)     mov     [USB_t2], [USB_Configuration]   ; Get the configuration number
08C5: 7A 1E    DEC   [30]          (0882)     DEC     [USB_t2]                   ; We don't populate the 0th entry
08C7: 9F BA    CALL  0x0883        (0883)     call    USB_LOOKUP                 ; Look up the configuration
08C9: 7F       RET                 (0884)     ret
                                   (0885) 
                                   (0886) 
                                   (0887) ;-----------------------------------------------------------------------------
                                   (0888) ;  FUNCTION NAME: USB_UpdateStatusBlock
                                   (0889) ;
                                   (0890) ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
                                   (0891) ;                  block is updated with the completion code from the
                                   (0892) ;                  argument (A) and the _TransferByteCount.
                                   (0893) ;
                                   (0894) ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
                                   (0895) ;                  to make sure no other updates are made to the StatusBlock by
                                   (0896) ;                  the USB User Module.
                                   (0897) ;
                                   (0898) ;-----------------------------------------------------------------------------
                                   (0899) ;
                                   (0900) ;  ARGUMENTS:      A contains the Completion Status Code
                                   (0901) ;
                                   (0902) ;  RETURNS:        None
                                   (0903) ;
                                   (0904) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0905) ;
                                   (0906) ;  THEORY of OPERATION or PROCEDURE:
                                   (0907) ;
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) USB_UpdateStatusBlock:
08CA: 58 19    MOV   X,[25]        (0910)     mov     X, [USB_StatusBlockPtr + 1]   ;
08CC: 4B       SWAP  A,X           (0911)     swap    A, X                       ; Don't loose the completion code
08CD: 39 00    CMP   A,0           (0912)     cmp     A, 0                       ; NULL?
08CF: A0 0F    JZ    0x08DF        (0913)     jz      .done                      ; No update on NULL
                                   (0914) ; Flow here to update the VSR Completion Status Block
08D1: 4B       SWAP  A,X           (0915)     swap    A, X                       ; Completion code A, Pointer in X
08D2: 54 00    MOV   [X+0],A       (0916)     mov     [X + 0], A                 ; Update the completion Code
08D4: 51 1A    MOV   A,[26]        (0917)     mov     A, [USB_TransferByteCount]   ; Actual Byte Count MSB
08D6: 54 01    MOV   [X+1],A       (0918)     mov     [X + 1], A
08D8: 51 1B    MOV   A,[27]        (0919)     mov     A, [USB_TransferByteCount + 1]   ; Actual Byte Count LSB
08DA: 54 02    MOV   [X+2],A       (0920)     mov     [X + 2], A
08DC: 55 19 00 MOV   [25],0        (0921)     mov     [USB_StatusBlockPtr + 1], 0   ; Clear the Block Pointer
                                   (0922) .done:
08DF: 7F       RET                 (0923)     ret                                ; All done
                                   (0924) 
                                   (0925) 
                                   (0926) ;-----------------------------------------------------------------------------
                                   (0927) ;  FUNCTION NAME: USB_InitializeStatusBlock
                                   (0928) ;
                                   (0929) ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
                                   (0930) ;                  The completion code is set to USB_XFER_IDLE.
                                   (0931) ;
                                   (0932) ;-----------------------------------------------------------------------------
                                   (0933) ;
                                   (0934) ;  ARGUMENTS:      None
                                   (0935) ;
                                   (0936) ;  RETURNS:        None
                                   (0937) ;
                                   (0938) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0939) ;
                                   (0940) ;  THEORY of OPERATION or PROCEDURE:
                                   (0941) ;
                                   (0942) ;-----------------------------------------------------------------------------
                                   (0943) USB_InitializeStatusBlock:
08E0: 51 19    MOV   A,[25]        (0944)     mov     A, [USB_StatusBlockPtr + 1]   ;
08E2: 39 00    CMP   A,0           (0945)     cmp     A, 0                       ; NULL?
08E4: A0 0B    JZ    0x08F0        (0946)     jz      .done                      ; No update on NULL
                                   (0947) ; Flow here to initialize the Completion Status Block
08E6: 4B       SWAP  A,X           (0948)     swap    A, X                       ; Pointer in X
08E7: 56 00 00 MOV   [X+0],0       (0949)     mov     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
08EA: 55 1A 00 MOV   [26],0        (0950)     mov     [USB_TransferByteCount], 0   ; Clear the byte count
08ED: 55 1B 00 MOV   [27],0        (0951)     mov     [USB_TransferByteCount + 1], 0   ;
                                   (0952) .done:
08F0: 7F       RET                 (0953)     ret                                ; All done
                                   (0954) 
                                   (0955) 
                                   (0956) ;-----------------------------------------------------------------------------
                                   (0957) ;  FUNCTION NAME: ;  USB 1st Tier Dispactch Jump Table (based on bmRequestType)
                                   (0958) ;
                                   (0959) ;  DESCRIPTION:
                                   (0960) ;
                                   (0961) ;-----------------------------------------------------------------------------
                                   (0962) ;
                                   (0963) ;  ARGUMENTS:
                                   (0964) ;
                                   (0965) ;  RETURNS:
                                   (0966) ;
                                   (0967) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0968) ;
                                   (0969) ;  THEORY of OPERATION or PROCEDURE:
                                   (0970) ;
                                   (0971) ;-----------------------------------------------------------------------------
                                   (0972) MACRO BMREQUEST_DISPATCH
                                   (0973) IF (USB_CB_@0_@1_@2 & 1)
                                   (0974)     jmp     USB_DT_@0_@1_@2_Dispatch
                                   (0975) ELSE
                                   (0976)     jmp     USB_Not_Supported_Local_Drv
                                   (0977) ENDIF
                                   (0978) ENDM
                                   (0979) 
                                   (0980) USB_DT_bmRequestType::
08F1: 8B 1F    JMP   0x0411        (0981)     BMREQUEST_DISPATCH    h2d, std, dev
08F3: 8B 68    JMP   0x045C        (0982)     BMREQUEST_DISPATCH    h2d, std, ifc
08F5: 8B B6    JMP   0x04AC        (0983)     BMREQUEST_DISPATCH    h2d, std, ep
08F7: 80 42    JMP   0x093A        (0984)     BMREQUEST_DISPATCH    h2d, std, oth
08F9: 80 40    JMP   0x093A        (0985)     BMREQUEST_DISPATCH    h2d, cls, dev
08FB: 83 19    JMP   0x0C15        (0986)     BMREQUEST_DISPATCH    h2d, cls, ifc
08FD: 80 3C    JMP   0x093A        (0987)     BMREQUEST_DISPATCH    h2d, cls, ep
08FF: 80 3A    JMP   0x093A        (0988)     BMREQUEST_DISPATCH    h2d, cls, oth
0901: 80 38    JMP   0x093A        (0989)     BMREQUEST_DISPATCH    h2d, vnd, dev
0903: 80 36    JMP   0x093A        (0990)     BMREQUEST_DISPATCH    h2d, vnd, ifc
0905: 80 34    JMP   0x093A        (0991)     BMREQUEST_DISPATCH    h2d, vnd, ep
0907: 80 32    JMP   0x093A        (0992)     BMREQUEST_DISPATCH    h2d, vnd, oth
0909: 80 30    JMP   0x093A        (0993)     BMREQUEST_DISPATCH    h2d, rsv, dev
090B: 80 2E    JMP   0x093A        (0994)     BMREQUEST_DISPATCH    h2d, rsv, ifc
090D: 80 2C    JMP   0x093A        (0995)     BMREQUEST_DISPATCH    h2d, rsv, ep
090F: 80 2A    JMP   0x093A        (0996)     BMREQUEST_DISPATCH    h2d, rsv, oth
0911: 8A E0    JMP   0x03F2        (0997)     BMREQUEST_DISPATCH    d2h, std, dev
0913: 8B 1E    JMP   0x0432        (0998)     BMREQUEST_DISPATCH    d2h, std, ifc
0915: 8B 72    JMP   0x0488        (0999)     BMREQUEST_DISPATCH    d2h, std, ep
0917: 80 22    JMP   0x093A        (1000)     BMREQUEST_DISPATCH    d2h, std, oth
0919: 80 20    JMP   0x093A        (1001)     BMREQUEST_DISPATCH    d2h, cls, dev
091B: 83 13    JMP   0x0C2F        (1002)     BMREQUEST_DISPATCH    d2h, cls, ifc
091D: 80 1C    JMP   0x093A        (1003)     BMREQUEST_DISPATCH    d2h, cls, ep
091F: 80 1A    JMP   0x093A        (1004)     BMREQUEST_DISPATCH    d2h, cls, oth
0921: 80 18    JMP   0x093A        (1005)     BMREQUEST_DISPATCH    d2h, vnd, dev
0923: 80 16    JMP   0x093A        (1006)     BMREQUEST_DISPATCH    d2h, vnd, ifc
0925: 80 14    JMP   0x093A        (1007)     BMREQUEST_DISPATCH    d2h, vnd, ep
0927: 80 12    JMP   0x093A        (1008)     BMREQUEST_DISPATCH    d2h, vnd, oth
0929: 80 10    JMP   0x093A        (1009)     BMREQUEST_DISPATCH    d2h, rsv, dev
092B: 80 0E    JMP   0x093A        (1010)     BMREQUEST_DISPATCH    d2h, rsv, ifc
092D: 80 0C    JMP   0x093A        (1011)     BMREQUEST_DISPATCH    d2h, rsv, ep
092F: 80 0A    JMP   0x093A        (1012)     BMREQUEST_DISPATCH    d2h, rsv, oth
0931: 39 20    CMP   A,32
                                   (1013) USB_DT_End:
                                   (1014) USB_DT_Size: equ (USB_DT_End-USB_DT_bmRequestType) / 2
                                   (1015) USB_bmRequestType_Dispatch::
0933: D0 04    JNC   0x0938        (1016)     DISPATCHER USB_DT_bmRequestType, USB_DT_Size, USB_Not_Supported_Local_Drv
0935: 64       ASL   A
0936: EF BA    JACC  0x08F1
0938: 80 01    JMP   0x093A
                                   (1017) 
                                   (1018) USB_Not_Supported_Local_Drv:
093A: 7D 03 C1 LJMP  0x03C1        (1019)     ljmp     USB_Not_Supported
093D: 12 01    SUB   A,[1]
093F: 00       SWI   
0940: 02 00    ADD   A,[0]
0942: 00       SWI   
0943: 00       SWI   
0944: 08       PUSH  A
0945: B4 04    JNZ   0x0D4A
0947: E0 FA    JACC  0x0A42
0949: 03 00    ADD   A,[X+0]
094B: 01 02    ADD   A,2
094D: 00       SWI   
094E: 01 09    ADD   A,9
0950: 02 29    ADD   A,[41]
0952: 00       SWI   
0953: 01 01    ADD   A,1
0955: 00       SWI   
0956: 80 32    JMP   0x0989
0958: 09 04    ADC   A,4
095A: 00       SWI   
095B: 00       SWI   
095C: 02 03    ADD   A,[3]
095E: 00       SWI   
095F: 00       SWI   
0960: 00       SWI   
0961: 09 21    ADC   A,33
0963: 11 01    SUB   A,1
0965: 00       SWI   
0966: 01 22    ADD   A,34
0968: 25 00    AND   [X+0],A
096A: 07 05 81 ADD   [X+5],129
096D: 03 40    ADD   A,[X+64]
096F: 00       SWI   
0970: 01 07    ADD   A,7
0972: 05 02    ADD   [X+2],A
0974: 03 40    ADD   A,[X+64]
0976: 00       SWI   
0977: 01 06    ADD   A,6
0979: A0 FF    JZ    0x0A79
097B: 09 01    ADC   A,1
097D: A1 01    JZ    0x0A7F
097F: 09 02    ADC   A,2
0981: A1 00    JZ    0x0A82
0983: 09 03    ADC   A,3
0985: 15 00    SUB   [X+0],A
0987: 25 FF    AND   [X-1],A
0989: 75       INC   X
098A: 08       PUSH  A
098B: 95 40    CALL  0x0ECD
098D: 91 02    CALL  0x0A91
098F: 09 04    ADC   A,4
0991: 15 00    SUB   [X+0],A
0993: 25 FF    AND   [X-1],A
0995: 75       INC   X
0996: 08       PUSH  A
0997: 95 40    CALL  0x0ED9
0999: 81 02    JMP   0x0A9C
099B: C0 C0    JC    0x0A5C
099D: 04 00    ADD   [0],A
099F: 00       SWI   
09A0: 04 09    ADD   [9],A
09A2: C6 00    JC    0x0FA3
09A4: 00       SWI   
09A5: DE 00    JNC   0x07A6
09A7: 00       SWI   
09A8: 38 09    ADD   SP,9
09AA: CA 00    JC    0x03AB
09AC: 00       SWI   
09AD: DE 00    JNC   0x07AE
09AF: 00       SWI   
09B0: 28       ROMX  
09B1: 0A 02    ADC   A,[2]
09B3: 00       SWI   
09B4: 00       SWI   
09B5: DE 00    JNC   0x07B6
09B7: 00       SWI   
09B8: 2C 0A    OR    [10],A
09BA: 2A 00    OR    A,[0]
09BC: 00       SWI   
09BD: DE 00    JNC   0x07BE
09BF: 00       SWI   
09C0: 2C 0A    OR    [10],A
09C2: 56 00 00 MOV   [X+0],0
09C5: DE 04    JNC   0x07CA
09C7: 03 09    ADD   A,[X+9]
09C9: 04 38    ADD   [56],A
09CB: 03 43    ADD   A,[X+67]
09CD: 00       SWI   
09CE: 79       DEC   X
09CF: 00       SWI   
09D0: 70 00    AND   F,0
09D2: 72 00    XOR   F,0
09D4: 65 00    ASL   [0]
09D6: 73       CPL   A
09D7: 00       SWI   
09D8: 73       CPL   A
09D9: 00       SWI   
09DA: 20       POP   X
09DB: 00       SWI   
09DC: 53 00    MOV   [0],A
09DE: 65 00    ASL   [0]
09E0: 6D       RRC   A
09E1: 00       SWI   
09E2: 69 00    ASR   [X+0]
09E4: 63 00 6F MOV   REG[X+0],111
09E7: 00       SWI   
09E8: 6E 00    RRC   [0]
09EA: 64       ASL   A
09EB: 00       SWI   
09EC: 75       INC   X
09ED: 00       SWI   
09EE: 63 00 74 MOV   REG[X+0],116
09F1: 00       SWI   
09F2: 6F 00    RRC   [X+0]
09F4: 72 00    XOR   F,0
09F6: 20       POP   X
09F7: 00       SWI   
09F8: 28       ROMX  
09F9: 00       SWI   
09FA: 42 00 52 AND   REG[X+0],82
09FD: 00       SWI   
09FE: 57 00    MOV   X,0
0A00: 29 00    OR    A,0
0A02: 28       ROMX  
0A03: 03 43    ADD   A,[X+67]
0A05: 00       SWI   
0A06: 79       DEC   X
0A07: 00       SWI   
0A08: 70 00    AND   F,0
0A0A: 72 00    XOR   F,0
0A0C: 65 00    ASL   [0]
0A0E: 73       CPL   A
0A0F: 00       SWI   
0A10: 73       CPL   A
0A11: 00       SWI   
0A12: 20       POP   X
0A13: 00       SWI   
0A14: 47 00 45 TST   [0],69
0A17: 00       SWI   
0A18: 4E       SWAP  SP,A
0A19: 00       SWI   
0A1A: 45 00 52 XOR   REG[0],82
0A1D: 00       SWI   
0A1E: 49 00 43 TST   REG[0],67
0A21: 00       SWI   
0A22: 20       POP   X
0A23: 00       SWI   
0A24: 48 00 49 TST   [X+0],73
0A27: 00       SWI   
0A28: 44 00 2C OR    REG[X+0],44
0A2B: 03 45    ADD   A,[X+69]
0A2D: 00       SWI   
0A2E: 64       ASL   A
0A2F: 00       SWI   
0A30: 69 00    ASR   [X+0]
0A32: 74       INC   A
0A33: 00       SWI   
0A34: 20       POP   X
0A35: 00       SWI   
0A36: 79       DEC   X
0A37: 00       SWI   
0A38: 6F 00    RRC   [X+0]
0A3A: 75       INC   X
0A3B: 00       SWI   
0A3C: 72 00    XOR   F,0
0A3E: 20       POP   X
0A3F: 00       SWI   
0A40: 73       CPL   A
0A41: 00       SWI   
0A42: 74       INC   A
0A43: 00       SWI   
0A44: 72 00    XOR   F,0
0A46: 69 00    ASR   [X+0]
0A48: 6E 00    RRC   [0]
0A4A: 67       ASR   A
0A4B: 00       SWI   
0A4C: 20       POP   X
0A4D: 00       SWI   
0A4E: 68 00    ASR   [0]
0A50: 65 00    ASL   [0]
0A52: 72 00    XOR   F,0
0A54: 65 00    ASL   [0]
0A56: 2C 03    OR    [3],A
0A58: 45 00 64 XOR   REG[0],100
0A5B: 00       SWI   
0A5C: 69 00    ASR   [X+0]
0A5E: 74       INC   A
0A5F: 00       SWI   
0A60: 20       POP   X
0A61: 00       SWI   
0A62: 79       DEC   X
0A63: 00       SWI   
0A64: 6F 00    RRC   [X+0]
0A66: 75       INC   X
0A67: 00       SWI   
0A68: 72 00    XOR   F,0
0A6A: 20       POP   X
0A6B: 00       SWI   
0A6C: 73       CPL   A
0A6D: 00       SWI   
0A6E: 74       INC   A
0A6F: 00       SWI   
0A70: 72 00    XOR   F,0
0A72: 69 00    ASR   [X+0]
0A74: 6E 00    RRC   [0]
0A76: 67       ASR   A
0A77: 00       SWI   
0A78: 20       POP   X
0A79: 00       SWI   
0A7A: 68 00    ASR   [0]
0A7C: 65 00    ASL   [0]
0A7E: 72 00    XOR   F,0
0A80: 65 00    ASL   [0]

FILE: lib\usb_cls_hid.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USB_cls_hid.asm
                                   (0004) ;;   Version: 1.3, Updated on 2007/09/28 at 14:23:41
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USB Human Interface Device (HID) Class request implemenatation
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API
                                   (0014) ;;        function returns. Even though these registers may be preserved now,
                                   (0015) ;;        there is no guarantee they will be preserved in future releases.
                                   (0016) ;;-----------------------------------------------------------------------------
                                   (0017) ;;  Copyright (c) Cypress Semiconductor 2005. All Rights Reserved.
                                   (0018) ;;*****************************************************************************
                                   (0019) ;;*****************************************************************************
                                   (0020) 
                                   (0021) include "m8c.inc"
                                   (0022) include "USB_macros.inc"
                                   (0023) include "USB.inc"
                                   (0024) include "memory.inc"
                                   (0025) 
                                   (0026) ;-----------------------------------------------
                                   (0027) ;  Global Symbols
                                   (0028) ;-----------------------------------------------
                                   (0029) EXPORT USB_UpdateHIDTimer
                                   (0030) EXPORT _USB_UpdateHIDTimer
                                   (0031) EXPORT USB_bGetProtocol
                                   (0032) EXPORT _USB_bGetProtocol
                                   (0033) ;export of the following items allows an application to initialize the data
                                   (0034) ; if necessary, possibly on reboot or other programatic events (usb reset).
                                   (0035) ; USB_Protocol is the variable controling boot/report mode for 
                                   (0036) ; HID devices.
                                   (0037) EXPORT  _USB_IdleReload    ; Idle Timer Reload Value
                                   (0038) EXPORT   USB_IdleReload    ; Idle Timer Reload Value
                                   (0039) EXPORT  _USB_Protocol	  ; Active Protocol
                                   (0040) EXPORT   USB_Protocol    ; Active Protocol
                                   (0041) 
                                   (0042) AREA InterruptRAM (RAM,REL,CON)
                                   (0043) ;-----------------------------------------------
                                   (0044) ;  Constant Definitions
                                   (0045) ;-----------------------------------------------
                                   (0046) ;-----------------------------------------------
                                   (0047) ; Variable Allocation
                                   (0048) ;-----------------------------------------------
                                   (0049) ;----------------------------------------------------------------------------
                                   (0050) ; Interface Setting
                                   (0051) ;----------------------------------------------------------------------------
                                   (0052)   USB_IdleReload:
                                   (0053)  _USB_IdleReload:                       BLK   1h    ; Idle Timer Reload Value
                                   (0054)  USB_IdleTimer:                         BLK   1h    ; Idle Timers
                                   (0055)   USB_Protocol:   
                                   (0056)  _USB_Protocol:                         BLK   1h    ; Active Protocol
                                   (0057) 
                                   (0058) AREA UserModules (ROM, REL)
                                   (0059) ;-----------------------------------------------------------------------------
                                   (0060) ;  FUNCTION NAME: USB_bGetProtocol
                                   (0061) ;
                                   (0062) ;  DESCRIPTION:   Returns the selected protocol value to the application
                                   (0063) ;
                                   (0064) ;-----------------------------------------------------------------------------
                                   (0065) ;
                                   (0066) ;  ARGUMENTS:    A: Interface number
                                   (0067) ;
                                   (0068) ;  RETURNS:      A: Protocol values
                                   (0069) ;
                                   (0070) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0071) ;
                                   (0072) ;  THEORY of OPERATION or PROCEDURE:
                                   (0073) ;
                                   (0074) ;-----------------------------------------------------------------------------
                                   (0075) .SECTION
                                   (0076)  USB_bGetProtocol:
                                   (0077) _USB_bGetProtocol:
0A82: 70 BF    AND   F,191         (0078)     RAM_PROLOGUE RAM_USE_CLASS_3
0A84: 62 D3 00 MOV   REG[211],0    (0079) 	RAM_SETPAGE_IDX >USB_Protocol
0A87: 5C       MOV   X,A           (0080)     mov  X, A                          ; Argument is the index
0A88: 52 40    MOV   A,[X+64]      (0081)     mov  A, [X + USB_Protocol] ; Return the protocol
0A8A: 70 3F    AND   F,63
0A8C: 71 C0    OR    F,192         (0082) 	RAM_EPILOGUE RAM_USE_CLASS_3
0A8E: 7F       RET                 (0083)     ret
                                   (0084) .ENDSECTION
                                   (0085) ;-----------------------------------------------------------------------------
                                   (0086) ;  FUNCTION NAME: USB_UpdateHIDTimer
                                   (0087) ;
                                   (0088) ;  DESCRIPTION:    Updates the HID report timer and reloads it if it expires
                                   (0089) ;
                                   (0090) ;-----------------------------------------------------------------------------
                                   (0091) ;
                                   (0092) ;  ARGUMENTS:     A: Interface number
                                   (0093) ;
                                   (0094) ;  RETURNS:       A: USB_IDLE_TIMER_EXPIRED, if the timer is running and expired
                                   (0095) ;                    USB_IDLE_TIMER_RUNNING, if the timer is running
                                   (0096) ;                    USB_IDLE_TIMER_INDEFINITE, if the report should be made on change
                                   (0097) ;
                                   (0098) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0099) ;
                                   (0100) ;  THEORY of OPERATION or PROCEDURE:
                                   (0101) ;
                                   (0102) ;-----------------------------------------------------------------------------
                                   (0103) .SECTION
                                   (0104)  USB_UpdateHIDTimer:
                                   (0105) _USB_UpdateHIDTimer:
0A8F: 70 BF    AND   F,191         (0106)     RAM_PROLOGUE RAM_USE_CLASS_3
0A91: 62 D3 00 MOV   REG[211],0    (0107) 	RAM_SETPAGE_IDX >USB_IdleReload
0A94: 5C       MOV   X,A           (0108)     mov  X, A                          ; Make the argument the index
                                   (0109) ; Flow here to check if the timer is "indefinite"
0A95: 3D 3E 00 CMP   [X+62],0      (0110)     cmp	 [X + USB_IdleReload], 0       ; Indefinite?
0A98: A0 13    JZ    0x0AAC        (0111)     jz   .indefinite                   ; Jump if Indefinite?
                                   (0112) ; Flow here to check the timers
0A9A: 7B 3F    DEC   [X+63]        (0113)     DEC    [X + USB_IdleTimer]         ; Decrement the timer
0A9C: C0 08    JC    0x0AA5        (0114)     jc   .expired
                                   (0115) ; Flow here if the timer has not expired
0A9E: 50 02    MOV   A,2           (0116)     mov  A, USB_IDLE_TIMER_RUNNING     ; Return value (not expired)
0AA0: 70 3F    AND   F,63
0AA2: 71 C0    OR    F,192         (0117) 	RAM_EPILOGUE RAM_USE_CLASS_3
0AA4: 7F       RET                 (0118)     ret                                ; Quick exit
                                   (0119) ; Jump here if the timer expired
                                   (0120) .expired:
0AA5: 52 3E    MOV   A,[X+62]      (0121)     mov  A, [X + USB_IdleReload]       ; Reload the timer
0AA7: 54 3F    MOV   [X+63],A      (0122)     mov  [X + USB_IdleTimer], A        ; 
0AA9: 50 01    MOV   A,1           (0123)     mov  A, USB_IDLE_TIMER_EXPIRED     ; Return value (expired)
0AAB: 7F       RET                 (0124)     ret                                ; Quick exit
                                   (0125) ; Jump here to make return "on change/indefinite"
                                   (0126) .indefinite:
0AAC: 50 00    MOV   A,0           (0127)     mov  A, USB_IDLE_TIMER_INDEFINITE  ; Return value (change/indefinite)
0AAE: 70 3F    AND   F,63
0AB0: 71 C0    OR    F,192         (0128) 	RAM_EPILOGUE RAM_USE_CLASS_3
0AB2: 7F       RET                 (0129)     ret                                ; Exit
                                   (0130) .ENDSECTION
                                   (0131) ;-----------------------------------------------------------------------------
                                   (0132) ;  FUNCTION NAME: USB_CB_d2h_std_ifc_06
                                   (0133) ;
                                   (0134) ;  DESCRIPTION:   Get Interface Descriptor
                                   (0135) ;
                                   (0136) ;****************************************************************
                                   (0137) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Descriptor
                                   (0138) ;****************************************************************
                                   (0139) ;
                                   (0140) ; bmRequestType   : (IN | STANDARD | INTERFACE)    = 81h
                                   (0141) ; bRequest        : GET_DESCRIPTOR                 = 06h    
                                   (0142) ; wValue          : DESCRIPTOR TYPE | INDEX        = xxxxh  
                                   (0143) ; wIndex          : INTERFACE                      = --xxh
                                   (0144) ; wLength         : DESCRIPTOR_LENGTH              = --xxh  
                                   (0145) ; 
                                   (0146) ; The GET_INTERFACE_DESCRIPTOR request returns the specified 
                                   (0147) ; descriptor if the descriptor exists. 
                                   (0148) ;
                                   (0149) ; The upper byte of request_value contains the descriptor type and 
                                   (0150) ; the lower byte contains the descriptor index. request_index 
                                   (0151) ; contains either 0000h or the Language ID. request_length contains 
                                   (0152) ; the descriptor length. The actual descriptor information is 
                                   (0153) ; transferred in subsequent data packets. 
                                   (0154) ;
                                   (0155) ; USB defines only a DEVICE recipient but the HID spec added 
                                   (0156) ; support for the INTERFACE recipient.
                                   (0157) ;
                                   (0158) ; Get Descriptor from an HID interface returns either HID, 
                                   (0159) ; REPORT, or PHYSICAL descriptors.
                                   (0160) ;
                                   (0161) ;****************************************************************
                                   (0162) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_UM_SUPPLIED)
                                   (0163) export  USB_CB_d2h_std_ifc_06
                                   (0164) USB_CB_d2h_std_ifc_06:
0AB3: 91 34    CALL  0x0BE9        (0165)     call  USB_GetInterfaceLookupTable  ; Point the the interface lookup table
0AB5: 08       PUSH  A             (0166)     push  A                            ; Save the MSB
0AB6: 5D 5B    MOV   A,REG[91]     (0167)     mov   A, REG[USB_EP0DATA+wValueHi] ; Get descriptor type
0AB8: 39 21    CMP   A,33          (0168)     cmp   A, DESCR_TYPE_HID_CLASS      ; HID Class descriptor?
0ABA: A0 0E    JZ    0x0AC9        (0169)     jz    .send_hid_class_descr
0ABC: 39 22    CMP   A,34          (0170)     cmp   A, DESCR_TYPE_HID_REPORT     ; HID Report descriptor?
0ABE: A0 04    JZ    0x0AC3        (0171)     jz    .send_hid_report_descr
                                   (0172) ; Jump or flow here if the request is not supported
                                   (0173) .not_supported:
0AC0: 18       POP   A             (0174)     pop   A                            ; Restore the stack
0AC1: 81 7F    JMP   0x0C41        (0175)     jmp   USB_Not_Supported_Local_Hid
                                   (0176) ; Jump here to send the HID Report Descriptor
                                   (0177) .send_hid_report_descr:
0AC3: 18       POP   A             (0178)     pop   A                            ; Restore the interface lookup table MSB
0AC4: 4B       SWAP  A,X           (0179)     swap  A, X                         ; Add the offset
0AC5: 01 02    ADD   A,2           (0180)     add   A, 2                         ; Point to the right table entry
0AC7: 80 05    JMP   0x0ACD        (0181)     jmp   .finish
                                   (0182) ; Jump here to send the HID Class Descriptor
                                   (0183) .send_hid_class_descr:
0AC9: 18       POP   A             (0184)     pop   A                            ; Restore the interface lookup table MSB
0ACA: 4B       SWAP  A,X           (0185)     swap  A, X                         ; Add the offset
0ACB: 01 04    ADD   A,4           (0186)     add   A, 4                         ; Point to the right table entry
                                   (0187) ; Jump or flow here with A:X Pointing to the 
                                   (0188) .finish:
0ACD: 4B       SWAP  A,X           (0189)     swap  A, X                         ; Back where they belong
0ACE: 09 00    ADC   A,0           (0190)     adc   A, 0                         ; Don't forget the carry
0AD0: 55 1E 1F MOV   [30],31       (0191)     mov   [USB_t2],USB_t1              ; Set the GETWORD destination 
0AD3: 9D BC    CALL  0x0891        (0192)     call  USB_GETWORD                  ; Get the pointer to the transfer descriptor table
                                   (0193)                                        ; ITempW has the address
                                   (0194) ; Get the interface number
0AD5: 5D 5C    MOV   A,REG[92]     (0195)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0AD7: 53 1E    MOV   [30],A        (0196)     mov   [USB_t2], A                  ; Save it for the call to LOOKUP
0AD9: 51 1F    MOV   A,[31]        (0197)     mov   A, [USB_t1]                  ; Get the transfer descriptor ROM Address MSB
0ADB: 58 20    MOV   X,[32]        (0198)     mov   X, [USB_t1+1]                ; Get the transfer descriptor ROM Address LSB
                                   (0199) 
0ADD: 81 66    JMP   0x0C44        (0200)     jmp   USB_GetTableEntry_Local_Hid
                                   (0201) ELSE
                                   (0202) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_APP_SUPPLIED)
                                   (0203) export  USB_CB_d2h_std_ifc_06
                                   (0204) USB_CB_d2h_std_ifc_06:
                                   (0205)     LJMP    APP_USB_CB_d2h_std_ifc_06
                                   (0206) ENDIF
                                   (0207) ENDIF
                                   (0208) ;-----------------------------------------------------------------------------
                                   (0209) ;  FUNCTION NAME: USB_CB_d2h_cls_ifc_01
                                   (0210) ;
                                   (0211) ;  DESCRIPTION:   Get Report
                                   (0212) ;
                                   (0213) ;****************************************************************
                                   (0214) ; HID CLASS INTERFACE IN REQUEST: Get_Report   
                                   (0215) ;****************************************************************
                                   (0216) ;
                                   (0217) ; bmRequestType  : (IN | CLASS | INTERFACE)       = A1h
                                   (0218) ; bRequest       : GET_REPORT                     = 01h    
                                   (0219) ; wValue         : REPORT TYPE | REPORT ID        = xxxxh  
                                   (0220) ; wIndex         : INTERFACE                      = --xxh
                                   (0221) ; wLength        : REPORT LENGTH                  = --xxh  
                                   (0222) ; 
                                   (0223) ; The GET_REPORT request allows the host to receive a report from 
                                   (0224) ; a specific interface via the control pipe. 
                                   (0225) ;
                                   (0226) ;****************************************************************
                                   (0227) ;-----------------------------------------------------------------------------
                                   (0228) ;
                                   (0229) ;  ARGUMENTS:
                                   (0230) ;
                                   (0231) ;  RETURNS:
                                   (0232) ;
                                   (0233) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0234) ;
                                   (0235) ;  THEORY of OPERATION or PROCEDURE:
                                   (0236) ;
                                   (0237) ;-----------------------------------------------------------------------------
                                   (0238) IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_UM_SUPPLIED)
                                   (0239) export  USB_CB_d2h_cls_ifc_01
                                   (0240) USB_CB_d2h_cls_ifc_01:
                                   (0241) 
0ADF: 90 90    CALL  0x0B71        (0242)     call    Find_Report
0AE1: 4B       SWAP  A,X
0AE2: B0 06    JNZ   0x0AE9        (0243)     NULL_PTR_CHECK USB_Not_Supported_Local_Hid
0AE4: 4B       SWAP  A,X
0AE5: A1 5B    JZ    0x0C41
0AE7: 80 02    JMP   0x0AEA
0AE9: 4B       SWAP  A,X
                                   (0244)     
0AEA: 81 59    JMP   0x0C44        (0245)     jmp     USB_GetTableEntry_Local_Hid
0AEC: 00       SWI   
0AED: 01 00    ADD   A,0
0AEF: 01 00    ADD   A,0
0AF1: 3E 00    MVI   A,[0]
0AF3: 00       SWI   
0AF4: DE 01    JNC   0x08F6
0AF6: 00       SWI   
0AF7: 01 00    ADD   A,0
0AF9: 3F 00    MVI   [0],A
0AFB: 00       SWI   
0AFC: DE 5D    JNC   0x095A
                                   (0246) ELSE
                                   (0247) IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_APP_SUPPLIED)
                                   (0248) export  USB_CB_d2h_cls_ifc_01
                                   (0249) USB_CB_d2h_cls_ifc_01:
                                   (0250)     LJMP    APP_USB_CB_d2h_cls_ifc_01
                                   (0251) ENDIF
                                   (0252) ENDIF
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;  FUNCTION NAME: USB_CB_d2h_cls_ifc_02
                                   (0255) ;
                                   (0256) ;  DESCRIPTION:   Get Idle
                                   (0257) ;
                                   (0258) ;****************************************************************
                                   (0259) ; HID CLASS INTERFACE IN REQUEST: Get_Idle
                                   (0260) ;****************************************************************
                                   (0261) ;
                                   (0262) ; bmRequestType  : (OUT | CLASS | INTERFACE)      = A1h
                                   (0263) ; bRequest       : GET_IDLE                       = 02h    
                                   (0264) ; wValue         : REPORT ID                      = 00xxh  
                                   (0265) ; wIndex         : INTERFACE                      = --xxh
                                   (0266) ; wLength        : Report Size                    = 0001h  
                                   (0267) ; 
                                   (0268) ; The GET_IDLE request reads the current idle rate for a given 
                                   (0269) ; input report on a specific interface. 
                                   (0270) ;
                                   (0271) ;****************************************************************
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:
                                   (0275) ;
                                   (0276) ;  RETURNS:
                                   (0277) ;
                                   (0278) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0279) ;
                                   (0280) ;  THEORY of OPERATION or PROCEDURE:
                                   (0281) ;
                                   (0282) ;-----------------------------------------------------------------------------
                                   (0283) IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_UM_SUPPLIED)
                                   (0284) .LITERAL
                                   (0285) GetSetIdleTable:
                                   (0286)     TD_START_TABLE  1h                 ; One entry for each interface
                                   (0287)     TD_ENTRY        USB_DS_RAM, 1, USB_IdleReload,   NULL_PTR  ; Reuse the transfer buffer
                                   (0288)     TD_ENTRY        USB_DS_RAM, 1, USB_IdleReload+1, NULL_PTR  ; Reuse the transfer buffer
                                   (0289) .ENDLITERAL
                                   (0290) export  USB_CB_d2h_cls_ifc_02
                                   (0291) USB_CB_d2h_cls_ifc_02:
0AFE: 5A 39    MOV   [57],X        (0292)     mov   A, REG[USB_EP0DATA+wValueLo] ; Get the report number
0B00: 00       SWI                 (0293)     cmp   A, 0                         ; We don't support report by report idle
0B01: B1 3F    JNZ   0x0C41        (0294)     jnz   USB_Not_Supported_Local_Hid
                                   (0295) 
0B03: 5D 5C    MOV   A,REG[92]     (0296)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0B05: 39 01    CMP   A,1           (0297)     cmp   A, 1h                        ; We don't support report by report idle
0B07: D1 39    JNC   0x0C41        (0298)     jnc   USB_Not_Supported_Local_Hid
                                   (0299) 
                                   (0300) 
0B09: 53 1E    MOV   [30],A        (0301)     mov   [USB_t2], A                  ; Use the UM temp var--Selector
0B0B: 50 0A    MOV   A,10          (0302)     mov   A,>GetSetIdleTable           ; Get the ROM Address MSB
0B0D: 57 EC    MOV   X,236         (0303)     mov   X,<GetSetIdleTable           ; Get the ROM Address LSB
                                   (0304)     
0B0F: 81 34    JMP   0x0C44        (0305)     jmp   USB_GetTableEntry_Local_Hid
0B11: 01 00    ADD   A,0
0B13: 00       SWI   
0B14: 01 0B    ADD   A,11
0B16: 22 00    AND   A,[0]
0B18: 00       SWI   
0B19: DE 00    JNC   0x091A
0B1B: 00       SWI   
0B1C: 01 0B    ADD   A,11
0B1E: 23 00    AND   A,[X+0]
0B20: 00       SWI   
0B21: DE 00    JNC   0x0922
0B23: 01 5D    ADD   A,93
                                   (0306) ELSE
                                   (0307) IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_APP_SUPPLIED)
                                   (0308) export  USB_CB_d2h_cls_ifc_02
                                   (0309) USB_CB_d2h_cls_ifc_02:
                                   (0310)     LJMP    APP_USB_CB_d2h_cls_ifc_02
                                   (0311) ENDIF
                                   (0312) ENDIF
                                   (0313) ;-----------------------------------------------------------------------------
                                   (0314) ;  FUNCTION NAME: USB_CB_d2h_cls_ifc_03
                                   (0315) ;
                                   (0316) ;  DESCRIPTION:   Get Protocol
                                   (0317) ;
                                   (0318) ;****************************************************************
                                   (0319) ; HID CLASS INTERFACE IN REQUEST: Get_Protocol
                                   (0320) ;****************************************************************
                                   (0321) ;
                                   (0322) ; bmRequestType  : (OUT | CLASS | INTERFACE)      = A1h
                                   (0323) ; bRequest       : GET_PROTOCOL                   = 03h    
                                   (0324) ; wValue         : RESERVED                       = 0000h  
                                   (0325) ; wIndex         : INTERFACE                      = --xxh
                                   (0326) ; wLength        : SIZEOF_INTERFACE_PROTOCOL      = 0001h  
                                   (0327) ; 
                                   (0328) ; The GET_PROTOCOL request reads which protocol is currently 
                                   (0329) ; active.
                                   (0330) ;
                                   (0331) ;****************************************************************
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:
                                   (0335) ;
                                   (0336) ;  RETURNS:
                                   (0337) ;
                                   (0338) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0339) ;
                                   (0340) ;  THEORY of OPERATION or PROCEDURE:
                                   (0341) ;
                                   (0342) ;-----------------------------------------------------------------------------
                                   (0343) IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_UM_SUPPLIED)
                                   (0344) .LITERAL
                                   (0345) GetProtocolTable:
                                   (0346)     TD_START_TABLE  2                  ; One entry for BOOT/One entry for REPORT
                                   (0347)     TD_ENTRY        USB_DS_ROM, 1, ROM_ZERO,   NULL_PTR  ; Simply use a a hard coded zero or one
                                   (0348)     TD_ENTRY        USB_DS_ROM, 1, ROM_ONE,    NULL_PTR  ; 
                                   (0349) ROM_ZERO:   DB  0
                                   (0350) ROM_ONE:    DB  1
                                   (0351) .ENDLITERAL
                                   (0352) export  USB_CB_d2h_cls_ifc_03
                                   (0353) USB_CB_d2h_cls_ifc_03:
0B25: 5C       MOV   X,A           (0354)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0B26: 39 01    CMP   A,1           (0355)     cmp   A, 1h                        ; Range check
0B28: D1 18    JNC   0x0C41        (0356)     jnc   USB_Not_Supported_Local_Hid
                                   (0357) 
0B2A: 5C       MOV   X,A           (0358)     mov   X, A                         ; Get the protocol for the requested interface
0B2B: 52 40    MOV   A,[X+64]      (0359)     mov   A, [X + USB_Protocol]        ; 
                                   (0360) 
0B2D: 53 1E    MOV   [30],A        (0361)     mov   [USB_t2], A                  ; Use the UM temp var--Selector
                                   (0362) 
0B2F: 50 0B    MOV   A,11          (0363)     mov   A,>GetProtocolTable          ; Get the ROM Address MSB
0B31: 57 11    MOV   X,17          (0364)     mov   X,<GetProtocolTable          ; Get the ROM Address LSB
                                   (0365)     
0B33: 81 10    JMP   0x0C44        (0366)     jmp   USB_GetTableEntry_Local_Hid
                                   (0367) ELSE
                                   (0368) IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_APP_SUPPLIED)
                                   (0369) export  USB_CB_d2h_cls_ifc_03
                                   (0370) USB_CB_d2h_cls_ifc_03:
                                   (0371)     LJMP    APP_USB_CB_d2h_cls_ifc_03
                                   (0372) ENDIF
                                   (0373) ENDIF
                                   (0374) ;-----------------------------------------------------------------------------
                                   (0375) ;  FUNCTION NAME: USB_CB_h2d_cls_ifc_09
                                   (0376) ;
                                   (0377) ;  DESCRIPTION:   Set Report
                                   (0378) ;
                                   (0379) ;****************************************************************
                                   (0380) ; HID CLASS INTERFACE OUT REQUEST: Set_Report
                                   (0381) ;****************************************************************
                                   (0382) ;
                                   (0383) ; bmRequestType   : (OUT | CLASS | INTERFACE)      = 21h
                                   (0384) ; bRequest        : SET_REPORT                     = 09h    
                                   (0385) ; wValue          : REPORT TYPE | REPORT ID        = xxxxh  
                                   (0386) ; wIndex          : INTERFACE                      = --xxh
                                   (0387) ; wLength         : REPORT LENGTH                  = --xxh  
                                   (0388) ; 
                                   (0389) ; The SET_REPORT request allows the host to send a report to the 
                                   (0390) ; device, possibly setting the state of input, output or feature 
                                   (0391) ; controls. 
                                   (0392) ;
                                   (0393) ;****************************************************************
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS:
                                   (0397) ;
                                   (0398) ;  RETURNS:
                                   (0399) ;
                                   (0400) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0401) ;
                                   (0402) ;  THEORY of OPERATION or PROCEDURE:
                                   (0403) ;
                                   (0404) ;-----------------------------------------------------------------------------
                                   (0405) IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_UM_SUPPLIED)
                                   (0406) export  USB_CB_h2d_cls_ifc_09
                                   (0407) USB_CB_h2d_cls_ifc_09:
0B35: 90 3A    CALL  0x0B71        (0408)     CALL    Find_Report
0B37: 4B       SWAP  A,X
0B38: B0 06    JNZ   0x0B3F        (0409)     NULL_PTR_CHECK USB_Not_Supported_Local_Hid
0B3A: 4B       SWAP  A,X
0B3B: A1 05    JZ    0x0C41
0B3D: 80 02    JMP   0x0B40
0B3F: 4B       SWAP  A,X
                                   (0410)     
0B40: 81 03    JMP   0x0C44        (0411)     JMP     USB_GetTableEntry_Local_Hid
                                   (0412) ELSE
                                   (0413) IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_APP_SUPPLIED)
                                   (0414) export  USB_CB_h2d_cls_ifc_09
                                   (0415) USB_CB_h2d_cls_ifc_09:
                                   (0416)     LJMP    APP_USB_CB_h2d_cls_ifc_09
                                   (0417) ENDIF
                                   (0418) ENDIF
                                   (0419) ;-----------------------------------------------------------------------------
                                   (0420) ;  FUNCTION NAME: USB_CB_h2d_cls_ifc_10
                                   (0421) ;
                                   (0422) ;  DESCRIPTION:   Set Idle
                                   (0423) ;
                                   (0424) ;****************************************************************
                                   (0425) ; HID CLASS INTERFACE OUT REQUEST: Set_Idle
                                   (0426) ;****************************************************************
                                   (0427) ;
                                   (0428) ; bmRequestType   : (OUT | CLASS | INTERFACE)      = 21h
                                   (0429) ; bRequest        : SET_IDLE                       = 0Ah    
                                   (0430) ; wValue          : DURATION | REPORT ID           = xxxxh  
                                   (0431) ; wIndex          : INTERFACE                      = --xxh
                                   (0432) ; wLength         : ZERO                           = 0000h  
                                   (0433) ; 
                                   (0434) ; The SET_IDLE request silences a particular input report (or all 
                                   (0435) ; input reports) on a specific interface until a new event occurs 
                                   (0436) ; or the specified amount of time passes. 
                                   (0437) ;
                                   (0438) ;****************************************************************
                                   (0439) ; Note: This function does not support multiple reports per interface.
                                   (0440) ;****************************************************************
                                   (0441) ;-----------------------------------------------------------------------------
                                   (0442) ;
                                   (0443) ;  ARGUMENTS:
                                   (0444) ;
                                   (0445) ;  RETURNS:
                                   (0446) ;
                                   (0447) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0448) ;
                                   (0449) ;  THEORY of OPERATION or PROCEDURE:
                                   (0450) ;
                                   (0451) ;-----------------------------------------------------------------------------
                                   (0452) IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_UM_SUPPLIED)
                                   (0453) export  USB_CB_h2d_cls_ifc_10
                                   (0454) USB_CB_h2d_cls_ifc_10:
0B42: 5D 5A    MOV   A,REG[90]     (0455)     mov   A, REG[USB_EP0DATA+wValueLo] ; Get the report number
0B44: 39 00    CMP   A,0           (0456)     cmp   A, 0                         ; We don't support report by report idle
0B46: B0 FA    JNZ   0x0C41        (0457)     jnz   USB_Not_Supported_Local_Hid
                                   (0458) 
0B48: 5D 5C    MOV   A,REG[92]     (0459)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0B4A: 39 01    CMP   A,1           (0460)     cmp   A, 1h                        ; Range Check
0B4C: D0 F4    JNC   0x0C41        (0461)     jnc   USB_Not_Supported_Local_Hid
                                   (0462) 
0B4E: 5C       MOV   X,A           (0463)     mov   X, A                         ; Interface Number becomes an index
                                   (0464) 
0B4F: 5D 5B    MOV   A,REG[91]     (0465)     mov   A, REG[USB_EP0DATA+wValueHi] ; Get the duration
                                   (0466) 
0B51: 54 3E    MOV   [X+62],A      (0467)     mov   [X+USB_IdleReload], A        ; Save the reload immediately
0B53: 39 00    CMP   A,0           (0468)     cmp   A, 0                         ; Is this request setting the duration to indefinite?
0B55: A0 06    JZ    0x0B5C        (0469)     jz    .reload                      ; If so, reload the timer 
                                   (0470) 
                                   (0471)     ; Otherwise, we need to determine if we reset the current expiry
                                   (0472)     ; (HID Spec says to send the next report if we are within 4 ms (1 count)
                                   (0473)     ; of sending the next report
0B57: 3D 3F 01 CMP   [X+63],1      (0474)     cmp   [X+USB_IdleTimer], 1         ; Within 4 ms?
0B5A: A0 03    JZ    0x0B5E        (0475)     jz    .done                        ; Jump to let the timer expire "naturally" 
                                   (0476) 
                                   (0477) ; Jump or Flow here to reload the timer
                                   (0478) .reload:
0B5C: 54 3F    MOV   [X+63],A      (0479)     mov   [x+USB_IdleTimer], A         ; Reload the timer
                                   (0480)             
                                   (0481) .done:
0B5E: 8B EB    JMP   0x074A        (0482)     jmp   USB_NoDataStageControlTransfer
                                   (0483) ELSE
                                   (0484) IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_APP_SUPPLIED)
                                   (0485) export  USB_CB_h2d_cls_ifc_10
                                   (0486) USB_CB_h2d_cls_ifc_10:
                                   (0487)     LJMP    APP_USB_CB_h2d_cls_ifc_10
                                   (0488) ENDIF
                                   (0489) ENDIF
                                   (0490) ;-----------------------------------------------------------------------------
                                   (0491) ;  FUNCTION NAME: USB_CB_h2d_cls_ifc_11
                                   (0492) ;
                                   (0493) ;  DESCRIPTION:   Set Idle
                                   (0494) ;
                                   (0495) ;****************************************************************
                                   (0496) ; HID CLASS INTERFACE OUT REQUEST: Set_Protocol
                                   (0497) ;****************************************************************
                                   (0498) ;
                                   (0499) ; bmRequestType  : (OUT | CLASS | INTERFACE)      = 21h
                                   (0500) ; bRequest       : SET_PROTOCOL                   = 0Bh    
                                   (0501) ; wValue         : DURATION | REPORT ID           = xxxxh  
                                   (0502) ; wIndex         : PROTOCOL                       = --xxh
                                   (0503) ; wLength        : ZERO                           = 0000h  
                                   (0504) ; 
                                   (0505) ; The SET_PROTOCOL request switches between the boot protocol and 
                                   (0506) ; the report protocol (or vice versa). 
                                   (0507) ;
                                   (0508) ;****************************************************************
                                   (0509) ;-----------------------------------------------------------------------------
                                   (0510) ;
                                   (0511) ;  ARGUMENTS:
                                   (0512) ;
                                   (0513) ;  RETURNS:
                                   (0514) ;
                                   (0515) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0516) ;
                                   (0517) ;  THEORY of OPERATION or PROCEDURE:
                                   (0518) ;
                                   (0519) ;-----------------------------------------------------------------------------
                                   (0520) IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_UM_SUPPLIED)
                                   (0521) export  USB_CB_h2d_cls_ifc_11
                                   (0522) USB_CB_h2d_cls_ifc_11:
0B60: 5D 5C    MOV   A,REG[92]     (0523)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0B62: 39 01    CMP   A,1           (0524)     cmp   A, 1h                        ; Range check
0B64: D0 DC    JNC   0x0C41        (0525)     jnc   USB_Not_Supported_Local_Hid
                                   (0526) 
0B66: 5C       MOV   X,A           (0527)     mov   X, A                         ; Save the interface number
                                   (0528) 
0B67: 5D 5A    MOV   A,REG[90]     (0529)     mov   A, REG[USB_EP0DATA+wValueLo] ; Get the protocol
0B69: 39 02    CMP   A,2           (0530)     cmp   A, (1+1)                     ; Must be zero or one
0B6B: D0 D5    JNC   0x0C41        (0531)     jnc   USB_Not_Supported_Local_Hid
                                   (0532) 
0B6D: 54 40    MOV   [X+64],A      (0533)     mov   [X + USB_Protocol], A        ; Save the new protocol
                                   (0534) 
0B6F: 8B DA    JMP   0x074A        (0535)     jmp   USB_NoDataStageControlTransfer
                                   (0536) ELSE
                                   (0537) IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_APP_SUPPLIED)
                                   (0538) export  USB_CB_h2d_cls_ifc_11
                                   (0539) USB_CB_h2d_cls_ifc_11:
                                   (0540)     LJMP    APP_USB_CB_h2d_cls_ifc_11
                                   (0541) ENDIF
                                   (0542) ENDIF
                                   (0543) ;-----------------------------------------------------------------------------
                                   (0544) ;  FUNCTION NAME:   Find_Report
                                   (0545) ;
                                   (0546) ;  DESCRIPTION:     Scan the HID Report Tree and return a pointer to the 
                                   (0547) ;                   HID Report Transfer Descriptor (TD) or NULL
                                   (0548) ;                   This function is called in during the processing of
                                   (0549) ;                   GET_REPORT or SET_REPORT HID Class Requests.
                                   (0550) ;
                                   (0551) ;-----------------------------------------------------------------------------
                                   (0552) ;
                                   (0553) ;  ARGUMENTS:       
                                   (0554) ;
                                   (0555) ;  RETURNS:
                                   (0556) ;
                                   (0557) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0558) ;
                                   (0559) ;  THEORY of OPERATION or PROCEDURE:
                                   (0560) ;
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) export USB_cls_hid_Find_Report
                                   (0563) USB_cls_hid_Find_Report:
                                   (0564) Find_Report:
0B71: 90 76    CALL  0x0BE9        (0565)     call  USB_GetInterfaceLookupTable  ; Point the the interface lookup table
                                   (0566)     ; The first entry of the table point to the report table.
0B73: 55 1E 1F MOV   [30],31       (0567)     mov   [USB_t2],USB_t1              ; Set the GETWORD destination 
0B76: 9D 19    CALL  0x0891        (0568)     call  USB_GETWORD                  ; Get the pointer to the transfer descriptor table
                                   (0569)                                        ; ITempW has the address
0B78: 5D 5C    MOV   A,REG[92]     (0570)     mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
0B7A: 53 1E    MOV   [30],A        (0571)     mov   [USB_t2], A                  ; Use the UM temp var--Selector
0B7C: 51 1F    MOV   A,[31]        (0572)     mov   A, [USB_t1]                  ; Get the Table Address MSB
0B7E: 58 20    MOV   X,[32]        (0573)     mov   X, [USB_t1+1]                ; Get the Table Address LSB
                                   (0574) 
0B80: 65 1E    ASL   [30]          (0575)     asl   [USB_t2] ; Convert the index to offset
                                   (0576) 
0B82: 4B       SWAP  A,X           (0577)     swap  A, X
0B83: 02 1E    ADD   A,[30]        (0578)     add   A, [USB_t2]
0B85: 4B       SWAP  A,X           (0579)     swap  A, X
0B86: 09 00    ADC   A,0           (0580)     adc   A, 0                         ; A:X now points to the table entry we want
0B88: 71 40    OR    F,64
                                   (0581) 
                                   (0582) ; Get the pointer to the Report Type Table
0B8A: 08       PUSH  A             (0583)     GET_WORD
0B8B: 08       PUSH  A
0B8C: 28       ROMX  
0B8D: 10       PUSH  X
0B8E: 4F       MOV   X,SP
0B8F: 54 FD    MOV   [X-3],A
0B91: 20       POP   X
0B92: 18       POP   A
0B93: 75       INC   X
0B94: 09 00    ADC   A,0
0B96: 28       ROMX  
0B97: 5C       MOV   X,A
0B98: 18       POP   A
0B99: 70 3F    AND   F,63
0B9B: 71 00    OR    F,0
                                   (0584) 
                                   (0585) ; Dereference to the requested Report Type
0B9D: 08       PUSH  A             (0586)     push  A                            ; Don't loose the pointer MSB
0B9E: 5D 5B    MOV   A,REG[91]     (0587)     mov   A, REG[USB_EP0DATA+wValueHi] ; Get the Report Type
0BA0: 78       DEC   A             (0588)     dec   A                            ; Make it 0 based
0BA1: 53 1E    MOV   [30],A        (0589)     mov   [USB_t2], A                  ; Use the UM temp var--Selector
0BA3: 18       POP   A             (0590)     pop   A                            ; Get the MSB back
0BA4: 08       PUSH  A             (0591)     push  A                            ; Don't loose the pointer MSB
0BA5: 28       ROMX                (0592)     romx                               ; Get the table size
0BA6: 3A 1E    CMP   A,[30]        (0593)     cmp   A, [USB_t2]                  ; Range check
0BA8: C0 3B    JC    0x0BE4        (0594)     jc    .not_supported_pop_1
                                   (0595)         
0BAA: 18       POP   A             (0596)     pop   A                            ; Get the MSB back
0BAB: 75       INC   X             (0597)     inc   X                            ; Point to the next  entry
0BAC: 09 00    ADC   A,0           (0598)     adc   A, 0                         ;
0BAE: 65 1E    ASL   [30]
                                   (0599) 
0BB0: 65 1E    ASL   [30]          (0600)     LT_INDEX_TO_OFFSET USB_t2          ; Convert the index to offset
                                   (0601) 
0BB2: 4B       SWAP  A,X           (0602)     swap  A, X
0BB3: 02 1E    ADD   A,[30]        (0603)     add   A, [USB_t2]
0BB5: 4B       SWAP  A,X           (0604)     swap  A, X
0BB6: 09 00    ADC   A,0           (0605)     adc   A, 0                         ; A:X now points to the table entry we want
0BB8: 71 40    OR    F,64
                                   (0606) ; Get the pointer to the requested Report Table
0BBA: 08       PUSH  A             (0607)     GET_WORD                            ; A:X points to the 
0BBB: 08       PUSH  A
0BBC: 28       ROMX  
0BBD: 10       PUSH  X
0BBE: 4F       MOV   X,SP
0BBF: 54 FD    MOV   [X-3],A
0BC1: 20       POP   X
0BC2: 18       POP   A
0BC3: 75       INC   X
0BC4: 09 00    ADC   A,0
0BC6: 28       ROMX  
0BC7: 5C       MOV   X,A
0BC8: 18       POP   A
0BC9: 70 3F    AND   F,63
0BCB: 71 00    OR    F,0
0BCD: 4B       SWAP  A,X
                                   (0608) 
0BCE: B0 06    JNZ   0x0BD5        (0609)     NULL_PTR_CHECK .not_supported      ; Null Table entries indicated not supported
0BD0: 4B       SWAP  A,X
0BD1: A0 13    JZ    0x0BE5
0BD3: 80 02    JMP   0x0BD6
0BD5: 4B       SWAP  A,X
                                   (0610) ; Dereference to the requested TRANSFER DESCRIPTOR
0BD6: 08       PUSH  A             (0611)     push  A                            ; Don't loose the pointer MSB
0BD7: 5D 5A    MOV   A,REG[90]     (0612)     mov   A, REG[USB_EP0DATA+wValueLo] ; Get the Report ID
0BD9: 53 1E    MOV   [30],A        (0613)     mov   [USB_t2], A                  ; Use the UM temp var--Selector
0BDB: 18       POP   A             (0614)     pop   A                            ; Get the MSB back
0BDC: 08       PUSH  A             (0615)     push  A                            ; Don't loose the pointer MSB
0BDD: 28       ROMX                (0616)     romx                               ; Get the table size
0BDE: 3A 1E    CMP   A,[30]        (0617)     cmp   A, [USB_t2]                  ; Range check
0BE0: C0 03    JC    0x0BE4        (0618)     jc    .not_supported_pop_1
                                   (0619)         
0BE2: 18       POP   A             (0620)     pop   A                            ; Get the MSB back
                                   (0621) 
0BE3: 7F       RET                 (0622)     ret                                ; Finished A:X point to the TD
                                   (0623) 
                                   (0624) .not_supported_pop_1:
0BE4: 18       POP   A             (0625)     pop   A                            ; Restore the stack
                                   (0626) .not_supported:
0BE5: 50 00    MOV   A,0           (0627)     mov   A, 0                         ; Return a null pointer
0BE7: 5C       MOV   X,A           (0628)     mov   X, A                         ; 
0BE8: 7F       RET                 (0629)     ret
                                   (0630) 
                                   (0631) ;-----------------------------------------------------------------------------
                                   (0632) ;  FUNCTION NAME: USB_GetInterfaceLookupTable
                                   (0633) ;
                                   (0634) ;  DESCRIPTION:   Point to the interface lookup table
                                   (0635) ;
                                   (0636) ;-----------------------------------------------------------------------------
                                   (0637) ;
                                   (0638) ;  ARGUMENTS:
                                   (0639) ;
                                   (0640) ;  RETURNS:
                                   (0641) ;
                                   (0642) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0643) ;
                                   (0644) ;  THEORY of OPERATION or PROCEDURE:
                                   (0645) ;
                                   (0646) ;-----------------------------------------------------------------------------
                                   (0647) export  USB_GetInterfaceLookupTable:
                                   (0648) USB_GetInterfaceLookupTable:
0BE9: 9C C8    CALL  0x08B3        (0649)     call  USB_GET_CONFIG_TABLE_ENTRY   ; Get the CONFIG_LOOKUP entry
0BEB: 4B       SWAP  A,X           (0650)     swap  A, X                         ; Second entry points to the HID_LOOKUP table
0BEC: 01 02    ADD   A,2           (0651)     add   A, 2                         ; So add two
0BEE: 4B       SWAP  A,X           (0652)     swap  A, X                         ; 
0BEF: 09 00    ADC   A,0           (0653)     adc   A, 0                         ; Don't forget the carry
0BF1: 55 1E 1F MOV   [30],31       (0654)     mov   [USB_t2],USB_t1              ; Set the GETWORD destination 
0BF4: 9C 9B    CALL  0x0891        (0655)     call  USB_GETWORD                  ; Get the pointer to the HID_LOOKUP table
                                   (0656)                                        ; ITempW has the address
0BF6: 51 1F    MOV   A,[31]        (0657)     mov   A, [USB_t1]                  ; Get the table address MSB
0BF8: 58 20    MOV   X,[32]        (0658)     mov   X, [USB_t1+1]                ; Get the table address LSB
0BFA: 7F       RET                 (0659)     ret
                                   (0660) 
                                   (0661) 
                                   (0662) 
                                   (0663) 
                                   (0664) ;-----------------------------------------------------------------------------
                                   (0665) ;-----------------------------------------------------------------------------
                                   (0666) ;  USB 2nd Tier Dispactch Jump Tables for HID Class Requests (based on bRequest)
                                   (0667) ;-----------------------------------------------------------------------------
                                   (0668) ;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
                                   (0669) ;
                                   (0670) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                   (0671) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                   (0672) ;
                                   (0673) ;-----------------------------------------------------------------------------
                                   (0674) ;
                                   (0675) ;  ARGUMENTS:
                                   (0676) ;
                                   (0677) ;  RETURNS:
                                   (0678) ;
                                   (0679) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0680) ;
                                   (0681) ;  THEORY of OPERATION or PROCEDURE:
                                   (0682) ;
                                   (0683) ;-----------------------------------------------------------------------------
                                   (0684) ;-----------------------------------------------------------------------------
                                   (0685) USB_DT_h2d_cls_ifc:
                                   (0686) ;-----------------------------------------------------------------------------
                                   (0687) 
0BFB: 80 45    JMP   0x0C41        (0688)     jmp     USB_CB_h2d_cls_ifc_00
0BFD: 80 43    JMP   0x0C41        (0689)     jmp     USB_CB_h2d_cls_ifc_01
0BFF: 80 41    JMP   0x0C41        (0690)     jmp     USB_CB_h2d_cls_ifc_02
0C01: 80 3F    JMP   0x0C41        (0691)     jmp     USB_CB_h2d_cls_ifc_03
0C03: 80 3D    JMP   0x0C41        (0692)     jmp     USB_CB_h2d_cls_ifc_04
0C05: 80 3B    JMP   0x0C41        (0693)     jmp     USB_CB_h2d_cls_ifc_05
0C07: 80 39    JMP   0x0C41        (0694)     jmp     USB_CB_h2d_cls_ifc_06
0C09: 80 37    JMP   0x0C41        (0695)     jmp     USB_CB_h2d_cls_ifc_07
0C0B: 80 35    JMP   0x0C41        (0696)     jmp     USB_CB_h2d_cls_ifc_08
0C0D: 8F 27    JMP   0x0B35        (0697)     jmp     USB_CB_h2d_cls_ifc_09
0C0F: 8F 32    JMP   0x0B42        (0698)     jmp     USB_CB_h2d_cls_ifc_10
0C11: 8F 4E    JMP   0x0B60        (0699)     jmp     USB_CB_h2d_cls_ifc_11
0C13: 80 2D    JMP   0x0C41        (0700)     jmp     USB_CB_h2d_cls_ifc_12
                                   (0701) 
                                   (0702) USB_DT_h2d_cls_ifc_End:
                                   (0703) USB_DT_h2d_cls_ifc_Size: equ (USB_DT_h2d_cls_ifc_End-USB_DT_h2d_cls_ifc) / 2
                                   (0704) USB_DT_h2d_cls_ifc_Dispatch::
0C15: 3C 01 00 CMP   [1],0         (0705)     CMP     [USB_Configuration], 0     ; Is the device configured?
0C18: B0 03    JNZ   0x0C1C        (0706)     JNZ     .configured                ; Jump on configured
0C1A: 80 26    JMP   0x0C41        (0707)     JMP     USB_Not_Supported_Local_Hid  ; Stall the request if not configured
                                   (0708) ; Jump here if the device is configured
                                   (0709) .configured:
0C1C: 5D 59    MOV   A,REG[89]     (0710)     MOV     A, REG[USB_EP0DATA + bRequest]       ; Get the request number
0C1E: 39 0D    CMP   A,13
0C20: D0 04    JNC   0x0C25        (0711)     DISPATCHER USB_DT_h2d_cls_ifc, USB_DT_h2d_cls_ifc_Size, USB_Not_Supported_Local_Hid 
0C22: 64       ASL   A
0C23: EF D7    JACC  0x0BFB
0C25: 80 1B    JMP   0x0C41
                                   (0712) 
                                   (0713) ;-----------------------------------------------------------------------------
                                   (0714) USB_DT_d2h_cls_ifc:
                                   (0715) ;-----------------------------------------------------------------------------
                                   (0716) 
0C27: 80 19    JMP   0x0C41        (0717)     jmp     USB_CB_d2h_cls_ifc_00
0C29: 8E B5    JMP   0x0ADF        (0718)     jmp     USB_CB_d2h_cls_ifc_01
0C2B: 8E D1    JMP   0x0AFD        (0719)     jmp     USB_CB_d2h_cls_ifc_02
0C2D: 8E F6    JMP   0x0B24        (0720)     jmp     USB_CB_d2h_cls_ifc_03
                                   (0721) 
                                   (0722) USB_DT_d2h_cls_ifc_End:
                                   (0723) USB_DT_d2h_cls_ifc_Size: equ (USB_DT_d2h_cls_ifc_End-USB_DT_d2h_cls_ifc) / 2
                                   (0724) USB_DT_d2h_cls_ifc_Dispatch::
0C2F: 3C 01 00 CMP   [1],0         (0725)     CMP     [USB_Configuration], 0     ; Is the device configured?
0C32: B0 03    JNZ   0x0C36        (0726)     JNZ     .configured                ; Jump on configured
0C34: 80 0C    JMP   0x0C41        (0727)     JMP     USB_Not_Supported_Local_Hid  ; Stall the request if not configured
                                   (0728) ; Jump here if the device is configured
                                   (0729) .configured:
0C36: 5D 59    MOV   A,REG[89]     (0730)     MOV     A, REG[USB_EP0DATA + bRequest]       ; Get the request number
0C38: 39 04    CMP   A,4
0C3A: D0 04    JNC   0x0C3F        (0731)     DISPATCHER USB_DT_d2h_cls_ifc, USB_DT_d2h_cls_ifc_Size, USB_Not_Supported_Local_Hid 
0C3C: 64       ASL   A
0C3D: EF E9    JACC  0x0C27
0C3F: 80 01    JMP   0x0C41
                                   (0732) 
                                   (0733) IF (USB_CB_SRC_d2h_cls_ifc_00 & USB_NOT_SUPPORTED)
                                   (0734) export  USB_CB_d2h_cls_ifc_00
                                   (0735) USB_CB_d2h_cls_ifc_00:
                                   (0736) ENDIF
                                   (0737) IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_NOT_SUPPORTED)
                                   (0738) export  USB_CB_d2h_cls_ifc_01
                                   (0739) USB_CB_d2h_cls_ifc_01:
                                   (0740) ENDIF
                                   (0741) IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_NOT_SUPPORTED)
                                   (0742) export  USB_CB_d2h_cls_ifc_02
                                   (0743) USB_CB_d2h_cls_ifc_02:
                                   (0744) ENDIF
                                   (0745) IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_NOT_SUPPORTED)
                                   (0746) export  USB_CB_d2h_cls_ifc_03
                                   (0747) USB_CB_d2h_cls_ifc_03:
                                   (0748) ENDIF
                                   (0749) IF (USB_CB_SRC_h2d_cls_ifc_00 & USB_NOT_SUPPORTED)
                                   (0750) export  USB_CB_h2d_cls_ifc_00
                                   (0751) USB_CB_h2d_cls_ifc_00:
                                   (0752) ENDIF
                                   (0753) IF (USB_CB_SRC_h2d_cls_ifc_01 & USB_NOT_SUPPORTED)
                                   (0754) export  USB_CB_h2d_cls_ifc_01
                                   (0755) USB_CB_h2d_cls_ifc_01:
                                   (0756) ENDIF
                                   (0757) IF (USB_CB_SRC_h2d_cls_ifc_02 & USB_NOT_SUPPORTED)
                                   (0758) export  USB_CB_h2d_cls_ifc_02
                                   (0759) USB_CB_h2d_cls_ifc_02:
                                   (0760) ENDIF
                                   (0761) IF (USB_CB_SRC_h2d_cls_ifc_03 & USB_NOT_SUPPORTED)
                                   (0762) export  USB_CB_h2d_cls_ifc_03
                                   (0763) USB_CB_h2d_cls_ifc_03:
                                   (0764) ENDIF
                                   (0765) IF (USB_CB_SRC_h2d_cls_ifc_04 & USB_NOT_SUPPORTED)
                                   (0766) export  USB_CB_h2d_cls_ifc_04
                                   (0767) USB_CB_h2d_cls_ifc_04:
                                   (0768) ENDIF
                                   (0769) IF (USB_CB_SRC_h2d_cls_ifc_05 & USB_NOT_SUPPORTED)
                                   (0770) export  USB_CB_h2d_cls_ifc_05
                                   (0771) USB_CB_h2d_cls_ifc_05:
                                   (0772) ENDIF
                                   (0773) IF (USB_CB_SRC_h2d_cls_ifc_06 & USB_NOT_SUPPORTED)
                                   (0774) export  USB_CB_h2d_cls_ifc_06
                                   (0775) USB_CB_h2d_cls_ifc_06:
                                   (0776) ENDIF
                                   (0777) IF (USB_CB_SRC_h2d_cls_ifc_07 & USB_NOT_SUPPORTED)
                                   (0778) export  USB_CB_h2d_cls_ifc_07
                                   (0779) USB_CB_h2d_cls_ifc_07:
                                   (0780) ENDIF
                                   (0781) IF (USB_CB_SRC_h2d_cls_ifc_08 & USB_NOT_SUPPORTED)
                                   (0782) export  USB_CB_h2d_cls_ifc_08
                                   (0783) USB_CB_h2d_cls_ifc_08:
                                   (0784) ENDIF
                                   (0785) IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_NOT_SUPPORTED)
                                   (0786) export  USB_CB_h2d_cls_ifc_09
                                   (0787) USB_CB_h2d_cls_ifc_09:
                                   (0788) ENDIF
                                   (0789) IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_NOT_SUPPORTED)
                                   (0790) export  USB_CB_h2d_cls_ifc_10
                                   (0791) USB_CB_h2d_cls_ifc_10:
                                   (0792) ENDIF
                                   (0793) IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_NOT_SUPPORTED)
                                   (0794) export  USB_CB_h2d_cls_ifc_11
                                   (0795) USB_CB_h2d_cls_ifc_11:
                                   (0796) ENDIF
                                   (0797) IF (USB_CB_SRC_h2d_cls_ifc_12 & USB_NOT_SUPPORTED)
                                   (0798) export  USB_CB_h2d_cls_ifc_12
                                   (0799) USB_CB_h2d_cls_ifc_12:
                                   (0800) ENDIF
                                   (0801) 
                                   (0802) USB_Not_Supported_Local_Hid:
0C41: 7D 03 C1 LJMP  0x03C1        (0803)     LJMP     USB_Not_Supported
                                   (0804) 
                                   (0805) USB_GetTableEntry_Local_Hid:
0C44: 7D 08 5D LJMP  0x085D        (0806)     LJMP     USB_GetTableEntry
0C47: 01 02    ADD   A,2
0C49: 04 08    ADD   [8],A
0C4B: 10       PUSH  X

FILE: lib\usb.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;*****************************************************************************
                                   (0004) ;;  FILENAME: USB.asm
                                   (0005) ;;   Version: 1.3, Updated on 2007/09/28 at 14:23:41
                                   (0006) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0007) ;;
                                   (0008) ;;  DESCRIPTION: USB Device User Module software implementation file
                                   (0009) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0010) ;;
                                   (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0013) ;;        This means it is the caller's responsibility to preserve any values
                                   (0014) ;;        in the X and A registers that are still needed after the API functions
                                   (0015) ;;        returns. For Large Memory Model devices it is also the caller's
                                   (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                   (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0019) ;;-----------------------------------------------------------------------------
                                   (0020) ;;  Copyright (c) Cypress Semiconductor 2005. All Rights Reserved.
                                   (0021) ;;*****************************************************************************
                                   (0022) ;;*****************************************************************************
                                   (0023) 
                                   (0024) include "m8c.inc"
                                   (0025) include "memory.inc"
                                   (0026) include "USB_macros.inc"
                                   (0027) include "USB.inc"
                                   (0028) IF 0x4 & 0x10000000
                                   (0029) PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
                                   (0030) ; This message will only appear if the USB Setup Wizard has not be run and the descriptors
                                   (0031) ; and associated data structures have been created.
                                   (0032) ; After running the USB Setup Wizard, you must also select the Config/Generate Application
                                   (0033) ; menu item from PSoC Designer in order to generate USB User Module data structures and
                                   (0034) ; descriptors.
                                   (0035) ENDIF
                                   (0036) ;-----------------------------------------------
                                   (0037) ;  Global Symbols
                                   (0038) ;-----------------------------------------------
                                   (0039) export  USB_Start
                                   (0040) export _USB_Start
                                   (0041) export  USB_Stop
                                   (0042) export _USB_Stop
                                   (0043) export  USB_bCheckActivity
                                   (0044) export _USB_bCheckActivity
                                   (0045) export  USB_bGetConfiguration
                                   (0046) export _USB_bGetConfiguration
                                   (0047) export  USB_bGetEPState
                                   (0048) export _USB_bGetEPState
                                   (0049) export  USB_wGetEPCount
                                   (0050) export _USB_wGetEPCount
                                   (0051) export  USB_LoadInEP
                                   (0052) export _USB_LoadInEP
                                   (0053) export  USB_LoadInISOCEP
                                   (0054) export _USB_LoadInISOCEP
                                   (0055) export  USB_EnableOutEP
                                   (0056) export _USB_EnableOutEP
                                   (0057) export  USB_EnableOutISOCEP
                                   (0058) export _USB_EnableOutISOCEP
                                   (0059) export  USB_DisableOutEP
                                   (0060) export _USB_DisableOutEP
                                   (0061) export  USB_bReadOutEP
                                   (0062) export _USB_bReadOutEP
                                   (0063) export  USB_Force
                                   (0064) export _USB_Force
                                   (0065) export  USB_bGetEPAckState
                                   (0066) export _USB_bGetEPAckState
                                   (0067) ;export USB_Suspend
                                   (0068) ;export _USB_Suspend
                                   (0069) ;export USB_Resume
                                   (0070) ;export _USB_Resume
                                   (0071) export  USB_bRWUEnabled
                                   (0072) export _USB_bRWUEnabled
                                   (0073) export  USB_SetPowerStatus
                                   (0074) export _USB_SetPowerStatus
                                   (0075) 
                                   (0076) AREA InterruptRAM (RAM, REL, CON)
                                   (0077) ;-----------------------------------------------
                                   (0078) ;  Constant Definitions
                                   (0079) ;-----------------------------------------------
                                   (0080) 
                                   (0081) ;-----------------------------------------------
                                   (0082) ;  Variable Allocation
                                   (0083) ;-----------------------------------------------
                                   (0084) export USB_APITemp
                                   (0085)  USB_APITemp:                           BLK   2 ; Two bytes of temporary
                                   (0086)                                                 ; storage shared by the API
                                   (0087)                                                 ; functions
                                   (0088) export USB_APIEPNumber, _USB_APIEPNumber
                                   (0089) _USB_APIEPNumber:
                                   (0090)  USB_APIEPNumber:                      BLK   1 ; API storage for speed
                                   (0091) export USB_APICount, _USB_APICount
                                   (0092) _USB_APICount:
                                   (0093)  USB_APICount:                         BLK   1 ; API storage for speed
                                   (0094) 
                                   (0095) export USB_bActivity, _USB_bActivity
                                   (0096) _USB_bActivity:
                                   (0097)  USB_bActivity:                        BLK   1 ; Activity flag (Shared between the ISR and API)
                                   (0098) ;-----------------------------------------------
                                   (0099) ;  Constant Data Allocation
                                   (0100) ;-----------------------------------------------
                                   (0101) AREA UserModules (ROM, REL)
                                   (0102) export USB_USB_EP_BIT_LOOKUP
                                   (0103) .LITERAL
                                   (0104) USB_USB_EP_BIT_LOOKUP:  ;
                                   (0105)     DB     01H                       ; EP0
                                   (0106)     DB     02H                       ; EP1
                                   (0107)     DB     04H                       ; EP2
                                   (0108)     DB     08H                       ; EP3
                                   (0109)     DB     010H                      ; EP4
                                   (0110) .ENDLITERAL
                                   (0111) 
                                   (0112) .SECTION
                                   (0113) ;-----------------------------------------------------------------------------
                                   (0114) ;  FUNCTION NAME: USB_Start
                                   (0115) ;
                                   (0116) ;  DESCRIPTION:    Starts the USB User Module
                                   (0117) ;                    Sets the device selection
                                   (0118) ;                    Set the configuration to unconfigured
                                   (0119) ;                    Enables the SIE for Address 0
                                   (0120) ;                    Enables the USB pullup (D- for low speed, D+ for full speed)
                                   (0121) ;
                                   (0122) ;-----------------------------------------------------------------------------
                                   (0123) ;
                                   (0124) ;  ARGUMENTS:    A is the desired device
                                   (0125) ;                X is the operation voltage
                                   (0126) ;
                                   (0127) ;  RETURNS:              Nothing
                                   (0128) ;
                                   (0129) ;  SIDE EFFECTS:
                                   (0130) ;    The A and X registers may be modified by this or future implementations
                                   (0131) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0132) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0133) ;    responsibility to perserve their values across calls to fastcall16
                                   (0134) ;    functions.
                                   (0135) ;
                                   (0136)  USB_Start:
                                   (0137) _USB_Start:
                                   (0138)     RAM_PROLOGUE RAM_USE_CLASS_4
0C4C: 70 BF    AND   F,191         (0139)     RAM_PROLOGUE RAM_USE_CLASS_3
0C4E: 62 D0 00 MOV   REG[208],0    (0140)     RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
0C51: 62 D3 00 MOV   REG[211],0    (0141)     RAM_SETPAGE_IDX >USB_bCurrentDevice   ; Set the IDX_PP to the right page
0C54: 10       PUSH  X             (0142)     push    X
0C55: 53 00    MOV   [0],A         (0143)     mov     [USB_bCurrentDevice], A    ; The app selects the desired device
                                   (0144) 
0C57: 55 0A 00 MOV   [10],0        (0145)     mov     [USB_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
0C5A: 55 01 00 MOV   [1],0         (0146)     mov     [USB_Configuration], 0     ; Unconfigured
0C5D: 55 02 00 MOV   [2],0         (0147)     mov     [USB_DeviceStatus], 0      ; Clears device status
                                   (0148) 
0C60: 55 1C 00 MOV   [28],0        (0149)     mov     [USB_EPDataToggle], 0      ; Clear all EP data toggles
                                   (0150) 
0C63: 62 6C 00 MOV   REG[108],0    (0151)     mov     reg[TMP_DR0], 0            ; EP1 start address in PMA space
0C66: 62 6D 40 MOV   REG[109],64   (0152)     mov     reg[TMP_DR1], 64           ; EP2 start address in PMA space
0C69: 62 6E 80 MOV   REG[110],128  (0153)     mov     reg[TMP_DR2], 128          ; EP3 start address in PMA space
0C6C: 62 6F C0 MOV   REG[111],192  (0154)     mov     reg[TMP_DR3], 192          ; EP4 start address in PMA space
                                   (0155) 
                                   (0156) ;    mov     X, USB_MAX_EP_NUMBER      ; Set up loop to clear all of the endpoint data items
                                   (0157) ; Flow or jump here to clear the data for the next endpoint
                                   (0158) ;.loop:
                                   (0159) ;    mov     [X + USB_EPDataToggle], 0    ; Or in the toggle
                                   (0160) ;    dec     X                         ; Are we done?
                                   (0161) ;    jnz     .loop                     ; Jump to do another endpoint
                                   (0162) ; Flow here to enable the SIE
                                   (0163) 
0C6F: 62 4A 80 MOV   REG[74],128   (0164)     mov     reg[USB_ADDR], USB_ADDR_ENABLE   ; Enable Address 0
0C72: 62 4B 00 MOV   REG[75],0     (0165)     mov     reg[USB_USBIO_CR0], USB_AUTO_DPDM
                                   (0166) 
                                   (0167) ; Set the Operating Voltage at which the chip will run
0C75: 18       POP   A             (0168)     pop     A
0C76: 71 10    OR    F,16          (0169)     M8C_SetBank1
0C78: 60 C1    MOV   REG[193],A    (0170)     mov     reg[USB_USB_CR1], A
0C7A: 70 EF    AND   F,239         (0171)     M8C_SetBank0
                                   (0172) ;   TODO
0C7C: 62 56 03 MOV   REG[86],3     (0173)     mov     reg[USB_EP0MODE], USB_MODE_STALL_IN_OUT   ; ACK Setup/Stall IN/OUT
0C7F: 43 DF 05 OR    REG[223],5    (0174)     M8C_EnableIntMask USB_INT_REG, (USB_INT_RESET_MASK | USB_INT_EP0_MASK)
                                   (0175) 
                                   (0176) ;   Enable the pullup so we can start to rock and roll
0C82: 62 4C 04 MOV   REG[76],4     (0177)     mov     reg[USB_USBIO_CR1], USB_PULLUP_ENABLE   ; Pullup D+
0C85: 70 3F    AND   F,63
                                   (0178) 
0C87: 71 C0    OR    F,192         (0179)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0180)     RAM_EPILOGUE RAM_USE_CLASS_4
0C89: 7F       RET                 (0181)     ret
                                   (0182) .ENDSECTION
                                   (0183) 
                                   (0184) .SECTION
                                   (0185) ;-----------------------------------------------------------------------------
                                   (0186) ;  FUNCTION NAME: USB_Stop
                                   (0187) ;
                                   (0188) ;  DESCRIPTION:
                                   (0189) ;
                                   (0190) ;-----------------------------------------------------------------------------
                                   (0191) ;
                                   (0192) ;  ARGUMENTS: None
                                   (0193) ;
                                   (0194) ;  RETURNS:   Nothing
                                   (0195) ;
                                   (0196) ;  SIDE EFFECTS:
                                   (0197) ;    The A and X registers may be modified by this or future implementations
                                   (0198) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0199) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0200) ;    responsibility to perserve their values across calls to fastcall16
                                   (0201) ;    functions.
                                   (0202) ;
                                   (0203)  USB_Stop:
                                   (0204) _USB_Stop:
                                   (0205)     RAM_PROLOGUE RAM_USE_CLASS_4
0C8A: 62 D0 00 MOV   REG[208],0    (0206)     RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
                                   (0207) 
0C8D: 55 00 00 MOV   [0],0         (0208)     mov     [USB_bCurrentDevice], 0    ; The app selects the desired device
                                   (0209) 
0C90: 55 0A 00 MOV   [10],0        (0210)     mov     [USB_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
0C93: 55 01 00 MOV   [1],0         (0211)     mov     [USB_Configuration], 0     ; Unconfigured
0C96: 55 02 00 MOV   [2],0         (0212)     mov     [USB_DeviceStatus], 0      ; Clears device status
0C99: 62 4A 00 MOV   REG[74],0     (0213)     mov     reg[USB_ADDR], 0           ; Clear the addfress and Address 0
                                   (0214) 
0C9C: 41 4C FB AND   REG[76],251   (0215)     and     reg[USB_USBIO_CR1], ~USB_PULLUP_ENABLE   ; Release D-
0C9F: 62 DF 00 MOV   REG[223],0    (0216)     mov     reg[USB_INT_REG], 0x00 ; Enable the interrupt
                                   (0217) 
                                   (0218)     RAM_EPILOGUE RAM_USE_CLASS_4
0CA2: 7F       RET                 (0219)     ret
                                   (0220) .ENDSECTION
                                   (0221) 
                                   (0222) .SECTION
                                   (0223) ;-----------------------------------------------------------------------------
                                   (0224) ;  FUNCTION NAME: USB_bCheckActivity
                                   (0225) ;
                                   (0226) ;  DESCRIPTION:
                                   (0227) ;
                                   (0228) ;-----------------------------------------------------------------------------
                                   (0229) ;
                                   (0230) ;  ARGUMENTS: Nothing
                                   (0231) ;
                                   (0232) ;  RETURNS:   A is a flag that indicates bus activity
                                   (0233) ;
                                   (0234) ;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
                                   (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0237) ;    responsibility to perserve their values across calls to fastcall16
                                   (0238) ;    functions.
                                   (0239) ;
                                   (0240)  USB_bCheckActivity:
                                   (0241) _USB_bCheckActivity:
                                   (0242)     RAM_PROLOGUE RAM_USE_CLASS_1
0CA3: 71 10    OR    F,16          (0243)     M8C_SetBank1
0CA5: 5D C1    MOV   A,REG[193]    (0244)     mov    A, reg[USB_USB_CR1]         ; USB Activity bit indicates activity
0CA7: 21 04    AND   A,4           (0245)     and    A, USB_BUS_ACTIVITY         ; Activity?
0CA9: A0 05    JZ    0x0CAF        (0246)     jz     .no_activity                ; Jump on no activity?
                                   (0247) ; Flow here on bus activity
0CAB: 50 01    MOV   A,1           (0248)     mov    A, 1                        ; Return true
0CAD: 80 03    JMP   0x0CB1        (0249)     jmp    .done
                                   (0250) ; Jump here on no activity
                                   (0251) .no_activity:
0CAF: 50 00    MOV   A,0           (0252)     mov    A, 0                        ; Return false
                                   (0253) ; Jump or flow here to clear the activity bit, then return
                                   (0254) .done:
0CB1: 41 C1 FB AND   REG[193],251  (0255)     and    reg[USB_USB_CR1], ~USB_BUS_ACTIVITY    ; Clear the activity flag
0CB4: 70 EF    AND   F,239         (0256)     M8C_SetBank0
                                   (0257)     RAM_EPILOGUE RAM_USE_CLASS_1
0CB6: 7F       RET                 (0258)     ret
                                   (0259) .ENDSECTION
                                   (0260) 
                                   (0261) .SECTION
                                   (0262) ;-----------------------------------------------------------------------------
                                   (0263) ;  FUNCTION NAME: USB_bGetConfiguration
                                   (0264) ;
                                   (0265) ;  DESCRIPTION:   Returns the current configuration number
                                   (0266) ;
                                   (0267) ;-----------------------------------------------------------------------------
                                   (0268) ;
                                   (0269) ;  ARGUMENTS:    None
                                   (0270) ;
                                   (0271) ;  RETURNS:      A contains the current configuration number
                                   (0272) ;
                                   (0273) ;  SIDE EFFECTS:
                                   (0274) ;    The A and X registers may be modified by this or future implementations
                                   (0275) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0276) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0277) ;    responsibility to perserve their values across calls to fastcall16
                                   (0278) ;    functions.
                                   (0279) ;
                                   (0280)  USB_bGetConfiguration:
                                   (0281) _USB_bGetConfiguration:
                                   (0282)     RAM_PROLOGUE RAM_USE_CLASS_4
0CB7: 62 D0 00 MOV   REG[208],0    (0283)     RAM_SETPAGE_CUR >USB_Configuration
0CBA: 51 01    MOV   A,[1]         (0284)     mov     A, [USB_Configuration]
                                   (0285)     RAM_EPILOGUE RAM_USE_CLASS_4
0CBC: 7F       RET                 (0286)     ret
                                   (0287) .ENDSECTION
                                   (0288) 
                                   (0289) .SECTION
                                   (0290) ;-----------------------------------------------------------------------------
                                   (0291) ;  FUNCTION NAME: USB_bGetEPState
                                   (0292) ;
                                   (0293) ;  DESCRIPTION:
                                   (0294) ;
                                   (0295) ;-----------------------------------------------------------------------------
                                   (0296) ;
                                   (0297) ;  ARGUMENTS:    A contains the endpoint number
                                   (0298) ;
                                   (0299) ;  RETURNS:      A contains the endpoint state
                                   (0300) ;
                                   (0301) ;  SIDE EFFECTS:
                                   (0302) ;    The A and X registers may be modified by this or future implementations
                                   (0303) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0304) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0305) ;    responsibility to perserve their values across calls to fastcall16
                                   (0306) ;    functions.
                                   (0307) ;
                                   (0308)  USB_bGetEPState:
                                   (0309) _USB_bGetEPState:
0CBD: 70 BF    AND   F,191         (0310)     RAM_PROLOGUE RAM_USE_CLASS_3
0CBF: 62 D3 00 MOV   REG[211],0    (0311)     RAM_SETPAGE_IDX >USB_EndpointAPIStatus
0CC2: 39 05    CMP   A,5           (0312)     cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
0CC4: D0 06    JNC   0x0CCB        (0313)     jnc     .invalid_ep                ; Bail out
                                   (0314) ; Flow here to enable an endpoint
0CC6: 5C       MOV   X,A           (0315)     mov     X, A                       ; Endpoint number is the index
0CC7: 52 21    MOV   A,[X+33]      (0316)     mov     A, [X+USB_EndpointAPIStatus]; Get the state
0CC9: 80 03    JMP   0x0CCD        (0317)     jmp     .exit                      ; Go to the common exit
                                   (0318) ; Jump here for an invalid endpoint
                                   (0319) .invalid_ep:
0CCB: 50 00    MOV   A,0           (0320)     mov     A, 0                       ; Return 0 for an invalid ep
0CCD: 70 3F    AND   F,63
                                   (0321) ; Jump or flow here for a common exit
                                   (0322) .exit:
0CCF: 71 C0    OR    F,192         (0323)     RAM_EPILOGUE RAM_USE_CLASS_3
0CD1: 7F       RET                 (0324)     ret                                ; All done
                                   (0325) .ENDSECTION
                                   (0326) 
                                   (0327) 
                                   (0328) 
                                   (0329) ;-----------------------------------------------------------------------------
                                   (0330) ;  FUNCTION NAME: USB_bRWUEnabled
                                   (0331) ;
                                   (0332) ;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
                                   (0333) ;
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;
                                   (0336) ;  ARGUMENTS:   None
                                   (0337) ;
                                   (0338) ;  RETURNS:     A: 1--Remote Wake Up Enabled
                                   (0339) ;                  0--Remote Wake Up Disabled
                                   (0340) ;
                                   (0341) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
                                   (0342) ;
                                   (0343) ;  THEORY of OPERATION or PROCEDURE:
                                   (0344) ;
                                   (0345) ;-----------------------------------------------------------------------------
                                   (0346) .SECTION
                                   (0347)  USB_bRWUEnabled:
                                   (0348) _USB_bRWUEnabled:
0CD2: 47 02 02 TST   [2],2         (0349)     tst     [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
0CD5: B0 05    JNZ   0x0CDB        (0350)     jnz     .enabled                   ; Jump if enabled
                                   (0351) ; Flow here if RWU is disabled
0CD7: 50 00    MOV   A,0           (0352)     mov     A, 0                       ; Return disabled
0CD9: 80 03    JMP   0x0CDD        (0353)     jmp     .exit                      ; Go to the common exit
                                   (0354) ; Jump when RWU is enabled
                                   (0355) .enabled:
0CDB: 50 01    MOV   A,1           (0356)     mov     A, 1                       ; Return enabled
                                   (0357) ; Jump or flow here for a common exit
                                   (0358) .exit:
0CDD: 7F       RET                 (0359)     ret                                ; All done
                                   (0360) .ENDSECTION
                                   (0361) 
                                   (0362) ;-----------------------------------------------------------------------------
                                   (0363) ;  FUNCTION NAME: USB_bGetEPCount
                                   (0364) ;
                                   (0365) ;  DESCRIPTION:
                                   (0366) ;
                                   (0367) ;-----------------------------------------------------------------------------
                                   (0368) ;
                                   (0369) ;  ARGUMENTS:    A contains the Endpoint Number
                                   (0370) ;
                                   (0371) ;  RETURNS:              A and X contain a WORD that indicate the values stored in the
                                   (0372) ;                Count registers of the Endpoint
                                   (0373) ;
                                   (0374) ;  SIDE EFFECTS:
                                   (0375) ;    The A and X registers may be modified by this or future implementations
                                   (0376) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0377) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0378) ;    responsibility to perserve their values across calls to fastcall16
                                   (0379) ;    functions.
                                   (0380) ;
                                   (0381) .SECTION
                                   (0382)  USB_wGetEPCount:
                                   (0383) _USB_wGetEPCount:
                                   (0384)     RAM_PROLOGUE RAM_USE_CLASS_1
0CDE: 39 05    CMP   A,5           (0385)     cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
0CE0: D0 11    JNC   0x0CF2        (0386)     jnc     .invalid_ep                ; Bail out
                                   (0387) ; Flow here to get the endpoint count
0CE2: 64       ASL   A             (0388)     asl     A                          ; Multiply the index by two to get to the value
0CE3: 5C       MOV   X,A           (0389)     mov     X, A                       ; Endpoint number is the index
0CE4: 5E 4D    MOV   A,REG[X+77]   (0390)     mov     A, reg[X+USB_EP1CNT1 - 1]  ; Here is the count
0CE6: 11 02    SUB   A,2           (0391)     sub     A, 2
0CE8: 08       PUSH  A             (0392)     push    A
0CE9: 79       DEC   X             (0393)     dec     X
0CEA: 5E 4D    MOV   A,REG[X+77]   (0394)     mov     A, reg[X+USB_EP1CNT1 - 1]  ; Here is the count
0CEC: 21 01    AND   A,1           (0395)     and     A, 0x01
0CEE: 5C       MOV   X,A           (0396)     mov     X, A
0CEF: 18       POP   A             (0397)     pop     A
0CF0: 80 03    JMP   0x0CF4        (0398)     jmp     .exit                      ; Go to the common exit
                                   (0399) ; Jump here for an invalid endpoint
                                   (0400) .invalid_ep:
0CF2: 50 00    MOV   A,0           (0401)     mov     A, 0                       ; Return 0 for an invalid ep
                                   (0402) ; Jump or flow here for a common exit
                                   (0403) .exit:
                                   (0404)     RAM_EPILOGUE RAM_USE_CLASS_1
0CF4: 7F       RET                 (0405)     ret
                                   (0406) .ENDSECTION
                                   (0407) 
                                   (0408) .SECTION
                                   (0409) ;-----------------------------------------------------------------------------
                                   (0410) ;  FUNCTION NAME: USB_LoadInEP and USB_LoadInISOCEP
                                   (0411) ;
                                   (0412) ;  DESCRIPTION:    This function loads the specified USB endpoint with
                                   (0413) ;                  the data specified.
                                   (0414) ;
                                   (0415) ;-----------------------------------------------------------------------------
                                   (0416) ;
                                   (0417) ;  ARGUMENTS:
                                   (0418) ;     [SP-8] Toggle
                                   (0419) ;     [SP-7] MSB of Count to send
                                   (0420) ;     [SP-6] LSB of Count to send
                                   (0421) ;     [SP-5] MSB of data array address
                                   (0422) ;     [SP-4] LSB of data array address
                                   (0423) ;     [SP-3] Endpoint Number
                                   (0424) ;
                                   (0425) ;  RETURNS:
                                   (0426) ;     none
                                   (0427) ;
                                   (0428) ;  SIDE EFFECTS:
                                   (0429) ;    The A and X registers may be modified by this or future implementations
                                   (0430) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0431) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0432) ;    responsibility to perserve their values across calls to fastcall16
                                   (0433) ;    functions.
                                   (0434) ;
                                   (0435) ;    Currently only the page pointer registers listed below are modified:
                                   (0436) ;          CUR_PP
                                   (0437) ;          IDX_PP
                                   (0438) ;
                                   (0439) EP_TYPE:        equ -1
                                   (0440) ; -2 and -3 is the return address to caller
                                   (0441) EP_NUM:     equ -4                       ; Endpoint Number
                                   (0442) DATA_LSB:   equ -5           ; LSB pointer of data
                                   (0443) DATA_MSB:   equ -6           ; MSB pointer of data
                                   (0444) CNTLEN_LSB: equ -7
                                   (0445) CNTLEN_MSB: equ -8           ; Length of data to send
                                   (0446) TOGGLE:     equ -9
                                   (0447) 
                                   (0448)  USB_LoadInISOCEP:
                                   (0449) _USB_LoadInISOCEP:
0CF5: 50 07    MOV   A,7           (0450)     mov     A, USB_MODE_ISO_IN
0CF7: 08       PUSH  A             (0451)     push    A
0CF8: 80 04    JMP   0x0CFD        (0452)     jmp             BodyLoadIN_USB
                                   (0453)  USB_LoadInEP:
                                   (0454) _USB_LoadInEP:
0CFA: 50 0D    MOV   A,13          (0455)     mov     A, USB_MODE_ACK_IN
0CFC: 08       PUSH  A             (0456)     push    A
                                   (0457) BodyLoadIN_USB:
                                   (0458)     RAM_PROLOGUE RAM_USE_CLASS_4
0CFD: 70 BF    AND   F,191         (0459)     RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0460) 
0CFF: 62 D0 00 MOV   REG[208],0    (0461)     RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
0D02: 62 D3 03 MOV   REG[211],3    (0462)     RAM_SETPAGE_IDX2STK
0D05: 4F       MOV   X,SP          (0463)     mov     X, SP
0D06: 52 FC    MOV   A,[X-4]       (0464)     mov     A, [X+EP_NUM]
0D08: 39 05    CMP   A,5           (0465)     cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
0D0A: D0 97    JNC   0x0DA2        (0466)     jnc     .exit                      ; Bail out
                                   (0467) 
                                   (0468)     ;SET THE COUNT
0D0C: 52 F8    MOV   A,[X-8]       (0469)     mov     A, [X+CNTLEN_MSB]          ; Get the MSB of the Count
0D0E: 21 01    AND   A,1           (0470)     and     A, 0x01                    ; Mask off the count bit
0D10: 53 42    MOV   [66],A        (0471)     mov     [USB_APITemp+1], A         ; Save the count
0D12: 52 F9    MOV   A,[X-7]       (0472)     mov     A, [X+CNTLEN_LSB]          ; Get the LSB of the Count
0D14: 53 41    MOV   [65],A        (0473)     mov     [USB_APITemp], A           ; Save the count
                                   (0474) 
                                   (0475) 
                                   (0476)         ;  Perform normal data toggle or bypass?
0D16: 10       PUSH  X             (0477)     push    X
0D17: 52 F7    MOV   A,[X-9]       (0478)     mov     A, [X+TOGGLE]
0D19: B0 0F    JNZ   0x0D29        (0479)     jnz     .normalToggle
                                   (0480) 		; the endpoint ISR automatically toggles the endpoint, so to support
                                   (0481) 		; the idea of not having the toggle change we must untoggle here.
0D1B: 50 47    MOV   A,71          (0482)     mov     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
0D1D: 03 FC    ADD   A,[X-4]       (0483)     add     A, [X+EP_NUM]           ; Get the Endpoint number
0D1F: 57 0C    MOV   X,12          (0484)     mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
0D21: 4B       SWAP  A,X           (0485)     swap    A, X
0D22: 09 00    ADC   A,0           (0486) 	adc     A, 0
0D24: 28       ROMX                (0487) 	romx
0D25: 20       POP   X             (0488) 	pop     X	                            ; Restore X to obtain the endpt correctly in the next block
0D26: 10       PUSH  X             (0489) 	push    X
                                   (0490) 
                                   (0491) ;    INDEX   USB_USB_EP_BIT_LOOKUP ; Get the bit mask
0D27: 34 1C    XOR   [28],A        (0492)     xor     [USB_EPDataToggle], A ; Retoggle the toggle
                                   (0493) 
                                   (0494) .normalToggle:
0D29: 50 47    MOV   A,71          (0495)     mov     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
0D2B: 03 FC    ADD   A,[X-4]       (0496)     add     A, [X+EP_NUM]           ; Get the Endpoint number
0D2D: 57 0C    MOV   X,12          (0497)     mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
0D2F: 4B       SWAP  A,X           (0498)     swap    A, X
0D30: 09 00    ADC   A,0           (0499) 	adc     A, 0
0D32: 28       ROMX                (0500) 	romx	;   now A contains the toggle
                                   (0501) 
                                   (0502) ;    INDEX   USB_USB_EP_BIT_LOOKUP ; Get the bit mask
0D33: 20       POP   X             (0503)     pop     X	 ;do before the and so the zero flag won't be corrupted.
0D34: 22 1C    AND   A,[28]        (0504)     and     A, [USB_EPDataToggle]
0D36: A0 06    JZ    0x0D3D        (0505)     jz      .toggle0
                                   (0506) 
0D38: 26 42 7F AND   [66],127      (0507)     and      [USB_APITemp+1], ~USB_CNT_TOGGLE ; Set the data toggle
0D3B: 80 04    JMP   0x0D40        (0508)     jmp     .toggle_done
                                   (0509) .toggle0:
0D3D: 2E 42 80 OR    [66],128      (0510)     or     [USB_APITemp+1], USB_CNT_TOGGLE
                                   (0511) 
                                   (0512) .toggle_done:
                                   (0513) 
0D40: 4F       MOV   X,SP          (0514)     mov     X, SP
0D41: 52 FC    MOV   A,[X-4]       (0515)     mov     A, [X+EP_NUM]               ; Get the Endpoint number
0D43: 64       ASL   A             (0516)     asl     A                           ; Double the ep number for proper cnt access
0D44: 5C       MOV   X,A           (0517)     mov     X, A                        ; Make it into an index
0D45: 51 41    MOV   A,[65]        (0518)     mov     A, [USB_APITemp]            ; Retrieve the saved MSB
0D47: 61 4D    MOV   REG[X+77],A   (0519)     mov     reg[X+USB_EP1CNT1 - 1], A     ; Write it into the register
0D49: 79       DEC   X             (0520)     dec     X                           ; Decrement the index to access the LSB
0D4A: 51 42    MOV   A,[66]        (0521)     mov     A, [USB_APITemp+1]          ; Retrieve the saved LSB
0D4C: 61 4D    MOV   REG[X+77],A   (0522)     mov     reg[X+USB_EP1CNT1 - 1], A     ; Write it into the register
                                   (0523) 
                                   (0524) ; It's Time to move the data
                                   (0525) 
                                   (0526) ; First we need to determine where within the PMA the EP Start Address is
0D4E: 4F       MOV   X,SP          (0527)     mov     X, SP                       ; Get the Stack Pointer
0D4F: 52 FC    MOV   A,[X-4]       (0528)     mov     A, [X+EP_NUM]               ; Get the Endpoint number
0D51: 5C       MOV   X,A           (0529)     mov     X, A                        ; Use the EP number as an index
0D52: 5E 6B    MOV   A,REG[X+107]  (0530)     mov     A, reg[X+TMP_DR0-1]         ; Get the address of ep from tmp register
0D54: 71 10    OR    F,16          (0531)     M8C_SetBank1
0D56: 70 FE    AND   F,254         (0532)     M8C_DisableGInt
0D58: 60 40    MOV   REG[64],A     (0533)     mov     reg[PMA0_WA], A             ; Set the Write pointer of our pma to ep space
0D5A: 71 01    OR    F,1           (0534)     M8C_EnableGInt
0D5C: 70 EF    AND   F,239         (0535)     M8C_SetBank0
                                   (0536) 
                                   (0537) ; Now we are ready to start moving data
0D5E: 4F       MOV   X,SP          (0538)     mov     X, SP
0D5F: 27 F8 01 AND   [X-8],1       (0539)     and     [X+CNTLEN_MSB], 0x01        ; Mask off the MSB bit
0D62: B0 05    JNZ   0x0D68        (0540)     jnz     .start_send                 ; If it is high then we have 256 bytes
0D64: 52 F9    MOV   A,[X-7]       (0541)     mov     A, [X+CNTLEN_LSB]           ; Check the LSB register
0D66: A0 15    JZ    0x0D7C        (0542)     jz      .done                       ; If it is 0 then we have a 0 length packet
                                   (0543) .start_send:
0D68: 52 FB    MOV   A,[X-5]       (0544)     mov     A, [X+DATA_LSB]
0D6A: 08       PUSH  A             (0545)     push    A
                                   (0546) IF SYSTEM_LARGE_MEMORY_MODEL
0D6B: 52 FA    MOV   A,[X-6]       (0547)     mov     A, [X+DATA_MSB]
0D6D: 60 D3    MOV   REG[211],A    (0548)     mov     reg[IDX_PP], A
                                   (0549) ENDIF
0D6F: 20       POP   X             (0550)     pop     X
                                   (0551) 
                                   (0552) .loop:
0D70: 52 00    MOV   A,[X+0]       (0553)     mov     A, [X]
0D72: 60 40    MOV   REG[64],A     (0554)     mov     reg[PMA0_DR], A
0D74: 75       INC   X             (0555)     inc     X
0D75: 7A 41    DEC   [65]          (0556)     dec     [USB_APITemp]
0D77: BF F8    JNZ   0x0D70        (0557)     jnz     .loop
                                   (0558) 
0D79: 62 D3 03 MOV   REG[211],3    (0559)     RAM_SETPAGE_IDX2STK
                                   (0560) .done:
0D7C: 4F       MOV   X,SP          (0561)     mov     X, SP
0D7D: 52 FC    MOV   A,[X-4]       (0562)     mov     A, [X+EP_NUM]
0D7F: 5C       MOV   X,A           (0563)     mov     X, A
0D80: 71 10    OR    F,16          (0564)     M8C_SetBank1
0D82: 5E 6B    MOV   A,REG[X+107]  (0565)     mov     A, reg[X+TMP_DR0-1]        ; Get the value of the PMA start Address
0D84: 70 FE    AND   F,254         (0566)     M8C_DisableGInt
0D86: 61 50    MOV   REG[X+80],A   (0567)     mov     reg[X + PMA0_RA], A        ; Load it into EP PMA so pre-fetch occurs
0D88: 71 01    OR    F,1           (0568)     M8C_EnableGInt
0D8A: 70 EF    AND   F,239         (0569)     M8C_SetBank0
                                   (0570)     
0D8C: 10       PUSH  X             (0571)     push    X
0D8D: 4F       MOV   X,SP          (0572)     mov     X, SP
0D8E: 52 FE    MOV   A,[X-2]       (0573)     mov     A, [X+EP_TYPE-1]
0D90: 20       POP   X             (0574)     pop     X
                                   (0575) 
                                   (0576)     ; Check that we aren't halted
0D91: 62 D3 00 MOV   REG[211],0    (0577)     RAM_SETPAGE_IDX >USB_EndpointAPIStatus
0D94: 3D 21 02 CMP   [X+33],2      (0578)     cmp     [X + USB_EndpointAPIStatus], NO_EVENT_ALLOWED    ; Get the state
0D97: A0 0A    JZ    0x0DA2        (0579)     jz      .exit
                                   (0580) 
0D99: 56 21 00 MOV   [X+33],0      (0581)     mov     [X + USB_EndpointAPIStatus], NO_EVENT_PENDING   ; Set the state
0D9C: 71 10    OR    F,16          (0582)     M8C_SetBank1
0D9E: 61 C3    MOV   REG[X+195],A  (0583)     mov     reg[X + USB_EP1MODE-1], A ; Enable the endpoint
0DA0: 70 EF    AND   F,239         (0584)     M8C_SetBank0
                                   (0585) 
                                   (0586) .exit:
0DA2: 18       POP   A             (0587)     pop     A                          ; Clean up EP_TYPE
0DA3: 70 3F    AND   F,63
0DA5: 71 C0    OR    F,192         (0588)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0589)     RAM_EPILOGUE RAM_USE_CLASS_4
0DA7: 7F       RET                 (0590)     ret
                                   (0591) .ENDSECTION
                                   (0592) 
                                   (0593) .SECTION
                                   (0594) ;-----------------------------------------------------------------------------
                                   (0595) ;  FUNCTION NAME: USB_EnableOutEP and
                                   (0596) ;                                 USB_EnableOutISOCEP
                                   (0597) ;
                                   (0598) ;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
                                   (0599) ;                  called for an IN endpoint.
                                   (0600) ;
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;
                                   (0603) ;  ARGUMENTS:      A contains the endpoint number
                                   (0604) ;
                                   (0605) ;  RETURNS:        None
                                   (0606) ;
                                   (0607) ;  SIDE EFFECTS:
                                   (0608) ;    The A and X registers may be modified by this or future implementations
                                   (0609) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0610) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0611) ;    responsibility to perserve their values across calls to fastcall16
                                   (0612) ;    functions.
                                   (0613) ;
                                   (0614) USB_EnableOutISOCEP:
                                   (0615) _USB_EnableOutISOCEP:
0DA8: 57 05    MOV   X,5           (0616)     mov     X, USB_MODE_ISO_OUT
0DAA: 10       PUSH  X             (0617)     push    X
0DAB: 80 04    JMP   0x0DB0        (0618)     jmp     BodyEnableOut_USB
                                   (0619)  USB_EnableOutEP:
                                   (0620) _USB_EnableOutEP:
0DAD: 57 09    MOV   X,9           (0621)     mov     X, USB_MODE_ACK_OUT
0DAF: 10       PUSH  X             (0622)     push    X
                                   (0623) BodyEnableOut_USB:
0DB0: 70 BF    AND   F,191         (0624)     RAM_PROLOGUE RAM_USE_CLASS_3
0DB2: 62 D3 00 MOV   REG[211],0    (0625)     RAM_SETPAGE_IDX >USB_EndpointAPIStatus
                                   (0626) 
0DB5: 39 00    CMP   A,0           (0627)     cmp     A, 0                       ; Can't enable EP0
0DB7: A0 25    JZ    0x0DDD        (0628)     jz      .exit                      ; Bail out
0DB9: 39 05    CMP   A,5           (0629)     cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
0DBB: D0 21    JNC   0x0DDD        (0630)     jnc     .exit                      ; Bail out
                                   (0631) ; Flow here to enable an endpoint
0DBD: 5C       MOV   X,A           (0632)     mov     X, A                       ; Endpoint number is the index
                                   (0633) 
                                   (0634)     ; Check that we aren't halted
0DBE: 3D 21 02 CMP   [X+33],2      (0635)     cmp     [X + USB_EndpointAPIStatus], NO_EVENT_ALLOWED    
0DC1: A0 1B    JZ    0x0DDD        (0636)     jz      .exit
                                   (0637) 
0DC3: 10       PUSH  X             (0638)     push    X
0DC4: 56 21 00 MOV   [X+33],0      (0639)     mov     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING   ; For the API
0DC7: 5B       MOV   A,X           (0640)     mov     A, X
0DC8: 64       ASL   A             (0641)     asl     A
0DC9: 5C       MOV   X,A           (0642)     mov     X, A
0DCA: 63 4D 40 MOV   REG[X+77],64  (0643)     mov     reg[X+EP1_CNT1-1], 64
0DCD: 71 10    OR    F,16          (0644)     M8C_SetBank1
0DCF: 20       POP   X             (0645)     pop     X
0DD0: 5E 6B    MOV   A,REG[X+107]  (0646)     mov     A, reg[X+TMP_DR0-1]
0DD2: 61 40    MOV   REG[X+64],A   (0647)     mov     reg[X+PMA0_WA], A
0DD4: 5E C3    MOV   A,REG[X+195]  (0648)     mov     A, reg[X+USB_EP1MODE-1]    ; Unlock the mode register
0DD6: 18       POP   A             (0649)     pop     A
                                   (0650) 
0DD7: 61 C3    MOV   REG[X+195],A  (0651)     mov     reg[X+USB_EP1MODE-1], A    ; Enable the endpoint
0DD9: 70 EF    AND   F,239         (0652)     M8C_SetBank0
0DDB: 80 02    JMP   0x0DDE        (0653)     jmp         .DoneEnableOut
                                   (0654) ; Jump or flow here for a common exit
                                   (0655) .exit:
0DDD: 18       POP   A             (0656)     pop     A
0DDE: 70 3F    AND   F,63
                                   (0657) .DoneEnableOut:
0DE0: 71 C0    OR    F,192         (0658)     RAM_EPILOGUE RAM_USE_CLASS_3
0DE2: 7F       RET                 (0659)     ret                                ; All done
                                   (0660) .ENDSECTION
                                   (0661) 
                                   (0662) ;-----------------------------------------------------------------------------
                                   (0663) ;  FUNCTION NAME: USB_DisableEP
                                   (0664) ;
                                   (0665) ;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
                                   (0666) ;                  called for an IN endpoint.
                                   (0667) ;
                                   (0668) ;-----------------------------------------------------------------------------
                                   (0669) ;
                                   (0670) ;  ARGUMENTS:     A the endpoint number
                                   (0671) ;
                                   (0672) ;  RETURNS:               none
                                   (0673) ;
                                   (0674) ;  SIDE EFFECTS:
                                   (0675) ;    The A and X registers may be modified by this or future implementations
                                   (0676) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0677) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0678) ;    responsibility to perserve their values across calls to fastcall16
                                   (0679) ;    functions.
                                   (0680) ;
                                   (0681) .SECTION
                                   (0682)  USB_DisableOutEP:
                                   (0683) _USB_DisableOutEP:
0DE3: 39 00    CMP   A,0           (0684)     cmp     A, 0                       ; Can't disable EP0
0DE5: A0 0F    JZ    0x0DF5        (0685)     jz      .exit                      ; Bail out
0DE7: 39 05    CMP   A,5           (0686)     cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
0DE9: D0 0B    JNC   0x0DF5        (0687)     jnc     .exit                      ; Bail out
                                   (0688) ; Flow here to disable an endpoint
0DEB: 5C       MOV   X,A           (0689)     mov     X, A                       ; Endpoint number is the index
0DEC: 71 10    OR    F,16          (0690)     M8C_SetBank1
0DEE: 5E C3    MOV   A,REG[X+195]  (0691)     mov     A, reg[X+USB_EP1MODE-1]    ; Unlock the mode register
0DF0: 63 C3 08 MOV   REG[X+195],8  (0692)     mov     reg[X+USB_EP1MODE-1], USB_MODE_NAK_OUT   ; Disable the endpoint
0DF3: 70 EF    AND   F,239         (0693)     M8C_SetBank0
                                   (0694) ; Jump or flow here for a common exit
                                   (0695) .exit:
0DF5: 7F       RET                 (0696)     ret                                ; All done
                                   (0697) .ENDSECTION
                                   (0698) 
                                   (0699) .SECTION
                                   (0700) ;-----------------------------------------------------------------------------
                                   (0701) ;  FUNCTION NAME: USB_Force
                                   (0702) ;
                                   (0703) ;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
                                   (0704) ;
                                   (0705) ;-----------------------------------------------------------------------------
                                   (0706) ;
                                   (0707) ;  ARGUMENTS:     A: USB_FORCE_J
                                   (0708) ;                    USB_FORCE_K
                                   (0709) ;                    USB_FORCE_SE0
                                   (0710) ;                    USB_FORCE_NONE
                                   (0711) ;
                                   (0712) ;  RETURNS:       Nothing
                                   (0713) ;
                                   (0714) ;  SIDE EFFECTS:
                                   (0715) ;    The A and X registers may be modified by this or future implementations
                                   (0716) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0717) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0718) ;    responsibility to perserve their values across calls to fastcall16
                                   (0719) ;    functions.
                                   (0720) ;
                                   (0721)  USB_Force:
                                   (0722) _USB_Force:
0DF6: 60 4B    MOV   REG[75],A     (0723)     mov    reg[USB_USBIO_CR0], A
0DF8: 7F       RET                 (0724)     ret                                ; Exit
                                   (0725) .ENDSECTION
                                   (0726) 
                                   (0727) .SECTION
                                   (0728) ;-----------------------------------------------------------------------------
                                   (0729) ;  FUNCTION NAME: USB_bReadOutEP
                                   (0730) ;
                                   (0731) ;  DESCRIPTION:    This function reads the data from the USB Out endpoint
                                   (0732) ;                  and loads it into the specified buffer.
                                   (0733) ;
                                   (0734) ;-----------------------------------------------------------------------------
                                   (0735) ;
                                   (0736) ;  ARGUMENTS:
                                   (0737) ;     [SP-7] MSB of Count to read
                                   (0738) ;     [SP-6] LSB of Count to read
                                   (0739) ;     [SP-5] MSB of data array address to put data in
                                   (0740) ;     [SP-4] LSB of data array address to put data in
                                   (0741) ;     [SP-3] Endpoint Number
                                   (0742) ;
                                   (0743) ;  RETURNS:
                                   (0744) ;     none
                                   (0745) ;
                                   (0746) ;  SIDE EFFECTS:
                                   (0747) ;    The A and X registers may be modified by this or future implementations
                                   (0748) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0749) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0750) ;    responsibility to perserve their values across calls to fastcall16
                                   (0751) ;    functions.
                                   (0752) ;
                                   (0753) ;    Currently only the page pointer registers listed below are modified:
                                   (0754) ;          CUR_PP
                                   (0755) ;          IDX_PP
                                   (0756) ;
                                   (0757) EP_NUMR:     equ -3                       ; Endpoint Number
                                   (0758) DATA_LSBR:   equ -4           ; MSB pointer of data
                                   (0759) DATA_MSBR:   equ -5           ; LSB pointer of data
                                   (0760) CNTLEN_LSBR: equ -6           ; Length of data to send
                                   (0761) CNTLEN_MSBR: equ -7
                                   (0762) 
                                   (0763)  USB_bReadOutEP:
                                   (0764) _USB_bReadOutEP:
                                   (0765)     RAM_PROLOGUE RAM_USE_CLASS_4
0DF9: 70 BF    AND   F,191         (0766)     RAM_PROLOGUE RAM_USE_CLASS_3
0DFB: 62 D0 00 MOV   REG[208],0    (0767)     RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
0DFE: 62 D3 03 MOV   REG[211],3    (0768)     RAM_SETPAGE_IDX2STK
0E01: 4F       MOV   X,SP          (0769)     mov     X, SP
0E02: 52 FD    MOV   A,[X-3]       (0770)     mov     A, [X+EP_NUMR]
0E04: 39 05    CMP   A,5           (0771)     cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
0E06: D0 7F    JNC   0x0E86        (0772)     jnc     .exit                      ; Bail out
                                   (0773) 
                                   (0774)     ;Get the count value passed
0E08: 52 F9    MOV   A,[X-7]       (0775)     mov     A, [X+CNTLEN_MSBR]         ; Get the MSB of the Count
0E0A: 21 01    AND   A,1           (0776)     and     A, 0x01                    ; Mask off the count bit
0E0C: 53 41    MOV   [65],A        (0777)     mov     [USB_APITemp], A           ; Save the count
0E0E: 52 FA    MOV   A,[X-6]       (0778)     mov     A, [X+CNTLEN_LSBR]         ; Get the LSB of the Count
0E10: 53 42    MOV   [66],A        (0779)     mov     [USB_APITemp+1], A         ; Save the count
                                   (0780) 
                                   (0781)     ;Determine which is smaller the requested data or the available data
0E12: 52 FD    MOV   A,[X-3]       (0782)     mov     A, [X+EP_NUMR]              ; Get the Endpoint number
0E14: 64       ASL   A             (0783)     asl     A                           ; Double the ep number for proper cnt access
0E15: 5C       MOV   X,A           (0784)     mov     X, A                        ; Make it into an index
0E16: 5E 4C    MOV   A,REG[X+76]   (0785)     mov     A, reg[X+USB_EP1CNT1 - 2]     ; Get the Real count MSB
0E18: 21 01    AND   A,1           (0786)     and     A, 0x01                     ; Mask off the LSB
0E1A: 3A 41    CMP   A,[65]        (0787)     cmp     A, [USB_APITemp]            ; Are they equal
0E1C: A0 0B    JZ    0x0E28        (0788)     jz      .MSBEqual                   ; If they are check if they are 1
0E1E: C0 1C    JC    0x0E3B        (0789)     jc      .CountDetermined            ;If the requested count is smaller use it
0E20: 53 41    MOV   [65],A        (0790)     mov     [USB_APITemp], A            ; Else use the actual
0E22: 5E 4D    MOV   A,REG[X+77]   (0791)     mov     A, reg[X+USB_EP1CNT1 - 1]     ; Get the Real count LSB
0E24: 53 42    MOV   [66],A        (0792)     mov     [USB_APITemp + 1], A        ; Else use the actual
0E26: 80 14    JMP   0x0E3B        (0793)     jmp     .CountDetermined
                                   (0794) .MSBEqual:
0E28: 51 41    MOV   A,[65]        (0795)     mov     A, [USB_APITemp]
0E2A: A0 06    JZ    0x0E31        (0796)     jz      .CheckLSB
0E2C: 55 42 00 MOV   [66],0        (0797)     mov     [USB_APITemp + 1], 0
0E2F: 80 0B    JMP   0x0E3B        (0798)     jmp         .CountDetermined
                                   (0799) .CheckLSB:
0E31: 5E 4D    MOV   A,REG[X+77]   (0800)     mov     A, reg[X+USB_EP1CNT1 - 1]     ; Get the Real count LSB
0E33: 3A 42    CMP   A,[66]        (0801)     cmp     A, [USB_APITemp+1]          ; Are they equal
0E35: A0 05    JZ    0x0E3B        (0802)     jz      .CountDetermined            ; If they are check if they are 1
0E37: D0 03    JNC   0x0E3B        (0803)     jnc      .CountDetermined           ;If the requested count is smaller use it
0E39: 53 42    MOV   [66],A        (0804)     mov     [USB_APITemp+1], A          ; Else use the actual
                                   (0805) .CountDetermined:
                                   (0806) 
                                   (0807) ; First we need to determine where within the PMA the EP Start Address is
0E3B: 4F       MOV   X,SP          (0808)     mov     X, SP                       ; Get the Stack Pointer
0E3C: 52 FD    MOV   A,[X-3]       (0809)     mov     A, [X+EP_NUMR]              ; Get the Endpoint number
0E3E: 5C       MOV   X,A           (0810)     mov     X, A                        ; Use the EP number as an index
0E3F: 5E 6B    MOV   A,REG[X+107]  (0811)     mov     A, reg[X+TMP_DR0-1]         ; Get the address of ep from tmp register
0E41: 71 10    OR    F,16          (0812)     M8C_SetBank1
0E43: 70 FE    AND   F,254         (0813)     M8C_DisableGInt	     ; bug 11658
0E45: 60 50    MOV   REG[80],A     (0814)     mov     reg[PMA0_RA], A             ; Set the Read pointer of our pma to ep space
0E47: 71 01    OR    F,1           (0815)     M8C_EnableGInt       ; bug 11658
0E49: 70 EF    AND   F,239         (0816)     M8C_SetBank0
                                   (0817) 
                                   (0818) ; Now we are ready to start moving data
0E4B: 26 41 01 AND   [65],1        (0819)     and     [USB_APITemp], 0x01         ; Mask off the MSB bit
0E4E: B0 05    JNZ   0x0E54        (0820)     jnz     .start_send                 ; If it is high then we have 256 bytes
0E50: 51 42    MOV   A,[66]        (0821)     mov     A, [USB_APITemp+1]          ; Check the LSB register
0E52: A0 33    JZ    0x0E86        (0822)     jz      .done                       ; If it is 0 then we have a 0 length packet
                                   (0823) 
                                   (0824) .start_send:
0E54: 4F       MOV   X,SP          (0825)     mov     X, SP
0E55: 52 FC    MOV   A,[X-4]       (0826)     mov     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
0E57: 08       PUSH  A             (0827)     push    A                           ; save on stack
                                   (0828) IF SYSTEM_LARGE_MEMORY_MODEL
0E58: 52 FB    MOV   A,[X-5]       (0829)     mov     A, [X+DATA_MSBR]            ; Get the MSB of the pointer
0E5A: 60 D3    MOV   REG[211],A    (0830)     mov     reg[IDX_PP], A              ; Use as value for IDX_PP
                                   (0831) ENDIF
0E5C: 20       POP   X             (0832)     pop     X                           ; Get the LSB again
                                   (0833) 
                                   (0834)         ;;
                                   (0835)         ;; 24Mhz read PMA workaround (kvn)
                                   (0836)         ;;
0E5D: 71 10    OR    F,16          (0837)     M8C_SetBank1
0E5F: 5D E0    MOV   A,REG[224]    (0838)     mov     A, reg[OSC_CR0]
0E61: 08       PUSH  A             (0839)     push    A
0E62: 21 F8    AND   A,248         (0840)     and     A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
0E64: 29 02    OR    A,2           (0841)     or      A, 0x02 ;will set clk to 12Mhz
0E66: 60 E0    MOV   REG[224],A    (0842)     mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
0E68: 70 EF    AND   F,239         (0843)     M8C_SetBank0
                                   (0844) 
                                   (0845) .loop:
0E6A: 5D 40    MOV   A,REG[64]     (0846)     mov     A, reg[PMA0_DR]             ; Get the data from the PMA space
0E6C: 54 00    MOV   [X+0],A       (0847)     mov    [X], A                       ; save it in data array
0E6E: 75       INC   X             (0848)     inc     X                           ; increment the pointer
0E6F: 7A 42    DEC   [66]          (0849)     dec     [USB_APITemp+1]             ; decrement the counter
0E71: BF F8    JNZ   0x0E6A        (0850)     jnz     .loop                       ; wait for count to zero out
                                   (0851) 
                                   (0852)         ;;
                                   (0853)         ;; 24Mhz read PMA workaround (back to previous clock speed (kvn)
                                   (0854)         ;;
0E73: 18       POP   A             (0855)     pop     A ;recover previous reg[OSC_CR0] value
0E74: 71 10    OR    F,16          (0856)     M8C_SetBank1
0E76: 60 E0    MOV   REG[224],A    (0857)     mov     reg[OSC_CR0], A ;clk is now set at previous value (probably 24Mhz)
0E78: 70 EF    AND   F,239         (0858)     M8C_SetBank0
                                   (0859)         ;;
                                   (0860)         ;; end 24Mhz read PMA workaround (kvn)
                                   (0861)         ;;
                                   (0862) 
0E7A: 62 D3 03 MOV   REG[211],3    (0863)     RAM_SETPAGE_IDX2STK
0E7D: 4F       MOV   X,SP          (0864)     mov     X, SP
0E7E: 52 FD    MOV   A,[X-3]       (0865)     mov     A, [X+EP_NUMR]
0E80: 64       ASL   A             (0866)     asl     A
0E81: 5C       MOV   X,A           (0867)     mov     X, A
0E82: 5E 4D    MOV   A,REG[X+77]   (0868)     mov     A, reg[X+USB_EP1CNT1 - 1]     ; Get the Real count LSB
0E84: 11 02    SUB   A,2           (0869)     sub     A, 2
0E86: 70 3F    AND   F,63
                                   (0870) .done:
                                   (0871) .exit:
0E88: 71 C0    OR    F,192         (0872)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0873)     RAM_EPILOGUE RAM_USE_CLASS_4
0E8A: 7F       RET                 (0874)     ret
                                   (0875) .ENDSECTION
                                   (0876) 
                                   (0877) .SECTION
                                   (0878) ;-----------------------------------------------------------------------------
                                   (0879) ;  FUNCTION NAME: USB_bGetEPAckState
                                   (0880) ;
                                   (0881) ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
                                   (0882) ;                 an endpoint
                                   (0883) ;
                                   (0884) ;-----------------------------------------------------------------------------
                                   (0885) ;
                                   (0886) ;  ARGUMENTS:     A is the Endpoint Number
                                   (0887) ;
                                   (0888) ;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
                                   (0889) ;
                                   (0890) ;  SIDE EFFECTS:
                                   (0891) ;    The A and X registers may be modified by this or future implementations
                                   (0892) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0893) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0894) ;    responsibility to perserve their values across calls to fastcall16
                                   (0895) ;    functions.
                                   (0896) ;
                                   (0897)  USB_bGetEPAckState:
                                   (0898) _USB_bGetEPAckState:
0E8B: 5C       MOV   X,A           (0899)     mov    X, A
0E8C: 71 10    OR    F,16          (0900)     M8C_SetBank1
0E8E: 5E C3    MOV   A,REG[X+195]  (0901)     mov    A, reg[X + USB_EP1MODE-1]
0E90: 70 EF    AND   F,239         (0902)     M8C_SetBank0
0E92: 21 10    AND   A,16          (0903)     and    A, 0x10
0E94: 7F       RET                 (0904)     ret                                ; Exit
                                   (0905) .ENDSECTION
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: USB_SetPowerStatus
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:    Set The Current Power status.
                                   (0912) ;
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
                                   (0915) ;  ARGUMENTS:      A contains the power status
                                   (0916) ;
                                   (0917) ;  RETURNS:        None
                                   (0918) ;
                                   (0919) ;  SIDE EFFECTS:
                                   (0920) ;    The A and X registers may be modified by this or future implementations
                                   (0921) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0922) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0923) ;    responsibility to perserve their values across calls to fastcall16
                                   (0924) ;    functions.
                                   (0925) ;
                                   (0926)  USB_SetPowerStatus:
                                   (0927) _USB_SetPowerStatus:
                                   (0928)     RAM_PROLOGUE RAM_USE_CLASS_4
0E95: 62 D0 00 MOV   REG[208],0    (0929)     RAM_SETPAGE_CUR >USB_DeviceStatus
0E98: 39 00    CMP   A,0           (0930)     cmp     A, 0
0E9A: A0 06    JZ    0x0EA1        (0931)     jz      .bus_powered
0E9C: 2E 02 01 OR    [2],1         (0932)     or      [USB_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
0E9F: 80 04    JMP   0x0EA4        (0933)     jmp     .done
                                   (0934) .bus_powered:
0EA1: 26 02 FE AND   [2],254       (0935)     and     [USB_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
                                   (0936) .done:
                                   (0937)     RAM_EPILOGUE RAM_USE_CLASS_4
0EA4: 7F       RET                 (0938)     ret                                ; All done

FILE: .\main.c
(0001) /******************************************************************************\
(0002) |*  Project Name:  BULK_cyusb			           							  *|
(0003) |*  Author(s):     Robert Birch (BRW), Cypress Semiconductor                  *|
(0004) |*  Date:          2008/June/24                                               *|
(0005) |*  Description:   This project implements a INTERRUPT endpoint USB device    *|
(0006) |*                                                                            *|
(0007) |*  Warning:	                                                     		  *|
(0008) |*  Memos:                                                                    *|
(0009) |*----------------------------------------------------------------------------*|
(0010) |*  Communication: USB                                                        *|
(0011) |*----------------------------------------------------------------------------*|
(0012) |*  LEGAL NOTICE:                                                             *|
(0013) |*  Cypress Source Code: Copyright 2007, Cypress Semiconductor Corporation.  *|
(0014) |*  This Source Code (software and/or firmware) is owned by Cypress           *|
(0015) |*  Semiconductor Corporation (Cypress) and is protected by and subject to    *|
(0016) |*  worldwide patent protection (United States and foreign), United States    *|
(0017) |*  copyright laws and international treaty provisions. Cypress hereby grants *|
(0018) |*  to licensee a personal, non-exclusive, non-transferable license to copy,  *|
(0019) |*  use, modify, create derivative works of, and compile the Cypress Source   *|
(0020) |*  Code and derivative works for the sole purpose of creating custom         *|
(0021) |*  software and or firmware in support of licensee product to be used only   *|
(0022) |*  in conjunction with a Cypress integrated circuit as specified in the      *|
(0023) |*  applicable agreement. Any reproduction, modification, translation,        *|
(0024) |*  compilation, or representation of this Source Code except as specified    *|
(0025) |*  above is prohibited without the express written permission of Cypress.    *|
(0026) |*                                                                            *|
(0027) |*  Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,    *|
(0028) |*  WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  *|
(0029) |*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.       *|
(0030) |*  Cypress reserves the right to make changes without further notice to the  *|
(0031) |*  materials described herein. Cypress does not assume any liability arising *|
(0032) |*  out of the application or use of any product or circuit described herein. *|
(0033) |*  Cypress does not authorize its products for use as critical components in *|
(0034) |*  life-support systems where a malfunction or failure may reasonably be     *|
(0035) |*  expected to result in significant injury to the user. The inclusion of    *|
(0036) |*  Cypress product in a life-support systems application implies that the   *|
(0037) |*  manufacturer assumes all risk of such use and in doing so indemnifies     *|
(0038) |*  Cypress against all charges.                                              *|
(0039) |*                                                                            *|
(0040) |*  Use may be limited by and subject to the applicable Cypress software      *|
(0041) |*  license agreement.                                                        *|
(0042) \******************************************************************************/
(0043) 
(0044) #include <m8c.h>        // part specific constants and macros
(0045) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0046) 
(0047) 
(0048) /* LOCAL VARIABLES */
(0049) /*******************/
(0050) BYTE l_bUSB_Once_Toggle ;			// USB
(0051) BYTE l_abUSB_InBuffer[64];			// USB
(0052) BYTE l_abUSB_OutBuffer[64];			// USB
(0053) 
(0054) 
(0055) void main()
(0056) {
(0057) 	// **************************************************************************************************
(0058) 	// 1. INITIALIZE
(0059) 	// 
(0060) 	M8C_EnableGInt ;	
_main:
__text_start:
0EA5: 71 01    OR    F,1
(0061) 
(0062)     // USB	
(0063) 	USB_Start(0, USB_5V_OPERATION);   	//Start USB Operation using device 0 with 5V operation  
0EA7: 10       PUSH  X
0EA8: 57 03    MOV   X,3
0EAA: 50 00    MOV   A,0
0EAC: 7C 0C 4C LCALL 0x0C4C
0EAF: 20       POP   X
(0064)     while(!USB_bGetConfiguration());    //Wait for Device to enumerate  
0EB0: 10       PUSH  X
0EB1: 7C 0C B7 LCALL 0x0CB7
0EB4: 20       POP   X
0EB5: 39 00    CMP   A,0
0EB7: AF F8    JZ    0x0EB0
(0065)     USB_INT_REG |= USB_INT_EP1_MASK | USB_INT_EP2_MASK ;
0EB9: 43 DF 18 OR    REG[223],24
(0066) 	
(0067) 	l_bUSB_Once_Toggle = 1 ;
0EBC: 62 D0 00 MOV   REG[208],0
0EBF: 55 C9 01 MOV   [l_bUSB_Once_Toggle],1
0EC2: 80 8E    JMP   0x0F51
(0068) 	
(0069) 	// **************************************************************************************************
(0070) 	// 2. MAIN LOOP
(0071) 	//
(0072) 	while (1) {
(0073) 	
(0074) 		// 2a. Gather and Process data ie: capsense, ADC
(0075) 		// 
(0076) 		l_abUSB_InBuffer[0]++ ;		
0EC4: 62 D0 00 MOV   REG[208],0
0EC7: 76 87    INC   [l_abUSB_InBuffer]
(0077) 		
(0078) 		
(0079) 		// 2b. Transfer data to SIE preparing for tranfer to the host with proper TOGGLE
(0080) 		//
(0081) 		if (l_bUSB_Once_Toggle) {
0EC9: 62 D0 00 MOV   REG[208],0
0ECC: 3C C9 00 CMP   [l_bUSB_Once_Toggle],0
0ECF: A0 22    JZ    0x0EF2
(0082) 			l_bUSB_Once_Toggle = 0 ;
0ED1: 55 C9 00 MOV   [l_bUSB_Once_Toggle],0
(0083) 			USB_LoadInEP(1, l_abUSB_InBuffer, 64, USB_NO_TOGGLE);
0ED4: 10       PUSH  X
0ED5: 50 00    MOV   A,0
0ED7: 08       PUSH  A
0ED8: 08       PUSH  A
0ED9: 50 40    MOV   A,64
0EDB: 08       PUSH  A
0EDC: 50 00    MOV   A,0
0EDE: 08       PUSH  A
0EDF: 50 87    MOV   A,135
0EE1: 08       PUSH  A
0EE2: 50 01    MOV   A,1
0EE4: 08       PUSH  A
0EE5: 7C 0C FA LCALL 0x0CFA
0EE8: 38 FA    ADD   SP,250
(0084) 			USB_EnableOutEP(2);
0EEA: 50 02    MOV   A,2
0EEC: 7C 0D AD LCALL 0x0DAD
0EEF: 20       POP   X
(0085) 		} else {
0EF0: 80 1A    JMP   0x0F0B
(0086) 	    	USB_LoadInEP(1, l_abUSB_InBuffer, 64, USB_TOGGLE);  		
0EF2: 10       PUSH  X
0EF3: 50 01    MOV   A,1
0EF5: 08       PUSH  A
0EF6: 50 00    MOV   A,0
0EF8: 08       PUSH  A
0EF9: 50 40    MOV   A,64
0EFB: 08       PUSH  A
0EFC: 50 00    MOV   A,0
0EFE: 08       PUSH  A
0EFF: 50 87    MOV   A,135
0F01: 08       PUSH  A
0F02: 50 01    MOV   A,1
0F04: 08       PUSH  A
0F05: 7C 0C FA LCALL 0x0CFA
0F08: 38 FA    ADD   SP,250
0F0A: 20       POP   X
(0087) 	    }
(0088) 
(0089) 
(0090) 		// 2c. Block on IN tranfer but give a chance on incomming
(0091) 		//
(0092)     	do {
(0093) 		
(0094) 			// 2c1. Process communication from host.
(0095) 			//
(0096) 			if (USB_bGetEPState(2) == OUT_BUFFER_FULL) {
0F0B: 10       PUSH  X
0F0C: 50 02    MOV   A,2
0F0E: 7C 0C BD LCALL 0x0CBD
0F11: 62 D0 00 MOV   REG[208],0
0F14: 20       POP   X
0F15: 39 01    CMP   A,1
0F17: B0 28    JNZ   0x0F40
(0097) 				USB_bReadOutEP(2, l_abUSB_OutBuffer, 64);
0F19: 10       PUSH  X
0F1A: 50 00    MOV   A,0
0F1C: 08       PUSH  A
0F1D: 50 40    MOV   A,64
0F1F: 08       PUSH  A
0F20: 50 00    MOV   A,0
0F22: 08       PUSH  A
0F23: 50 47    MOV   A,71
0F25: 08       PUSH  A
0F26: 50 02    MOV   A,2
0F28: 08       PUSH  A
0F29: 7C 0D F9 LCALL 0x0DF9
0F2C: 62 D0 00 MOV   REG[208],0
0F2F: 38 FB    ADD   SP,251
0F31: 20       POP   X
(0098) 				USB_EnableOutEP(2); 
0F32: 10       PUSH  X
0F33: 50 02    MOV   A,2
0F35: 7C 0D AD LCALL 0x0DAD
0F38: 20       POP   X
(0099) 				PRT0DR = l_abUSB_OutBuffer[0] ;
0F39: 62 D0 00 MOV   REG[208],0
0F3C: 51 47    MOV   A,[l_abUSB_OutBuffer]
0F3E: 60 00    MOV   REG[0],A
(0100)     		}
(0101) 		} while (USB_bGetEPState(1) == IN_BUFFER_FULL) ;
0F40: 10       PUSH  X
0F41: 50 01    MOV   A,1
0F43: 7C 0C BD LCALL 0x0CBD
0F46: 62 D0 00 MOV   REG[208],0
0F49: 20       POP   X
0F4A: 39 00    CMP   A,0
0F4C: AF BE    JZ    0x0F0B
(0102) 	
(0103) 		PRT2DR ^= 0x01;
0F4E: 45 08 01 XOR   REG[8],1
0F51: 8F 72    JMP   0x0EC4
(0104) 	}
(0105) }
0F53: 8F FF    JMP   0x0F53

FILE: lib\usbint.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USBCommon.asm
                                   (0004) ;;  Version: 1.3, Updated on 2007/09/28 at 14:23:41
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2004, 2005. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "USB.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name refence for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    USB_EP1_ISR
                                   (0044) export   _USB_EP1_ISR
                                   (0045) export    USB_EP2_ISR
                                   (0046) export   _USB_EP2_ISR
                                   (0047) export    USB_EP3_ISR
                                   (0048) export   _USB_EP3_ISR
                                   (0049) export    USB_EP4_ISR
                                   (0050) export   _USB_EP4_ISR
                                   (0051) export    USB_RESET_ISR
                                   (0052) export   _USB_RESET_ISR
                                   (0053) export    USB_SOF_ISR
                                   (0054) export   _USB_SOF_ISR
                                   (0055) export    USB_WAKEUP_ISR
                                   (0056) export   _USB_WAKEUP_ISR
                                   (0057) 
                                   (0058) 
                                   (0059) AREA InterruptRAM (RAM, REL, CON)
                                   (0060) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0061) ;---------------------------------------------------
                                   (0062) ; Insert your custom declarations below this banner
                                   (0063) ;---------------------------------------------------
                                   (0064) 
                                   (0065) ;------------------------
                                   (0066) ; Includes
                                   (0067) ;------------------------
                                   (0068) 
                                   (0069) 
                                   (0070) ;------------------------
                                   (0071) ;  Constant Definitions
                                   (0072) ;------------------------
                                   (0073) 
                                   (0074) 
                                   (0075) ;------------------------
                                   (0076) ; Variable Allocation
                                   (0077) ;------------------------
                                   (0078) 
                                   (0079) 
                                   (0080) ;---------------------------------------------------
                                   (0081) ; Insert your custom declarations above this banner
                                   (0082) ;---------------------------------------------------
                                   (0083) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0084) 
                                   (0085) AREA text (ROM, REL)
                                   (0086) 
                                   (0087) ;-----------------------------------------------------------------------------
                                   (0088) ;  FUNCTION NAME: USB_EP1_ISR
                                   (0089) ;
                                   (0090) ;  DESCRIPTION:    Handle the Endpoint 1 event by updating the data toggle
                                   (0091) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                   (0092) ;                  automatically set the mode to NAK both IN and out transfers
                                   (0093) ;-----------------------------------------------------------------------------
                                   (0094) export  USB_EP1_ISR
                                   (0095) export _USB_EP1_ISR
                                   (0096)  USB_EP1_ISR:
                                   (0097) _USB_EP1_ISR:
                                   (0098)    ;@PSoC_UserCode_BODY_EP1@ (Do not change this line.)
                                   (0099)    ;---------------------------------------------------
                                   (0100)    ; Insert your custom code below this banner
                                   (0101)    ;---------------------------------------------------
                                   (0102)    ;   NOTE: interrupt service routines must preserve
                                   (0103)    ;   the values of the A and X CPU registers.
                                   (0104) STD_EP1:    EQU     1   ; Set this equate to 0 to remove the standard
                                   (0105)                         ; endpoint handling code
                                   (0106)    ;---------------------------------------------------
                                   (0107)    ; Insert your custom code above this banner
                                   (0108)    ;---------------------------------------------------
                                   (0109)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0110) 
                                   (0111) IF  STD_EP1
0F55: 08       PUSH  A             (0112)     push    A
0F56: 36 1C 02 XOR   [28],2        (0113)     xor     [USB_EPDataToggle], 2 ; Update EP1 data toggle
0F59: 71 10    OR    F,16          (0114)     M8C_SetBank1	; _EP1MODE is in Bank 1
0F5B: 5D C4    MOV   A,REG[196]    (0115)     mov     A, reg[USB_EP1MODE]        ; Get the mode
0F5D: 70 EF    AND   F,239         (0116) 	M8C_SetBank0
0F5F: 55 22 01 MOV   [34],1        (0117)     mov     [USB_EndpointAPIStatus+1], EVENT_PENDING ; For the API
0F62: 18       POP   A             (0118)     pop     A
0F63: 7E       RETI                (0119)     reti
                                   (0120) ENDIF
                                   (0121) 
                                   (0122) ;-----------------------------------------------------------------------------
                                   (0123) ;  FUNCTION NAME: USB_EP2_ISR
                                   (0124) ;
                                   (0125) ;  DESCRIPTION:    Handle the Endpoint 2 event by updating the data toggle
                                   (0126) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                   (0127) ;                  automatically set the mode to NAK both IN and out transfers
                                   (0128) ;-----------------------------------------------------------------------------
                                   (0129) export  USB_EP2_ISR
                                   (0130) export _USB_EP2_ISR
                                   (0131)  USB_EP2_ISR:
                                   (0132) _USB_EP2_ISR:
                                   (0133) 
                                   (0134)    ;@PSoC_UserCode_BODY_EP2@ (Do not change this line.)
                                   (0135)    ;---------------------------------------------------
                                   (0136)    ; Insert your custom code below this banner
                                   (0137)    ;---------------------------------------------------
                                   (0138)    ;   NOTE: interrupt service routines must preserve
                                   (0139)    ;   the values of the A and X CPU registers.
                                   (0140) STD_EP2:    EQU     1   ; Set this equate to 0 to remove the standard
                                   (0141)                         ; endpoint handling code
                                   (0142)    ;---------------------------------------------------
                                   (0143)    ; Insert your custom code above this banner
                                   (0144)    ;---------------------------------------------------
                                   (0145)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0146) 
                                   (0147) IF  STD_EP2
0F64: 08       PUSH  A             (0148)     push    A
0F65: 36 1C 04 XOR   [28],4        (0149)     xor     [USB_EPDataToggle], 4 ; Update EP2 data toggle
0F68: 71 10    OR    F,16          (0150)     M8C_SetBank1
0F6A: 5D C5    MOV   A,REG[197]    (0151)     mov     A, reg[USB_EP2MODE]        ; Get the mode
0F6C: 70 EF    AND   F,239         (0152)     M8C_SetBank0
0F6E: 55 23 01 MOV   [35],1        (0153)     mov     [USB_EndpointAPIStatus + 2], EVENT_PENDING ; For the API
0F71: 18       POP   A             (0154)     pop     A
0F72: 7E       RETI                (0155)     reti
                                   (0156) ENDIF
                                   (0157) 
                                   (0158) 
                                   (0159) ;-----------------------------------------------------------------------------
                                   (0160) ;  FUNCTION NAME: USB_EP3_ISR
                                   (0161) ;
                                   (0162) ;  DESCRIPTION:    Handle the Endpoint 3 event by updating the data toggle
                                   (0163) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                   (0164) ;                  automatically set the mode to NAK both IN and out transfers
                                   (0165) ;-----------------------------------------------------------------------------
                                   (0166)  USB_EP3_ISR:
                                   (0167) _USB_EP3_ISR:
                                   (0168) 
                                   (0169)    ;@PSoC_UserCode_BODY_EP3@ (Do not change this line.)
                                   (0170)    ;---------------------------------------------------
                                   (0171)    ; Insert your custom code below this banner
                                   (0172)    ;---------------------------------------------------
                                   (0173)    ;   NOTE: interrupt service routines must preserve
                                   (0174)    ;   the values of the A and X CPU registers.
                                   (0175) STD_EP3:    EQU     1   ; Set this equate to 0 to remove the standard
                                   (0176)                         ; endpoint handling code
                                   (0177)    ;---------------------------------------------------
                                   (0178)    ; Insert your custom code above this banner
                                   (0179)    ;---------------------------------------------------
                                   (0180)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0181) 
                                   (0182) IF  STD_EP3
0F73: 08       PUSH  A             (0183)     push    A
0F74: 36 1C 08 XOR   [28],8        (0184)     xor     [USB_EPDataToggle], 8 ; Update EP3 data toggle
0F77: 71 10    OR    F,16          (0185)     M8C_SetBank1
0F79: 5D C6    MOV   A,REG[198]    (0186)     mov     A, reg[USB_EP3MODE]        ; Get the mode
0F7B: 70 EF    AND   F,239         (0187)     M8C_SetBank0
0F7D: 55 24 01 MOV   [36],1        (0188)     mov     [USB_EndpointAPIStatus + 3], EVENT_PENDING ; For the API
0F80: 18       POP   A             (0189)     pop     A
0F81: 7E       RETI                (0190)     reti
                                   (0191) ENDIF
                                   (0192) 
                                   (0193) 
                                   (0194) ;-----------------------------------------------------------------------------
                                   (0195) ;  FUNCTION NAME: USB_EP4_ISR
                                   (0196) ;
                                   (0197) ;  DESCRIPTION:    Handle the Endpoint 4 event by updating the data toggle
                                   (0198) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                   (0199) ;                  automatically set the mode to NAK both IN and out transfers
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201)  USB_EP4_ISR:
                                   (0202) _USB_EP4_ISR:
                                   (0203) 
                                   (0204)    ;@PSoC_UserCode_BODY_EP4@ (Do not change this line.)
                                   (0205)    ;---------------------------------------------------
                                   (0206)    ; Insert your custom code below this banner
                                   (0207)    ;---------------------------------------------------
                                   (0208)    ;   NOTE: interrupt service routines must preserve
                                   (0209)    ;   the values of the A and X CPU registers.
                                   (0210) STD_EP4:    EQU     1   ; Set this equate to 0 to remove the standard
                                   (0211)                         ; endpoint handling code
                                   (0212)    ;---------------------------------------------------
                                   (0213)    ; Insert your custom code above this banner
                                   (0214)    ;---------------------------------------------------
                                   (0215)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0216) 
                                   (0217) IF  STD_EP4
0F82: 08       PUSH  A             (0218)     push    A
0F83: 36 1C 10 XOR   [28],16       (0219)     xor     [USB_EPDataToggle], 16 ; Update EP4 data toggle
0F86: 71 10    OR    F,16          (0220)     M8C_SetBank1
0F88: 5D C7    MOV   A,REG[199]    (0221)     mov     A, reg[USB_EP4MODE]        ; Get the mode
0F8A: 70 EF    AND   F,239         (0222)     M8C_SetBank0
0F8C: 55 25 01 MOV   [37],1        (0223)     mov     [USB_EndpointAPIStatus + 4], EVENT_PENDING ; For the API
0F8F: 18       POP   A             (0224)     pop     A
0F90: 7E       RETI                (0225)     reti
                                   (0226) ENDIF
                                   (0227) 
                                   (0228) 
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;  FUNCTION NAME: USB_RESET_ISR
                                   (0231) ;
                                   (0232) ;  DESCRIPTION:    Handle the USB Bus Reset Interrupt
                                   (0233) ;-----------------------------------------------------------------------------
                                   (0234) export  USB_RESET_ISR
                                   (0235) export _USB_RESET_ISR
                                   (0236)  USB_RESET_ISR:
                                   (0237) _USB_RESET_ISR:
                                   (0238) ;   mov     [USB_Configuration], 0
                                   (0239) ;   mov     [USB_DeviceStatus], 0
                                   (0240) ;   mov     [USB_InterfaceSetting], 0
                                   (0241) ;   mov     [USB_EndpointStatus], 0
                                   (0242) ;   mov     [USB_TransferType], 0
                                   (0243) ;   mov     [USB_fDataPending], 0
                                   (0244) ;   mov     reg[USB_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
                                   (0245) ;   mov     reg[USB_EP1MODE], 0
                                   (0246) ;   mov     reg[USB_EP2MODE], 0
                                   (0247) ;   mov     reg[USB_EP3MODE], 0
                                   (0248) ;   mov     reg[USB_EP4MODE], 0
                                   (0249) ;   mov     X, USB_MAX_EP_NUMBER       ; Set up loop to clear all of the endpoint data items
                                   (0250) ;.loop:
                                   (0251) ;   mov     [X + USB_EPDataToggle], 0  ; Or in the toggle
                                   (0252) ;   dec     X                          ; Are we done?
                                   (0253) ;   jnz     .loop                      ; Jump to do another endpoint
                                   (0254) 
                                   (0255) ;   mov     reg[USB_ADDR], USB_ADDR_ENABLE ; Enable Address 0
                                   (0256) 
                                   (0257)    ;@PSoC_UserCode_BODY_USB_RESET@ (Do not change this line.)
                                   (0258)    ;---------------------------------------------------
                                   (0259)    ; Insert your custom code below this banner
                                   (0260)    ;---------------------------------------------------
                                   (0261)    ;   NOTE: interrupt service routines must preserve
                                   (0262)    ;   the values of the A and X CPU registers.
                                   (0263) 
                                   (0264) STD_USB_RESET:    EQU     1 ; Set this equate to 0 to remove the standard
                                   (0265)                             ; USB reset handling code below
                                   (0266) 
                                   (0267)    ;---------------------------------------------------
                                   (0268)    ; Insert your custom code above this banner
                                   (0269)    ;---------------------------------------------------
                                   (0270)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0271) 
                                   (0272) IF  STD_USB_RESET
0F91: 08       PUSH  A             (0273) 	push 	A
0F92: 10       PUSH  X             (0274) 	push    X
0F93: 5D D0    MOV   A,REG[208]
0F95: 08       PUSH  A             (0275)     ISR_PRESERVE_PAGE_POINTERS
0F96: 5D D3    MOV   A,REG[211]
0F98: 08       PUSH  A
0F99: 5D D4    MOV   A,REG[212]
0F9B: 08       PUSH  A
0F9C: 5D D5    MOV   A,REG[213]
0F9E: 08       PUSH  A
0F9F: 71 10    OR    F,16          (0276) 	M8C_SetBank1
0FA1: 5D C1    MOV   A,REG[193]    (0277) 	mov		A, reg[USB_USB_CR1]		            ; Get the RegEnable
0FA3: 70 EF    AND   F,239         (0278) 	M8C_SetBank0
0FA5: 21 03    AND   A,3           (0279) 	and 	A, 0x03                          ; mask off the RegEnable and EnableLock bits
0FA7: 5C       MOV   X,A           (0280) 	mov		X, A                             ; save value in X
0FA8: 51 00    MOV   A,[0]         (0281)     mov     A, [USB_bCurrentDevice]     ; Select the current device
0FAA: 70 3F    AND   F,63
0FAC: 71 C0    OR    F,192         (0282)     RAM_RESTORE_NATIVE_PAGING
0FAE: 7C 0C 4C LCALL 0x0C4C        (0283) 	lcall   _USB_Start     ; Restart USB
0FB1: 18       POP   A
0FB2: 60 D5    MOV   REG[213],A    (0284)     ISR_RESTORE_PAGE_POINTERS
0FB4: 18       POP   A
0FB5: 60 D4    MOV   REG[212],A
0FB7: 18       POP   A
0FB8: 60 D3    MOV   REG[211],A
0FBA: 18       POP   A
0FBB: 60 D0    MOV   REG[208],A
0FBD: 20       POP   X             (0285)     pop X
0FBE: 18       POP   A             (0286)     pop A
                                   (0287) 
                                   (0288) ENDIF
                                   (0289) 
0FBF: 7E       RETI                (0290) 	reti
                                   (0291) 
                                   (0292) 
                                   (0293) 
                                   (0294)  USB_SOF_ISR:
                                   (0295) _USB_SOF_ISR:
                                   (0296) 
                                   (0297)    ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
                                   (0298)    ;---------------------------------------------------
                                   (0299)    ; Insert your custom code below this banner
                                   (0300)    ;---------------------------------------------------
                                   (0301)    ;   NOTE: interrupt service routines must preserve
                                   (0302)    ;   the values of the A and X CPU registers.
                                   (0303) 
                                   (0304)    ;---------------------------------------------------
                                   (0305)    ; Insert your custom code above this banner
                                   (0306)    ;---------------------------------------------------
                                   (0307)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0308) 
0FC0: 7E       RETI                (0309)    reti
                                   (0310) 
                                   (0311)  USB_WAKEUP_ISR:
                                   (0312) _USB_WAKEUP_ISR:
                                   (0313) 
                                   (0314)    ;@PSoC_UserCode_BODY_7@ (Do not change this line.)
                                   (0315)    ;---------------------------------------------------
                                   (0316)    ; Insert your custom code below this banner
                                   (0317)    ;---------------------------------------------------
                                   (0318)    ;   NOTE: interrupt service routines must preserve
                                   (0319)    ;   the values of the A and X CPU registers.
                                   (0320) 
                                   (0321)    ;---------------------------------------------------
                                   (0322)    ; Insert your custom code above this banner
                                   (0323)    ;---------------------------------------------------
                                   (0324)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0325) 
                                   (0326)    reti

FILE: <library>
USB_WAKEUP_ISR:
_USB_WAKEUP_ISR:
0FC1: 7E       RETI  
--------------------------------------------------------------------------------


PSoC Designer Version: 4.4.1184

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.09
ICCM8C version V1.69A
